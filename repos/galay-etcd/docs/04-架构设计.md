# 04-架构设计

## 整体分层

Galay-etcd 采用分层实现：

```text
Application
  ├─ Async API (AsyncEtcdClient)
  └─ Sync API  (EtcdClient)
        ↓
Protocol (HTTP/JSON over etcd v3 API)
        ↓
Base (EtcdConfig / EtcdError / EtcdValue)
        ↓
Galay-Kernel (Runtime / IOScheduler / TcpSocket / CustomAwaitable)
        ↓
Galay-HTTP (HttpSession / HttpRequest / HttpResponse)
```

## 模块职责

### Base

- `EtcdConfig`：连接配置（endpoint、api_prefix）
- `EtcdError`：统一错误模型
- `EtcdValue`：键值对数据结构（EtcdKeyValue）

### Async

- `AsyncEtcdClient`：异步客户端
- `AsyncEtcdConfig`：异步超时与缓冲参数（`EtcdNetworkConfig` 的类型别名）
- 自定义 Awaitable：ConnectAwaitable、PutAwaitable、GetAwaitable、DeleteAwaitable、GrantLeaseAwaitable、KeepAliveAwaitable、PipelineAwaitable

### Sync

- `EtcdClient`：同步阻塞接口

## 异步链式 Awaitable

异步路径基于 `galay::kernel::CustomAwaitable`，通过组合 TcpSocket I/O 与 HttpSession 构成协议链。

### Connect 流程

`ConnectAwaitable` 链路：

```text
TcpSocket::connect(host, port) -> 建立 TCP 连接
```

连接成功后，客户端持有 TcpSocket 和 HttpSession 实例，用于后续请求。

### KV 操作流程

`PutAwaitable` / `GetAwaitable` / `DeleteAwaitable` 链路：

```text
构造 HTTP POST 请求 -> HttpSessionAwaitable 发送请求 -> 接收响应 -> 解析 JSON
```

内部使用 `PostJsonAwaitable` 封装完整的 HTTP 请求/响应周期：

1. 构造 HTTP POST 请求（Content-Type: application/json）
2. 通过 HttpSession 发送请求
3. 接收完整 HTTP 响应
4. 解析 JSON 响应体
5. 提取 etcd 错误码和业务数据

### Lease 流程

- `GrantLeaseAwaitable`：`POST /v3/lease/grant`，返回 lease_id
- `KeepAliveAwaitable`：`POST /v3/lease/keepalive`，续约指定 lease_id

### Pipeline 流程

`PipelineAwaitable` 链路：

```text
构造 txn 请求（success ops） -> POST /v3/kv/txn -> 解析多个操作结果
```

Pipeline 使用 etcd 的事务 API（txn），将多个操作打包为一个请求，减少网络往返。

## Await 返回语义

异步接口返回值统一是 `std::expected<void, EtcdError>`：

- `!expected`：出错，`expected.error()` 为错误详情
- `expected`：成功，通过 `lastXxx()` 方法获取结果

该语义用于 `connect/put/get/del/grantLease/keepAliveOnce/pipeline`。

## 关键约束

- 同一个 `AsyncEtcdClient` 实例应串行执行请求，不建议并发复用同一个实例发起多条异步命令。
- 生产环境建议设置 `EtcdNetworkConfig`（或 `AsyncEtcdConfig`）超时参数，避免无限等待。
- etcd v3 API 使用 HTTP/JSON 协议，所有请求均为 POST 方法。

## 错误模型

全部接口使用 `std::expected`，错误分类由 `EtcdErrorType` 提供：

- `Success`：无错误
- `InvalidEndpoint`：端点地址无效
- `InvalidParam`：参数错误
- `NotConnected`：未连接
- `Connection`：连接错误
- `Timeout`：超时
- `Send`：发送错误
- `Recv`：接收错误
- `Http`：HTTP 错误
- `Server`：etcd 服务端错误
- `Parse`：JSON 解析错误
- `Internal`：内部错误

相较异常，错误路径更可控，便于高并发场景下统一日志与重试策略。

## 内存管理

### HttpSession 复用

异步客户端复用 `HttpSession` 实例，避免每次请求创建新的 session 和 ring buffer。

### 结果集缓存

客户端内部缓存最近一次操作的结果：

- `m_last_kvs`：最近一次 get 操作的键值对列表
- `m_last_pipeline_results`：最近一次 pipeline 操作的结果列表
- `m_last_response_body`：最近一次 HTTP 响应体

上层通过 `lastKeyValues()` 等方法获取只读引用，避免拷贝。

### 零拷贝参数

Pipeline 操作使用 `std::vector<PipelineOp>` 传递，内部移动语义避免拷贝。

## 协议细节

### etcd v3 API

etcd v3 使用 gRPC-Gateway 提供 HTTP/JSON 接口，所有请求均为 POST 方法：

- `POST /v3/kv/put`：写入键值对
- `POST /v3/kv/range`：读取键值对（支持前缀查询）
- `POST /v3/kv/deleterange`：删除键值对（支持前缀删除）
- `POST /v3/lease/grant`：创建租约
- `POST /v3/lease/keepalive`：续约
- `POST /v3/kv/txn`：事务（用于 pipeline）

### Base64 编码

etcd v3 API 要求 key 和 value 使用 Base64 编码传输。客户端内部自动处理编码/解码。

### 前缀查询

前缀查询通过 `range_end` 参数实现：

```json
{
  "key": "base64(prefix)",
  "range_end": "base64(prefix_end)"
}
```

其中 `prefix_end` 为前缀的下一个字典序字符串（最后一个字节 +1）。

### 租约机制

租约（Lease）用于实现键的自动过期：

1. 通过 `grantLease(ttl_seconds)` 创建租约，获得 lease_id
2. 通过 `put(key, value, lease_id)` 将键绑定到租约
3. 租约到期后，绑定的键自动删除
4. 通过 `keepAliveOnce(lease_id)` 续约，延长 TTL

## 并发模型

### 异步路径

基于 `galay::kernel::IOScheduler` 的协程调度，单个客户端实例串行执行命令，多个客户端实例可并发运行在不同协程中。

### 同步路径

使用阻塞 socket，适合单线程或简单场景，不涉及协程调度。

## 性能考量

### 批量操作

使用 pipeline 包裹多个操作可显著提升吞吐：

```cpp
std::vector<AsyncEtcdClient::PipelineOp> ops;
ops.push_back(AsyncEtcdClient::PipelineOp::Put("/key1", "value1"));
ops.push_back(AsyncEtcdClient::PipelineOp::Put("/key2", "value2"));
ops.push_back(AsyncEtcdClient::PipelineOp::Get("/key3"));
co_await client.pipeline(std::move(ops));
```

### 连接复用

客户端内部复用 TcpSocket 和 HttpSession，避免频繁建立连接。

### JSON 解析优化

使用 `simdjson` 高性能 JSON 解析库，减少解析开销。

### 快路径优化

`put` 操作在响应疑似无错误时跳过 JSON 解析，直接返回成功。

## 线程安全

- `AsyncEtcdClient`：非线程安全，应在单个协程中使用
- `EtcdClient`：非线程安全，应在单个线程中使用

## 传输层设计

### 去 HttpClient 封装

传输层不依赖 `HttpClient` 封装，直接使用 `TcpSocket` + `HttpSessionAwaitable`：

- 连接管理：`TcpSocket::connect()` / `TcpSocket::close()`
- 请求发送：`HttpSessionAwaitable` 完整收发链路（请求发送 + 响应读满 + HTTP 解析完成后再唤醒）

### HttpSessionAwaitable 生命周期

为避免 `HttpSessionAwaitable` move 后内部 owner 指针失效，内部直接构造 `HttpSessionAwaitable`，并由 `PostJsonAwaitable::Context` 固定持有直到请求完成。

## 与 etcd 官方客户端对比

### 优势

- 现代 C++ 接口（C++23）
- 基于协程的异步支持
- 类型安全的错误处理（`std::expected`）
- 轻量级实现，无需 gRPC 依赖
- 更好的内存管理（复用 HttpSession）

### 限制

- 仅支持 HTTP/JSON 协议，不支持 gRPC
- 不支持 Watch 流式接口（计划未来支持）
- 不支持 Lock 分布式锁（计划未来支持）
- 不支持 Cluster 管理接口
