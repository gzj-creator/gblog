# 05-示例代码

## 同步客户端基础示例

### 基本 KV 操作

```cpp
#include "galay-etcd/sync/EtcdClient.h"
#include <iostream>

using namespace galay::etcd;

int main() {
    EtcdConfig config;
    config.endpoint = "http://127.0.0.1:2379";
    config.api_prefix = "/v3";

    EtcdClient session(config);

    // 连接
    auto conn = session.connect();
    if (!conn) {
        std::cerr << "连接失败: " << conn.error().message() << '\n';
        return 1;
    }

    // 写入
    auto put = session.put("/demo/key", "hello");
    if (!put) {
        std::cerr << "写入失败: " << put.error().message() << '\n';
        return 1;
    }

    // 读取
    auto get = session.get("/demo/key");
    if (!get) {
        std::cerr << "读取失败: " << get.error().message() << '\n';
        return 1;
    }

    const auto& kvs = session.lastKeyValues();
    for (const auto& kv : kvs) {
        std::cout << kv.key << " => " << kv.value << '\n';
    }

    // 删除
    auto del = session.del("/demo/key");
    if (!del) {
        std::cerr << "删除失败: " << del.error().message() << '\n';
        return 1;
    }
    std::cout << "删除了 " << session.lastDeletedCount() << " 个键\n";

    session.close();
    return 0;
}
```

### 前缀操作

```cpp
// 写入多个键
session.put("/app/config/db/host", "localhost");
session.put("/app/config/db/port", "3306");
session.put("/app/config/cache/host", "redis");

// 前缀查询
auto get = session.get("/app/config/db/", true);  // prefix=true
if (get) {
    for (const auto& kv : session.lastKeyValues()) {
        std::cout << kv.key << " => " << kv.value << '\n';
    }
}

// 前缀删除
auto del = session.del("/app/config/db/", true);  // prefix=true
if (del) {
    std::cout << "删除了 " << session.lastDeletedCount() << " 个键\n";
}
```

### 租约（Lease）

```cpp
// 创建 5 秒租约
auto lease = session.grantLease(5);
if (!lease) {
    std::cerr << "创建租约失败: " << lease.error().message() << '\n';
    return 1;
}

int64_t lease_id = session.lastLeaseId();
std::cout << "租约 ID: " << lease_id << '\n';

// 绑定键到租约
auto put = session.put("/temp/key", "value", lease_id);
if (!put) {
    std::cerr << "写入失败: " << put.error().message() << '\n';
    return 1;
}

// 续约
auto keepalive = session.keepAliveOnce(lease_id);
if (!keepalive) {
    std::cerr << "续约失败: " << keepalive.error().message() << '\n';
    return 1;
}

// 5 秒后键自动过期
std::this_thread::sleep_for(std::chrono::seconds(6));
auto get = session.get("/temp/key");
if (get && session.lastKeyValues().empty()) {
    std::cout << "键已过期\n";
}
```

### Pipeline（批量操作）

```cpp
using PipelineOp = EtcdClient::PipelineOp;

std::vector<PipelineOp> ops;
ops.push_back(PipelineOp::Put("/batch/key1", "value1"));
ops.push_back(PipelineOp::Put("/batch/key2", "value2"));
ops.push_back(PipelineOp::Get("/batch/key1"));
ops.push_back(PipelineOp::Del("/batch/key2"));

auto result = session.pipeline(std::move(ops));
if (!result) {
    std::cerr << "Pipeline 失败: " << result.error().message() << '\n';
    return 1;
}

const auto& results = session.lastPipelineResults();
for (size_t i = 0; i < results.size(); ++i) {
    const auto& r = results[i];
    std::cout << "操作 " << i << ": ";
    if (r.ok) {
        std::cout << "成功";
        if (r.type == EtcdClient::PipelineOpType::Get) {
            std::cout << ", 返回 " << r.kvs.size() << " 个键";
        } else if (r.type == EtcdClient::PipelineOpType::Delete) {
            std::cout << ", 删除 " << r.deleted_count << " 个键";
        }
    } else {
        std::cout << "失败";
    }
    std::cout << '\n';
}
```

## 异步客户端基础示例

### 基本 KV 操作

```cpp
#include "galay-etcd/async/AsyncEtcdClient.h"
#include <galay-kernel/kernel/Runtime.h>
#include <iostream>

using namespace galay::kernel;
using namespace galay::etcd;

Coroutine asyncDemo(IOScheduler* scheduler) {
    AsyncEtcdClient client(scheduler);

    // 连接
    auto conn = co_await client.connect();
    if (!conn) {
        std::cerr << "连接失败: " << conn.error().message() << '\n';
        co_return;
    }

    // 写入
    auto put = co_await client.put("/demo/key", "hello");
    if (!put) {
        std::cerr << "写入失败: " << put.error().message() << '\n';
        co_await client.close();
        co_return;
    }

    // 读取
    auto get = co_await client.get("/demo/key");
    if (!get) {
        std::cerr << "读取失败: " << get.error().message() << '\n';
        co_await client.close();
        co_return;
    }

    for (const auto& kv : client.lastKeyValues()) {
        std::cout << kv.key << " => " << kv.value << '\n';
    }

    // 删除
    auto del = co_await client.del("/demo/key");
    if (!del) {
        std::cerr << "删除失败: " << del.error().message() << '\n';
        co_await client.close();
        co_return;
    }

    std::cout << "删除了 " << client.lastDeletedCount() << " 个键\n";

    co_await client.close();
}

int main() {
    Runtime runtime;
    runtime.start();

    auto* scheduler = runtime.getNextIOScheduler();
    if (!scheduler) return 1;

    std::atomic<bool> done{false};
    scheduler->spawn([&]() -> Coroutine {
        co_await asyncDemo(scheduler);
        done.store(true, std::memory_order_release);
    }());

    while (!done.load(std::memory_order_acquire)) {
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
    }

    runtime.stop();
    return 0;
}
```

### 异步前缀操作

```cpp
Coroutine asyncPrefixDemo(IOScheduler* scheduler) {
    AsyncEtcdClient client(scheduler);

    co_await client.connect();
    if (!client.lastError().isOk()) co_return;

    // 写入多个键
    co_await client.put("/app/config/db/host", "localhost");
    co_await client.put("/app/config/db/port", "3306");
    co_await client.put("/app/config/cache/host", "redis");

    // 前缀查询（limit=10）
    auto get = co_await client.get("/app/config/db/", true, 10);
    if (get) {
        for (const auto& kv : client.lastKeyValues()) {
            std::cout << kv.key << " => " << kv.value << '\n';
        }
    }

    // 前缀删除
    auto del = co_await client.del("/app/config/db/", true);
    if (del) {
        std::cout << "删除了 " << client.lastDeletedCount() << " 个键\n";
    }

    co_await client.close();
}
```

### 异步租约

```cpp
Coroutine asyncLeaseDemo(IOScheduler* scheduler) {
    AsyncEtcdClient client(scheduler);

    co_await client.connect();
    if (!client.lastError().isOk()) co_return;

    // 创建 10 秒租约
    auto lease = co_await client.grantLease(10);
    if (!lease) {
        std::cerr << "创建租约失败: " << lease.error().message() << '\n';
        co_await client.close();
        co_return;
    }

    int64_t lease_id = client.lastLeaseId();
    std::cout << "租约 ID: " << lease_id << '\n';

    // 绑定键到租约
    auto put = co_await client.put("/temp/session", "active", lease_id);
    if (!put) {
        std::cerr << "写入失败: " << put.error().message() << '\n';
        co_await client.close();
        co_return;
    }

    // 定期续约（每 5 秒）
    for (int i = 0; i < 3; ++i) {
        co_await galay::kernel::sleep(std::chrono::seconds(5));
        auto keepalive = co_await client.keepAliveOnce(lease_id);
        if (!keepalive) {
            std::cerr << "续约失败: " << keepalive.error().message() << '\n';
            break;
        }
        std::cout << "续约成功\n";
    }

    co_await client.close();
}
```

### 异步 Pipeline

```cpp
Coroutine asyncPipelineDemo(IOScheduler* scheduler) {
    AsyncEtcdClient client(scheduler);

    co_await client.connect();
    if (!client.lastError().isOk()) co_return;

    using PipelineOp = AsyncEtcdClient::PipelineOp;

    std::vector<PipelineOp> ops;
    ops.push_back(PipelineOp::Put("/batch/key1", "value1"));
    ops.push_back(PipelineOp::Put("/batch/key2", "value2"));
    ops.push_back(PipelineOp::Put("/batch/key3", "value3"));
    ops.push_back(PipelineOp::Get("/batch/", true));  // 前缀查询
    ops.push_back(PipelineOp::Del("/batch/key2"));

    auto result = co_await client.pipeline(std::move(ops));
    if (!result) {
        std::cerr << "Pipeline 失败: " << result.error().message() << '\n';
        co_await client.close();
        co_return;
    }

    const auto& results = client.lastPipelineResults();
    for (size_t i = 0; i < results.size(); ++i) {
        const auto& r = results[i];
        std::cout << "操作 " << i << ": ";
        if (r.ok) {
            std::cout << "成功";
            if (r.type == AsyncEtcdClient::PipelineOpType::Get) {
                std::cout << ", 返回 " << r.kvs.size() << " 个键";
                for (const auto& kv : r.kvs) {
                    std::cout << "\n  " << kv.key << " => " << kv.value;
                }
            } else if (r.type == AsyncEtcdClient::PipelineOpType::Delete) {
                std::cout << ", 删除 " << r.deleted_count << " 个键";
            }
        } else {
            std::cout << "失败";
        }
        std::cout << '\n';
    }

    co_await client.close();
}
```

## 错误处理

### 同步错误处理

```cpp
void handleError(const EtcdError& error) {
    switch (error.type()) {
        case EtcdErrorType::Success:
            std::cout << "成功\n";
            break;
        case EtcdErrorType::InvalidParam:
            std::cerr << "参数错误: " << error.message() << '\n';
            break;
        case EtcdErrorType::NotConnected:
            std::cerr << "未连接: " << error.message() << '\n';
            break;
        case EtcdErrorType::Connection:
            std::cerr << "连接错误: " << error.message() << '\n';
            break;
        case EtcdErrorType::Timeout:
            std::cerr << "超时: " << error.message() << '\n';
            break;
        case EtcdErrorType::Http:
            std::cerr << "HTTP 错误: " << error.message() << '\n';
            break;
        case EtcdErrorType::Server:
            std::cerr << "服务端错误: " << error.message() << '\n';
            break;
        case EtcdErrorType::Parse:
            std::cerr << "解析错误: " << error.message() << '\n';
            break;
        default:
            std::cerr << "其他错误: " << error.message() << '\n';
            break;
    }
}

int main() {
    EtcdClient session;
    auto conn = session.connect();
    if (!conn) {
        handleError(conn.error());
        return 1;
    }

    auto put = session.put("/key", "value");
    if (!put) {
        handleError(put.error());
        std::cerr << "HTTP 状态码: " << session.lastStatusCode() << '\n';
        std::cerr << "响应体: " << session.lastResponseBody() << '\n';
        return 1;
    }

    return 0;
}
```

### 异步错误处理

```cpp
Coroutine asyncErrorHandling(IOScheduler* scheduler) {
    AsyncEtcdClient client(scheduler);

    auto conn = co_await client.connect();
    if (!conn) {
        const auto& error = conn.error();
        std::cerr << "连接失败: " << error.message() << '\n';
        std::cerr << "错误类型: " << static_cast<int>(error.type()) << '\n';
        co_return;
    }

    auto put = co_await client.put("/key", "value");
    if (!put) {
        const auto& error = put.error();
        std::cerr << "写入失败: " << error.message() << '\n';
        std::cerr << "HTTP 状态码: " << client.lastStatusCode() << '\n';
        std::cerr << "响应体: " << client.lastResponseBody() << '\n';
        co_await client.close();
        co_return;
    }

    co_await client.close();
}
```

## 超时配置

### 异步超时

```cpp
#include "galay-etcd/async/AsyncEtcdConfig.h"

// 仅接收超时
AsyncEtcdConfig config = AsyncEtcdConfig::withRecvTimeout(
    std::chrono::seconds(5)
);

// 发送和接收超时
AsyncEtcdConfig config = AsyncEtcdConfig::withTimeout(
    std::chrono::seconds(3),  // 发送超时
    std::chrono::seconds(10)  // 接收超时
);

// 无超时（不推荐生产环境）
AsyncEtcdConfig config = AsyncEtcdConfig::noTimeout();

// 自定义缓冲区大小
config.buffer_size = 32768;  // 32KB

AsyncEtcdClient client(scheduler, etcd_config, config);
```

## 高级示例

### 服务注册与发现

```cpp
Coroutine serviceRegister(IOScheduler* scheduler,
                          const std::string& service_name,
                          const std::string& service_addr) {
    AsyncEtcdClient client(scheduler);

    co_await client.connect();
    if (!client.lastError().isOk()) co_return;

    // 创建 30 秒租约
    auto lease = co_await client.grantLease(30);
    if (!lease) {
        std::cerr << "创建租约失败\n";
        co_await client.close();
        co_return;
    }

    int64_t lease_id = client.lastLeaseId();
    std::string key = "/services/" + service_name + "/" + service_addr;

    // 注册服务
    auto put = co_await client.put(key, service_addr, lease_id);
    if (!put) {
        std::cerr << "注册服务失败\n";
        co_await client.close();
        co_return;
    }

    std::cout << "服务注册成功: " << key << '\n';

    // 定期续约（每 10 秒）
    while (true) {
        co_await galay::kernel::sleep(std::chrono::seconds(10));
        auto keepalive = co_await client.keepAliveOnce(lease_id);
        if (!keepalive) {
            std::cerr << "续约失败，重新注册\n";
            // 重新创建租约并注册
            lease = co_await client.grantLease(30);
            if (lease) {
                lease_id = client.lastLeaseId();
                co_await client.put(key, service_addr, lease_id);
            }
        }
    }

    co_await client.close();
}

Coroutine serviceDiscover(IOScheduler* scheduler,
                          const std::string& service_name) {
    AsyncEtcdClient client(scheduler);

    co_await client.connect();
    if (!client.lastError().isOk()) co_return;

    std::string prefix = "/services/" + service_name + "/";
    auto get = co_await client.get(prefix, true);
    if (!get) {
        std::cerr << "查询服务失败\n";
        co_await client.close();
        co_return;
    }

    std::cout << "发现服务:\n";
    for (const auto& kv : client.lastKeyValues()) {
        std::cout << "  " << kv.key << " => " << kv.value << '\n';
    }

    co_await client.close();
}
```

### 分布式配置中心

```cpp
Coroutine configCenter(IOScheduler* scheduler) {
    AsyncEtcdClient client(scheduler);

    co_await client.connect();
    if (!client.lastError().isOk()) co_return;

    // 批量写入配置
    using PipelineOp = AsyncEtcdClient::PipelineOp;
    std::vector<PipelineOp> ops;
    ops.push_back(PipelineOp::Put("/config/app/name", "my-app"));
    ops.push_back(PipelineOp::Put("/config/app/version", "1.0.0"));
    ops.push_back(PipelineOp::Put("/config/db/host", "localhost"));
    ops.push_back(PipelineOp::Put("/config/db/port", "3306"));
    ops.push_back(PipelineOp::Put("/config/cache/host", "redis"));
    ops.push_back(PipelineOp::Put("/config/cache/port", "6379"));

    auto result = co_await client.pipeline(std::move(ops));
    if (!result) {
        std::cerr << "写入配置失败\n";
        co_await client.close();
        co_return;
    }

    std::cout << "配置写入成功\n";

    // 读取所有配置
    auto get = co_await client.get("/config/", true);
    if (get) {
        std::cout << "当前配置:\n";
        for (const auto& kv : client.lastKeyValues()) {
            std::cout << "  " << kv.key << " => " << kv.value << '\n';
        }
    }

    co_await client.close();
}
```

### 分布式锁（简化版）

```cpp
Coroutine distributedLock(IOScheduler* scheduler,
                          const std::string& lock_name,
                          int ttl_seconds) {
    AsyncEtcdClient client(scheduler);

    co_await client.connect();
    if (!client.lastError().isOk()) co_return;

    // 创建租约
    auto lease = co_await client.grantLease(ttl_seconds);
    if (!lease) {
        std::cerr << "创建租约失败\n";
        co_await client.close();
        co_return;
    }

    int64_t lease_id = client.lastLeaseId();
    std::string lock_key = "/locks/" + lock_name;

    // 尝试获取锁（简化版，未实现 CAS）
    auto put = co_await client.put(lock_key, "locked", lease_id);
    if (!put) {
        std::cerr << "获取锁失败\n";
        co_await client.close();
        co_return;
    }

    std::cout << "获取锁成功: " << lock_key << '\n';

    // 执行业务逻辑
    co_await galay::kernel::sleep(std::chrono::seconds(5));
    std::cout << "业务逻辑执行完成\n";

    // 释放锁
    auto del = co_await client.del(lock_key);
    if (del) {
        std::cout << "释放锁成功\n";
    }

    co_await client.close();
}
```

## 测试程序运行

```bash
# 功能测试
./build/test/T1-EtcdSmoke http://127.0.0.1:2379
./build/test/T2-EtcdPrefixOps http://127.0.0.1:2379
./build/test/T3-EtcdPipeline http://127.0.0.1:2379

# 压测
./build/benchmark/B1-EtcdKvBenchmark http://127.0.0.1:2379 8 500 64 put
./build/benchmark/B1-EtcdKvBenchmark http://127.0.0.1:2379 8 300 128 mixed
```
