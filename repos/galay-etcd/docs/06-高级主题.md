# 06-高级主题

## 性能优化

### 1. 批量操作使用 Pipeline

Pipeline 将多个操作打包为一个 HTTP 请求，减少网络往返：

```cpp
// 低效：多次网络往返
co_await client.put("/key1", "value1");
co_await client.put("/key2", "value2");
co_await client.put("/key3", "value3");

// 高效：一次网络往返
std::vector<AsyncEtcdClient::PipelineOp> ops;
ops.push_back(AsyncEtcdClient::PipelineOp::Put("/key1", "value1"));
ops.push_back(AsyncEtcdClient::PipelineOp::Put("/key2", "value2"));
ops.push_back(AsyncEtcdClient::PipelineOp::Put("/key3", "value3"));
co_await client.pipeline(std::move(ops));
```

### 2. 连接复用

客户端内部复用 TcpSocket 和 HttpSession，避免频繁建立连接：

```cpp
AsyncEtcdClient client(scheduler);
co_await client.connect();

// 多次操作复用同一连接
for (int i = 0; i < 100; ++i) {
    co_await client.put("/key" + std::to_string(i), "value");
}

co_await client.close();
```

### 3. 前缀查询限制结果数量

使用 `limit` 参数避免返回过多数据：

```cpp
// 仅返回前 10 个结果
auto get = co_await client.get("/prefix/", true, 10);
```

### 4. 合理设置超时

根据网络环境和业务需求设置超时：

```cpp
// 本地环境：短超时
AsyncEtcdConfig config = AsyncEtcdConfig::withTimeout(
    std::chrono::seconds(1),
    std::chrono::seconds(3)
);

// 远程环境：长超时
AsyncEtcdConfig config = AsyncEtcdConfig::withTimeout(
    std::chrono::seconds(3),
    std::chrono::seconds(10)
);
```

### 5. 调整缓冲区大小

根据响应体大小调整缓冲区：

```cpp
AsyncEtcdConfig config;
config.buffer_size = 65536;  // 64KB，适合大结果集
```

## 超时策略

### 连接超时

通过 `AsyncEtcdConfig` 设置：

```cpp
AsyncEtcdConfig config = AsyncEtcdConfig::withTimeout(
    std::chrono::seconds(5),   // 发送超时
    std::chrono::seconds(10)   // 接收超时
);

AsyncEtcdClient client(scheduler, etcd_config, config);
```

### 超时处理

```cpp
auto put = co_await client.put("/key", "value");
if (!put) {
    if (put.error().type() == EtcdErrorType::Timeout) {
        std::cerr << "操作超时，考虑重试或增加超时时间\n";
    }
}
```

### 超时重试

```cpp
Coroutine putWithRetry(AsyncEtcdClient& client,
                       const std::string& key,
                       const std::string& value,
                       int max_retries = 3) {
    for (int i = 0; i < max_retries; ++i) {
        auto put = co_await client.put(key, value);
        if (put) {
            co_return;
        }

        if (put.error().type() == EtcdErrorType::Timeout) {
            std::cerr << "超时，重试 " << (i + 1) << "/" << max_retries << '\n';
            co_await galay::kernel::sleep(std::chrono::seconds(1));
        } else {
            std::cerr << "非超时错误，停止重试: " << put.error().message() << '\n';
            co_return;
        }
    }

    std::cerr << "达到最大重试次数\n";
}
```

## 租约管理

### 租约续约策略

定期续约保持键的存活：

```cpp
Coroutine leaseKeepalive(AsyncEtcdClient& client,
                         int64_t lease_id,
                         int ttl_seconds) {
    // 每 ttl/3 时间续约一次
    int interval = ttl_seconds / 3;
    if (interval < 1) interval = 1;

    while (true) {
        co_await galay::kernel::sleep(std::chrono::seconds(interval));

        auto keepalive = co_await client.keepAliveOnce(lease_id);
        if (!keepalive) {
            std::cerr << "续约失败: " << keepalive.error().message() << '\n';
            break;
        }

        std::cout << "续约成功\n";
    }
}
```

### 租约自动重建

续约失败时自动重建租约：

```cpp
Coroutine leaseWithAutoRenew(AsyncEtcdClient& client,
                             const std::string& key,
                             const std::string& value,
                             int ttl_seconds) {
    int64_t lease_id = 0;

    while (true) {
        // 创建租约
        if (lease_id == 0) {
            auto lease = co_await client.grantLease(ttl_seconds);
            if (!lease) {
                std::cerr << "创建租约失败\n";
                co_await galay::kernel::sleep(std::chrono::seconds(1));
                continue;
            }
            lease_id = client.lastLeaseId();

            // 绑定键到租约
            auto put = co_await client.put(key, value, lease_id);
            if (!put) {
                std::cerr << "写入失败\n";
                lease_id = 0;
                continue;
            }
        }

        // 续约
        co_await galay::kernel::sleep(std::chrono::seconds(ttl_seconds / 3));
        auto keepalive = co_await client.keepAliveOnce(lease_id);
        if (!keepalive) {
            std::cerr << "续约失败，重建租约\n";
            lease_id = 0;
        }
    }
}
```

## 服务注册与发现

### 服务注册

```cpp
class ServiceRegistry {
public:
    ServiceRegistry(IOScheduler* scheduler,
                    const std::string& etcd_endpoint,
                    const std::string& service_name,
                    const std::string& service_addr,
                    int ttl_seconds = 30)
        : m_scheduler(scheduler)
        , m_service_name(service_name)
        , m_service_addr(service_addr)
        , m_ttl_seconds(ttl_seconds)
    {
        EtcdConfig config;
        config.endpoint = etcd_endpoint;
        m_client = std::make_unique<AsyncEtcdClient>(scheduler, config);
    }

    Coroutine start() {
        co_await m_client->connect();
        if (!m_client->lastError().isOk()) {
            std::cerr << "连接 etcd 失败\n";
            co_return;
        }

        while (true) {
            // 创建租约
            auto lease = co_await m_client->grantLease(m_ttl_seconds);
            if (!lease) {
                std::cerr << "创建租约失败\n";
                co_await galay::kernel::sleep(std::chrono::seconds(1));
                continue;
            }

            int64_t lease_id = m_client->lastLeaseId();
            std::string key = "/services/" + m_service_name + "/" + m_service_addr;

            // 注册服务
            auto put = co_await m_client->put(key, m_service_addr, lease_id);
            if (!put) {
                std::cerr << "注册服务失败\n";
                co_await galay::kernel::sleep(std::chrono::seconds(1));
                continue;
            }

            std::cout << "服务注册成功: " << key << '\n';

            // 定期续约
            int interval = m_ttl_seconds / 3;
            for (int i = 0; i < 100; ++i) {  // 最多续约 100 次
                co_await galay::kernel::sleep(std::chrono::seconds(interval));
                auto keepalive = co_await m_client->keepAliveOnce(lease_id);
                if (!keepalive) {
                    std::cerr << "续约失败，重新注册\n";
                    break;
                }
            }
        }
    }

    Coroutine stop() {
        std::string key = "/services/" + m_service_name + "/" + m_service_addr;
        co_await m_client->del(key);
        co_await m_client->close();
    }

private:
    IOScheduler* m_scheduler;
    std::unique_ptr<AsyncEtcdClient> m_client;
    std::string m_service_name;
    std::string m_service_addr;
    int m_ttl_seconds;
};
```

### 服务发现

```cpp
class ServiceDiscovery {
public:
    ServiceDiscovery(IOScheduler* scheduler,
                     const std::string& etcd_endpoint,
                     const std::string& service_name)
        : m_scheduler(scheduler)
        , m_service_name(service_name)
    {
        EtcdConfig config;
        config.endpoint = etcd_endpoint;
        m_client = std::make_unique<AsyncEtcdClient>(scheduler, config);
    }

    Coroutine discover() {
        co_await m_client->connect();
        if (!m_client->lastError().isOk()) {
            co_return std::vector<std::string>{};
        }

        std::string prefix = "/services/" + m_service_name + "/";
        auto get = co_await m_client->get(prefix, true);
        if (!get) {
            co_return std::vector<std::string>{};
        }

        std::vector<std::string> services;
        for (const auto& kv : m_client->lastKeyValues()) {
            services.push_back(kv.value);
        }

        co_await m_client->close();
        co_return services;
    }

private:
    IOScheduler* m_scheduler;
    std::unique_ptr<AsyncEtcdClient> m_client;
    std::string m_service_name;
};
```

## 分布式配置中心

### 配置读取

```cpp
class ConfigCenter {
public:
    ConfigCenter(IOScheduler* scheduler, const std::string& etcd_endpoint)
        : m_scheduler(scheduler)
    {
        EtcdConfig config;
        config.endpoint = etcd_endpoint;
        m_client = std::make_unique<AsyncEtcdClient>(scheduler, config);
    }

    Coroutine loadConfig(const std::string& prefix) {
        co_await m_client->connect();
        if (!m_client->lastError().isOk()) {
            co_return std::map<std::string, std::string>{};
        }

        auto get = co_await m_client->get(prefix, true);
        if (!get) {
            co_return std::map<std::string, std::string>{};
        }

        std::map<std::string, std::string> config;
        for (const auto& kv : m_client->lastKeyValues()) {
            config[kv.key] = kv.value;
        }

        co_await m_client->close();
        co_return config;
    }

    Coroutine saveConfig(const std::map<std::string, std::string>& config) {
        co_await m_client->connect();
        if (!m_client->lastError().isOk()) {
            co_return;
        }

        std::vector<AsyncEtcdClient::PipelineOp> ops;
        for (const auto& [key, value] : config) {
            ops.push_back(AsyncEtcdClient::PipelineOp::Put(key, value));
        }

        auto result = co_await m_client->pipeline(std::move(ops));
        if (!result) {
            std::cerr << "保存配置失败\n";
        }

        co_await m_client->close();
    }

private:
    IOScheduler* m_scheduler;
    std::unique_ptr<AsyncEtcdClient> m_client;
};
```

## 分布式锁（简化版）

注意：这是简化版实现，生产环境建议使用 etcd 官方的 Lock API。

```cpp
class DistributedLock {
public:
    DistributedLock(IOScheduler* scheduler,
                    const std::string& etcd_endpoint,
                    const std::string& lock_name,
                    int ttl_seconds = 10)
        : m_scheduler(scheduler)
        , m_lock_name(lock_name)
        , m_ttl_seconds(ttl_seconds)
        , m_lease_id(0)
    {
        EtcdConfig config;
        config.endpoint = etcd_endpoint;
        m_client = std::make_unique<AsyncEtcdClient>(scheduler, config);
    }

    Coroutine tryLock() {
        co_await m_client->connect();
        if (!m_client->lastError().isOk()) {
            co_return false;
        }

        // 创建租约
        auto lease = co_await m_client->grantLease(m_ttl_seconds);
        if (!lease) {
            co_return false;
        }

        m_lease_id = m_client->lastLeaseId();
        std::string lock_key = "/locks/" + m_lock_name;

        // 尝试获取锁（简化版，未实现 CAS）
        auto put = co_await m_client->put(lock_key, "locked", m_lease_id);
        if (!put) {
            co_return false;
        }

        // 启动续约协程
        m_scheduler->spawn(keepaliveLoop());

        co_return true;
    }

    Coroutine unlock() {
        if (m_lease_id == 0) {
            co_return;
        }

        std::string lock_key = "/locks/" + m_lock_name;
        co_await m_client->del(lock_key);
        m_lease_id = 0;
        co_await m_client->close();
    }

private:
    Coroutine keepaliveLoop() {
        int interval = m_ttl_seconds / 3;
        while (m_lease_id != 0) {
            co_await galay::kernel::sleep(std::chrono::seconds(interval));
            if (m_lease_id == 0) break;

            auto keepalive = co_await m_client->keepAliveOnce(m_lease_id);
            if (!keepalive) {
                std::cerr << "锁续约失败\n";
                m_lease_id = 0;
                break;
            }
        }
    }

    IOScheduler* m_scheduler;
    std::unique_ptr<AsyncEtcdClient> m_client;
    std::string m_lock_name;
    int m_ttl_seconds;
    int64_t m_lease_id;
};

// 使用示例
Coroutine useLock(IOScheduler* scheduler) {
    DistributedLock lock(scheduler, "http://127.0.0.1:2379", "my-lock");

    auto acquired = co_await lock.tryLock();
    if (!acquired) {
        std::cerr << "获取锁失败\n";
        co_return;
    }

    std::cout << "获取锁成功，执行业务逻辑\n";
    co_await galay::kernel::sleep(std::chrono::seconds(5));
    std::cout << "业务逻辑执行完成\n";

    co_await lock.unlock();
    std::cout << "释放锁成功\n";
}
```

## 错误恢复策略

### 连接重试

```cpp
Coroutine connectWithRetry(AsyncEtcdClient& client, int max_retries = 3) {
    for (int i = 0; i < max_retries; ++i) {
        auto conn = co_await client.connect();
        if (conn) {
            std::cout << "连接成功\n";
            co_return;
        }

        std::cerr << "连接失败，" << (i + 1) << " 秒后重试...\n";
        co_await galay::kernel::sleep(std::chrono::seconds(i + 1));
    }

    std::cerr << "连接失败，已达最大重试次数\n";
}
```

### 操作重试

```cpp
template<typename Func>
Coroutine retryOperation(Func&& operation, int max_retries = 3) {
    for (int i = 0; i < max_retries; ++i) {
        auto result = co_await operation();
        if (result) {
            co_return true;
        }

        std::cerr << "操作失败，重试 " << (i + 1) << "/" << max_retries << '\n';
        co_await galay::kernel::sleep(std::chrono::seconds(1));
    }

    co_return false;
}

// 使用示例
Coroutine example(AsyncEtcdClient& client) {
    auto success = co_await retryOperation([&]() -> Coroutine {
        auto put = co_await client.put("/key", "value");
        co_return put.has_value();
    });

    if (success) {
        std::cout << "操作成功\n";
    } else {
        std::cerr << "操作失败\n";
    }
}
```

## 调试技巧

### 启用日志

```cpp
#include <spdlog/spdlog.h>

int main() {
    // 设置日志级别
    spdlog::set_level(spdlog::level::debug);

    // 客户端操作会输出调试日志
    AsyncEtcdClient client(scheduler);
    // ...
}
```

### 打印请求响应

```cpp
auto put = co_await client.put("/key", "value");
if (!put) {
    std::cerr << "操作失败\n";
    std::cerr << "HTTP 状态码: " << client.lastStatusCode() << '\n';
    std::cerr << "响应体: " << client.lastResponseBody() << '\n';
    std::cerr << "错误信息: " << put.error().message() << '\n';
}
```

### 性能分析

```cpp
auto start = std::chrono::steady_clock::now();

co_await client.put("/key", "value");

auto end = std::chrono::steady_clock::now();
auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
std::cout << "操作耗时: " << duration.count() << " us\n";
```

## 常见陷阱

### 1. 忘记检查连接状态

```cpp
// 错误：未检查连接是否成功
co_await client.connect();
co_await client.put("/key", "value");  // 可能失败

// 正确：检查连接状态
auto conn = co_await client.connect();
if (!conn) {
    std::cerr << "连接失败\n";
    co_return;
}
co_await client.put("/key", "value");
```

### 2. 并发使用同一个客户端

```cpp
// 错误：并发使用同一个客户端实例
AsyncEtcdClient client(scheduler);
scheduler->spawn(operation1(client));  // 协程 1
scheduler->spawn(operation2(client));  // 协程 2 - 冲突！

// 正确：每个协程使用独立客户端
scheduler->spawn([scheduler]() -> Coroutine {
    AsyncEtcdClient client1(scheduler);
    co_await operation1(client1);
}());

scheduler->spawn([scheduler]() -> Coroutine {
    AsyncEtcdClient client2(scheduler);
    co_await operation2(client2);
}());
```

### 3. 租约过期未续约

```cpp
// 错误：创建租约后未续约
auto lease = co_await client.grantLease(5);
co_await client.put("/key", "value", client.lastLeaseId());
co_await galay::kernel::sleep(std::chrono::seconds(10));  // 租约已过期

// 正确：定期续约
auto lease = co_await client.grantLease(10);
int64_t lease_id = client.lastLeaseId();
co_await client.put("/key", "value", lease_id);

// 启动续约协程
scheduler->spawn([&client, lease_id]() -> Coroutine {
    while (true) {
        co_await galay::kernel::sleep(std::chrono::seconds(3));
        co_await client.keepAliveOnce(lease_id);
    }
}());
```

### 4. 前缀查询未设置 limit

```cpp
// 错误：前缀查询可能返回大量数据
co_await client.get("/prefix/", true);  // 可能返回数万条记录

// 正确：设置 limit
co_await client.get("/prefix/", true, 100);  // 最多返回 100 条
```

### 5. 忘记关闭连接

```cpp
// 错误：忘记关闭连接
co_await client.connect();
co_await client.put("/key", "value");
// 连接泄漏

// 正确：显式关闭连接
co_await client.connect();
co_await client.put("/key", "value");
co_await client.close();
```

## 与其他库集成

### 与 JSON 库集成

```cpp
#include <nlohmann/json.hpp>

Coroutine saveJsonConfig(AsyncEtcdClient& client,
                         const std::string& key,
                         const nlohmann::json& config) {
    std::string value = config.dump();
    co_await client.put(key, value);
}

Coroutine loadJsonConfig(AsyncEtcdClient& client,
                         const std::string& key) {
    auto get = co_await client.get(key);
    if (!get || client.lastKeyValues().empty()) {
        co_return nlohmann::json{};
    }

    const auto& value = client.lastKeyValues().front().value;
    co_return nlohmann::json::parse(value);
}
```

### 与 HTTP 服务器集成

```cpp
#include <galay-http/server/HttpServer.h>

Coroutine handleRequest(HttpRequest& req, HttpResponse& resp,
                        AsyncEtcdClient& client) {
    std::string key = req.getParam("key");
    if (key.empty()) {
        resp.setStatus(400);
        resp.setBody("Missing key parameter");
        co_return;
    }

    auto get = co_await client.get(key);
    if (!get) {
        resp.setStatus(500);
        resp.setBody("etcd error: " + get.error().message());
        co_return;
    }

    if (client.lastKeyValues().empty()) {
        resp.setStatus(404);
        resp.setBody("Key not found");
        co_return;
    }

    const auto& value = client.lastKeyValues().front().value;
    resp.setStatus(200);
    resp.setBody(value);
}
```
