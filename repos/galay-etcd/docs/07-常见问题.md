# 07-常见问题

## 编译相关

### Q: 编译时找不到 galay-kernel 头文件

**A:** 确保 CMake 能找到依赖库，使用 `CMAKE_PREFIX_PATH` 指定：

```bash
cmake -S . -B build \
  -DCMAKE_PREFIX_PATH="/path/to/galay-kernel;/path/to/galay-http"
```

或者设置环境变量：

```bash
export CMAKE_PREFIX_PATH="/path/to/galay-kernel:/path/to/galay-http"
cmake -S . -B build
```

### Q: 链接时出现 undefined reference 错误

**A:** 检查链接库是否完整：

```cmake
target_link_libraries(your_target PRIVATE
    galay-etcd
    galay-kernel
    galay-http
    simdjson
    spdlog::spdlog
)
```

### Q: 编译时出现 C++23 特性不支持

**A:** 确保编译器支持 C++23：

```bash
# GCC
g++ --version  # 需要 >= 13

# Clang
clang++ --version  # 需要 >= 16
```

在 CMakeLists.txt 中显式指定：

```cmake
set(CMAKE_CXX_STANDARD 23)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
```

### Q: 找不到 simdjson

**A:** 安装 simdjson 并确保 pkg-config 能找到：

```bash
# macOS
brew install simdjson

# Ubuntu/Debian
sudo apt-get install libsimdjson-dev

# 验证
pkg-config --cflags --libs simdjson
```

## 连接相关

### Q: 连接失败：Connection refused

**A:** 检查以下几点：

1. etcd 服务是否运行：
   ```bash
   # 检查进程
   ps aux | grep etcd

   # 检查端口
   netstat -tlnp | grep 2379
   ```

2. 端口是否正确（默认 2379）：
   ```bash
   curl http://127.0.0.1:2379/version
   ```

3. 防火墙是否允许连接：
   ```bash
   sudo ufw allow 2379
   ```

### Q: 连接失败：Invalid endpoint

**A:** 检查 endpoint 格式是否正确：

```cpp
// 正确
config.endpoint = "http://127.0.0.1:2379";
config.endpoint = "http://etcd.example.com:2379";

// 错误
config.endpoint = "127.0.0.1:2379";  // 缺少协议
config.endpoint = "http://127.0.0.1";  // 缺少端口
```

### Q: 连接超时

**A:** 调整超时参数：

```cpp
AsyncEtcdConfig config = AsyncEtcdConfig::withTimeout(
    std::chrono::seconds(5),   // 发送超时
    std::chrono::seconds(10)   // 接收超时
);
```

或检查网络连接：

```bash
# 测试连通性
curl -v http://127.0.0.1:2379/version

# 测试延迟
ping 127.0.0.1
```

### Q: 连接一段时间后断开

**A:** etcd 默认有空闲超时。解决方案：

1. 定期发送请求保持连接活跃
2. 检测连接断开后重连：
   ```cpp
   auto put = co_await client.put("/key", "value");
   if (!put && put.error().type() == EtcdErrorType::Connection) {
       std::cerr << "连接断开，重新连接\n";
       co_await client.close();
       co_await client.connect();
   }
   ```

## 操作相关

### Q: put 操作返回成功但 get 不到数据

**A:** 检查以下几点：

1. key 是否正确（注意前导斜杠）：
   ```cpp
   co_await client.put("/key", "value");  // 正确
   co_await client.get("/key");           // 正确

   co_await client.put("key", "value");   // 不推荐
   co_await client.get("/key");           // 找不到
   ```

2. 是否使用了租约且租约已过期：
   ```cpp
   auto lease = co_await client.grantLease(5);
   co_await client.put("/key", "value", client.lastLeaseId());
   std::this_thread::sleep_for(std::chrono::seconds(6));
   co_await client.get("/key");  // 键已过期
   ```

### Q: 前缀查询返回空结果

**A:** 检查前缀是否正确：

```cpp
// 写入
co_await client.put("/app/config/db/host", "localhost");
co_await client.put("/app/config/db/port", "3306");

// 正确：前缀查询
co_await client.get("/app/config/db/", true);  // 返回 2 个键

// 错误：前缀不匹配
co_await client.get("/app/config/", true);     // 返回 2 个键
co_await client.get("/app/config/db", true);   // 可能返回 0 个键（缺少尾部斜杠）
```

### Q: 删除操作返回 deleted_count = 0

**A:** 可能原因：

1. 键不存在
2. 前缀不匹配
3. 键已被其他客户端删除

验证键是否存在：

```cpp
auto get = co_await client.get("/key");
if (client.lastKeyValues().empty()) {
    std::cout << "键不存在\n";
}
```

### Q: Pipeline 操作部分失败

**A:** 检查 `lastPipelineResults()` 中每个操作的状态：

```cpp
auto result = co_await client.pipeline(ops);
if (result) {
    const auto& results = client.lastPipelineResults();
    for (size_t i = 0; i < results.size(); ++i) {
        if (!results[i].ok) {
            std::cerr << "操作 " << i << " 失败\n";
        }
    }
}
```

## 租约相关

### Q: 租约创建失败

**A:** 检查 TTL 是否合法：

```cpp
// 正确
co_await client.grantLease(5);   // 5 秒
co_await client.grantLease(60);  // 60 秒

// 错误
co_await client.grantLease(0);   // TTL 必须 > 0
co_await client.grantLease(-1);  // TTL 必须 > 0
```

### Q: 续约失败

**A:** 可能原因：

1. 租约已过期
2. lease_id 不存在
3. 网络错误

检查租约是否存在：

```cpp
auto keepalive = co_await client.keepAliveOnce(lease_id);
if (!keepalive) {
    std::cerr << "续约失败: " << keepalive.error().message() << '\n';
    std::cerr << "HTTP 状态码: " << client.lastStatusCode() << '\n';
    std::cerr << "响应体: " << client.lastResponseBody() << '\n';
}
```

### Q: 租约绑定的键未自动删除

**A:** 检查以下几点：

1. 租约是否正确绑定：
   ```cpp
   auto lease = co_await client.grantLease(5);
   int64_t lease_id = client.lastLeaseId();
   co_await client.put("/key", "value", lease_id);  // 必须传递 lease_id
   ```

2. 是否在续约：
   ```cpp
   // 如果持续续约，键不会过期
   co_await client.keepAliveOnce(lease_id);
   ```

3. 等待时间是否足够：
   ```cpp
   // TTL = 5 秒，需要等待 > 5 秒
   std::this_thread::sleep_for(std::chrono::seconds(6));
   ```

## 性能相关

### Q: 操作速度慢

**A:** 优化建议：

1. 使用 Pipeline 批量操作：
   ```cpp
   // 低效
   for (int i = 0; i < 100; ++i) {
       co_await client.put("/key" + std::to_string(i), "value");
   }

   // 高效
   std::vector<AsyncEtcdClient::PipelineOp> ops;
   for (int i = 0; i < 100; ++i) {
       ops.push_back(AsyncEtcdClient::PipelineOp::Put(
           "/key" + std::to_string(i), "value"));
   }
   co_await client.pipeline(std::move(ops));
   ```

2. 复用连接：
   ```cpp
   // 低效：每次操作都建立连接
   for (int i = 0; i < 100; ++i) {
       AsyncEtcdClient client(scheduler);
       co_await client.connect();
       co_await client.put("/key", "value");
       co_await client.close();
   }

   // 高效：复用连接
   AsyncEtcdClient client(scheduler);
   co_await client.connect();
   for (int i = 0; i < 100; ++i) {
       co_await client.put("/key", "value");
   }
   co_await client.close();
   ```

3. 检查网络延迟：
   ```bash
   ping etcd-server
   ```

### Q: 内存占用高

**A:** 优化建议：

1. 减小缓冲区大小：
   ```cpp
   AsyncEtcdConfig config;
   config.buffer_size = 8192;  // 默认 16384
   ```

2. 前缀查询使用 limit：
   ```cpp
   co_await client.get("/prefix/", true, 100);  // 限制返回 100 条
   ```

3. 及时释放结果：
   ```cpp
   // lastKeyValues() 返回引用，不会拷贝
   const auto& kvs = client.lastKeyValues();
   // 使用完后，下次操作会覆盖
   ```

### Q: 并发性能差

**A:** 优化建议：

1. 使用多个客户端实例：
   ```cpp
   // 每个协程使用独立客户端
   for (int i = 0; i < 10; ++i) {
       scheduler->spawn([scheduler, i]() -> Coroutine {
           AsyncEtcdClient client(scheduler);
           co_await client.connect();
           co_await client.put("/key" + std::to_string(i), "value");
           co_await client.close();
       }());
   }
   ```

2. 增加 IOScheduler 线程数：
   ```cpp
   Runtime runtime(8);  // 8 个 IO 线程
   ```

## 错误处理相关

### Q: 如何区分不同类型的错误？

**A:** 通过 `EtcdErrorType` 判断：

```cpp
auto put = co_await client.put("/key", "value");
if (!put) {
    switch (put.error().type()) {
        case EtcdErrorType::InvalidParam:
            std::cerr << "参数错误\n";
            break;
        case EtcdErrorType::NotConnected:
            std::cerr << "未连接\n";
            break;
        case EtcdErrorType::Connection:
            std::cerr << "连接错误\n";
            break;
        case EtcdErrorType::Timeout:
            std::cerr << "超时\n";
            break;
        case EtcdErrorType::Http:
            std::cerr << "HTTP 错误\n";
            break;
        case EtcdErrorType::Server:
            std::cerr << "服务端错误\n";
            break;
        case EtcdErrorType::Parse:
            std::cerr << "解析错误\n";
            break;
        default:
            std::cerr << "未知错误\n";
    }
}
```

### Q: 如何获取详细的错误信息？

**A:** 使用 `lastStatusCode()` 和 `lastResponseBody()`：

```cpp
auto put = co_await client.put("/key", "value");
if (!put) {
    std::cerr << "错误类型: " << static_cast<int>(put.error().type()) << '\n';
    std::cerr << "错误消息: " << put.error().message() << '\n';
    std::cerr << "HTTP 状态码: " << client.lastStatusCode() << '\n';
    std::cerr << "响应体: " << client.lastResponseBody() << '\n';
}
```

### Q: 超时后如何重试？

**A:** 检测超时错误并重试：

```cpp
for (int i = 0; i < 3; ++i) {
    auto put = co_await client.put("/key", "value");
    if (put) {
        break;
    }

    if (put.error().type() == EtcdErrorType::Timeout) {
        std::cerr << "超时，重试 " << (i + 1) << "/3\n";
        co_await galay::kernel::sleep(std::chrono::seconds(1));
    } else {
        std::cerr << "非超时错误，停止重试\n";
        break;
    }
}
```

## 异步相关

### Q: 可以并发使用同一个 AsyncEtcdClient 吗？

**A:** 不可以。同一个实例应串行使用：

```cpp
// 错误
AsyncEtcdClient client(scheduler);
scheduler->spawn(operation1(client));
scheduler->spawn(operation2(client));  // 冲突！

// 正确：每个协程使用独立客户端
scheduler->spawn([scheduler]() -> Coroutine {
    AsyncEtcdClient client1(scheduler);
    co_await operation1(client1);
}());

scheduler->spawn([scheduler]() -> Coroutine {
    AsyncEtcdClient client2(scheduler);
    co_await operation2(client2);
}());
```

### Q: co_await 后如何获取结果？

**A:** 通过 `lastXxx()` 方法：

```cpp
// KV 操作
auto get = co_await client.get("/key");
if (get) {
    const auto& kvs = client.lastKeyValues();
    for (const auto& kv : kvs) {
        std::cout << kv.key << " => " << kv.value << '\n';
    }
}

// 删除操作
auto del = co_await client.del("/prefix/", true);
if (del) {
    std::cout << "删除了 " << client.lastDeletedCount() << " 个键\n";
}

// 租约操作
auto lease = co_await client.grantLease(10);
if (lease) {
    int64_t lease_id = client.lastLeaseId();
    std::cout << "租约 ID: " << lease_id << '\n';
}
```

## 同步相关

### Q: 同步客户端会阻塞吗？

**A:** 是的，所有方法都是阻塞的。适合：

- 简单脚本
- 测试代码
- 低并发场景

高并发场景建议使用异步客户端。

### Q: 同步客户端可以设置超时吗？

**A:** 当前版本不支持操作超时，仅支持连接超时（通过底层 socket 实现）。

## 兼容性相关

### Q: 支持哪些 etcd 版本？

**A:** 支持 etcd v3 API，理论上兼容 etcd 3.x 所有版本。已测试：

- etcd 3.4.x
- etcd 3.5.x

### Q: 支持 gRPC 协议吗？

**A:** 不支持。仅支持 HTTP/JSON 协议（etcd v3 gRPC-Gateway）。

### Q: 支持 Watch 功能吗？

**A:** 当前版本不支持。Watch 需要流式接口，计划在未来版本中添加。

### Q: 支持 Lock API 吗？

**A:** 当前版本不支持。可以使用租约实现简化版分布式锁，但不如官方 Lock API 完善。

### Q: 支持 Cluster 管理吗？

**A:** 不支持。仅支持 KV、Lease、Transaction（Pipeline）操作。

## 调试相关

### Q: 如何启用调试日志？

**A:** 设置 spdlog 日志级别：

```cpp
#include <spdlog/spdlog.h>

int main() {
    spdlog::set_level(spdlog::level::debug);
    // ...
}
```

### Q: 如何查看发送的请求？

**A:** 启用调试日志后，会输出 HTTP 请求详情。或使用抓包工具：

```bash
# tcpdump
sudo tcpdump -i lo -A 'port 2379'

# Wireshark
# 过滤器：tcp.port == 2379
```

### Q: 如何分析性能瓶颈？

**A:** 使用计时器：

```cpp
auto start = std::chrono::steady_clock::now();

co_await client.put("/key", "value");

auto end = std::chrono::steady_clock::now();
auto us = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
std::cout << "操作耗时: " << us.count() << " us\n";
```

或使用压测工具：

```bash
./build/benchmark/B1-EtcdKvBenchmark http://127.0.0.1:2379 8 500 64 put
```

## 其他

### Q: 如何贡献代码？

**A:** 欢迎提交 PR 到 GitHub 仓库：

1. Fork 仓库
2. 创建特性分支
3. 提交代码并编写测试
4. 发起 Pull Request

### Q: 如何报告 Bug？

**A:** 在 GitHub Issues 中提交，包含：

- 复现步骤
- 预期行为和实际行为
- 环境信息（OS、编译器、etcd 版本）
- 相关日志和错误信息

### Q: 生产环境可以使用吗？

**A:** 项目处于活跃开发中，建议：

- 充分测试后再用于生产
- 关注 GitHub 更新和 Bug 修复
- 做好错误处理和监控
- 准备降级方案

### Q: 与 etcd 官方客户端相比有什么优势？

**A:**

- 现代 C++ 接口（C++23）
- 基于协程的异步支持
- 类型安全的错误处理（`std::expected`）
- 轻量级实现，无需 gRPC 依赖
- 更好的内存管理

### Q: 有商业支持吗？

**A:** 当前为开源项目，暂无商业支持。可通过 GitHub Issues 获取社区支持。
