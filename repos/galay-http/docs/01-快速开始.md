# 01-快速开始

## 依赖

- Galay 内部依赖（构建必需 + 联调推荐）：
  - [galay-kernel](https://github.com/gzj-creator/galay-kernel)（构建必需）
  - [galay-utils](https://github.com/gzj-creator/galay-utils)（推荐）
  - [galay-ssl](https://github.com/gzj-creator/galay-ssl)（启用 TLS 时必需）
- 支持 C++23 的编译器（推荐 GCC 11+、Clang 14+、AppleClang 15+）
- CMake 3.22+
- spdlog
- OpenSSL（启用 TLS 时）

## 拉取与编译

```bash
git clone https://github.com/gzj-creator/galay-kernel.git
git clone https://github.com/gzj-creator/galay-utils.git
git clone https://github.com/gzj-creator/galay-http.git
# 可选：启用 TLS 时一并拉取
git clone https://github.com/gzj-creator/galay-ssl.git

cd galay-http
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release
cmake --build build --parallel
```

仅单独构建 `galay-http` 时，最小内部依赖为 `galay-kernel` 和 `galay-utils`。

## CMake 开关

- `GALAY_HTTP_ENABLE_SSL`：是否启用 SSL/TLS 支持（需要 galay-ssl）
- `BUILD_MODULE_EXAMPLES`：是否构建 C++23 模块示例
- `CMAKE_BUILD_TYPE`：构建类型（Debug/Release）

说明：模块编译自动检测工具链，当前需要 `CMake >= 3.28 + Ninja/Visual Studio`。
模块接口文件统一使用 `.cppm`（位于 `galay-http/module/`）。
AppleClang 环境会自动关闭模块目标，避免构建失败。

## 依赖安装

### macOS / Homebrew

```bash
brew install cmake spdlog
# 仅在开启 TLS 时需要
brew install openssl
```

### Ubuntu / Debian

```bash
sudo apt-get update
sudo apt-get install -y cmake g++ libspdlog-dev
# 仅在开启 TLS 时需要
sudo apt-get install -y libssl-dev
```

## 运行示例

### HTTP Echo

```bash
# 终端 1：启动服务器
./build/examples/E1-EchoServer 8080

# 终端 2：发送请求
./build/examples/E2-EchoClient http://127.0.0.1:8080/echo "hello"
# 或使用 curl
curl -X POST http://127.0.0.1:8080/echo -d "hello world"
```

### WebSocket Echo

```bash
# 终端 1：启动服务器
./build/examples/E3-WebsocketServer

# 终端 2：连接客户端
./build/examples/E4-WebsocketClient ws://127.0.0.1:8080/ws
```

### HTTP/2 (h2c) Echo

```bash
# 终端 1：启动服务器
./build/examples/E9-H2cEchoServer 9080

# 终端 2：连接客户端
./build/examples/E10-H2cEchoClient 127.0.0.1 9080
```

### 静态文件服务

```bash
./build/examples/E11-StaticServer 8090 ./html
# 打开浏览器访问 http://127.0.0.1:8090/
```

### HTTP 反向代理

```bash
# 终端 1：启动上游服务器
./build/examples/E1-EchoServer 8080

# 终端 2：启动代理服务器（监听 8081，转发到 127.0.0.1:8080）
./build/examples/E12-HttpProxy 8081 127.0.0.1 8080 /static ./html dynamic

# 终端 3：通过代理发送请求
curl -X POST http://127.0.0.1:8081/echo -d "via proxy"

# 访问本地静态文件（由 mount 提供，不经过代理）
curl http://127.0.0.1:8081/static/index.html
```

代理参数说明：

```text
E12-HttpProxy [listen_port] [upstream_host] [upstream_port]
             [mount_prefix] [mount_dir] [mount_mode]

mount_mode: dynamic(默认) | hard | nginx(try_files)
关闭 mount: mount_prefix 或 mount_dir 传 none/off
```

## HTTP 服务器最小示例

```cpp
#include "galay-http/kernel/http/HttpServer.h"
#include "galay-http/kernel/http/HttpRouter.h"
#include "galay-http/protoc/http/HttpRequest.h"
#include "galay-http/utils/Http1_1ResponseBuilder.h"

using namespace galay::http;
using namespace galay::kernel;

// Echo 处理器
Coroutine echoHandler(HttpConn& conn, HttpRequest req) {
    std::string body = req.body().getBodyStr();

    auto response = Http1_1ResponseBuilder::ok()
        .header("Server", "Galay-HTTP/1.0")
        .text(body.empty() ? "Echo: (empty)" : "Echo: " + body)
        .build();

    auto writer = conn.getWriter();
    while (true) {
        auto result = co_await writer.sendResponse(response);
        if (!result || result.value()) break;
    }

    co_return;
}

int main() {
    // 创建路由器
    HttpRouter router;
    router.addHandler<HttpMethod::POST>("/echo", echoHandler);

    // 配置服务器
    HttpServerConfig config;
    config.host = "0.0.0.0";
    config.port = 8080;
    config.backlog = 128;

    // 启动服务器
    HttpServer server(config);
    server.start(std::move(router));

    // 保持运行
    while (true) {
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }

    return 0;
}
```

## HTTP 客户端最小示例

```cpp
#include <iostream>
#include "galay-http/kernel/http/HttpClient.h"
#include "galay-http/utils/Http1_1RequestBuilder.h"
#include "galay-kernel/kernel/Runtime.h"

using namespace galay::http;
using namespace galay::kernel;

Coroutine sendRequest() {
    HttpClient client;

    // 连接服务器
    auto connect_result = co_await client.connect("http://127.0.0.1:8080");
    if (!connect_result) {
        std::cerr << "连接失败\n";
        co_return;
    }

    // 获取 Session
    auto session = client.getSession();
    auto writer = session.getWriter();
    auto reader = session.getReader();

    // 构建并发送 POST 请求
    auto request = Http1_1RequestBuilder::post("/echo")
        .host("127.0.0.1:8080")
        .header("Content-Type", "text/plain")
        .body("Hello, World!")
        .build();

    while (true) {
        auto send_result = co_await writer.sendRequest(request);
        if (!send_result || send_result.value()) break;
    }

    // 接收响应
    HttpResponse response;
    auto recv_result = co_await reader.getResponse(response);
    if (recv_result) {
        std::cout << "响应: " << response.getBodyStr() << '\n';
    }

    co_await client.close();
}

int main() {
    Runtime runtime;
    runtime.start();

    auto* scheduler = runtime.getNextIOScheduler();
    scheduler->spawn(sendRequest());

    std::this_thread::sleep_for(std::chrono::seconds(2));
    runtime.stop();

    return 0;
}
```

## WebSocket 服务器最小示例

```cpp
#include "galay-http/kernel/http/HttpServer.h"
#include "galay-http/kernel/websocket/WsUpgrade.h"
#include "galay-http/kernel/websocket/WsConn.h"

using namespace galay::http;
using namespace galay::websocket;
using namespace galay::kernel;

Coroutine handleWebSocket(WsConn& ws_conn) {
    auto reader = ws_conn.getReader(WsReaderSetting{});
    auto writer = ws_conn.getWriter(WsWriterSetting::byServer());

    // 发送欢迎消息
    co_await writer.sendText("Welcome!");

    // 消息循环
    while (true) {
        std::string message;
        WsOpcode opcode;

        auto result = co_await reader.getMessage(message, opcode);
        if (!result.has_value() || !result.value()) break;

        // Echo 回消息
        if (opcode == WsOpcode::Text) {
            co_await writer.sendText("Echo: " + message);
        }
    }
}

Coroutine wsHandler(HttpConn& conn, HttpRequest req) {
    WsUpgrade upgrade;
    auto ws_conn = co_await upgrade.upgrade(conn, req);
    if (ws_conn) {
        co_await handleWebSocket(*ws_conn);
    }
    co_return;
}

int main() {
    HttpRouter router;
    router.addHandler<HttpMethod::GET>("/ws", wsHandler);

    HttpServerConfig config;
    config.host = "0.0.0.0";
    config.port = 8080;

    HttpServer server(config);
    server.start(std::move(router));

    while (true) {
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }

    return 0;
}
```

## WebSocket 客户端最小示例

```cpp
#include <iostream>
#include "galay-http/kernel/websocket/WsClient.h"
#include "galay-kernel/kernel/Runtime.h"

using namespace galay::websocket;
using namespace galay::kernel;

Coroutine wsClient() {
    WsClient client;

    // 连接 WebSocket 服务器
    auto connect_result = co_await client.connect("ws://127.0.0.1:8080/ws");
    if (!connect_result) {
        std::cerr << "连接失败\n";
        co_return;
    }

    // 获取 Session 并升级
    auto session = client.getSession(WsWriterSetting::byClient());
    auto upgrader = session.upgrade();
    auto upgrade_result = co_await upgrader();
    if (!upgrade_result) {
        std::cerr << "升级失败\n";
        co_return;
    }

    // 获取连接
    auto conn = session.getConn();
    if (!conn) {
        std::cerr << "获取连接失败\n";
        co_return;
    }

    auto reader = conn->getReader(WsReaderSetting{});
    auto writer = conn->getWriter(WsWriterSetting::byClient());

    // 发送消息
    co_await writer.sendText("Hello, WebSocket!");

    // 接收响应
    std::string message;
    WsOpcode opcode;
    auto result = co_await reader.getMessage(message, opcode);
    if (result.has_value() && result.value()) {
        std::cout << "收到: " << message << '\n';
    }

    co_await writer.sendClose(1000, "Normal closure");
    co_await conn->close();
}

int main() {
    Runtime runtime;
    runtime.start();

    auto* scheduler = runtime.getNextIOScheduler();
    scheduler->spawn(wsClient());

    std::this_thread::sleep_for(std::chrono::seconds(2));
    runtime.stop();

    return 0;
}
```

## 常见问题

### 编译错误：找不到头文件

确保 CMake 能找到 `galay-kernel` 等依赖。可通过 `CMAKE_PREFIX_PATH` 指定：

```bash
cmake -S . -B build -DCMAKE_PREFIX_PATH="/path/to/galay-kernel;/path/to/galay-utils"
```

### 链接错误：undefined reference

检查是否链接了必要的库：

```cmake
target_link_libraries(your_target PRIVATE
    galay-http
    galay-kernel
    galay-utils
    spdlog::spdlog
)

# 启用 SSL 时还需要
target_link_libraries(your_target PRIVATE
    galay-ssl
    OpenSSL::SSL
    OpenSSL::Crypto
)
```

### 运行时错误：端口被占用

检查端口是否已被使用：

```bash
# Linux
netstat -tlnp | grep 8080

# macOS
lsof -i :8080
```

### 模块编译失败

当前模块编译路径要求：

- CMake >= 3.28
- Ninja 或 Visual Studio 生成器
- GCC >= 14 或 Clang >= 16

不满足条件时会自动降级到 include 路径。

## 下一步

- 查看 [架构设计](02-架构设计.md) 理解内部实现
- 查看 [API 文档](03-API文档.md) 了解完整接口
- 查看 [示例代码](04-示例代码.md) 学习常见用法
- 查看 [高级主题](05-高级主题.md) 掌握进阶技巧
- 查看 [常见问题](06-常见问题.md) 解决疑难问题
