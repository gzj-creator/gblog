# 02-架构设计

## 设计目标

Galay-HTTP 是一个基于 C++23 协程的高性能网络库，提供统一的异步接口，覆盖：

- HTTP/1.1 客户端与服务器
- WebSocket (`ws` / `wss`)
- HTTP/2 (`h2c`)
- TLS 支持（`https` / `wss`）

设计原则：

- 零拷贝：最小化数据拷贝，提升性能
- 类型安全：使用 `std::expected` 进行错误处理
- 协程优先：统一的 `co_await` 异步模型
- 模块化：清晰的分层架构，易于扩展

## 核心分层

```text
┌─────────────────────────────────────────┐
│  应用层 (examples / test / benchmark)    │
└─────────────────────────────────────────┘
                  ↓
┌─────────────────────────────────────────┐
│  galay-http/kernel                      │
│  ├── http    (HTTP/1.1 实现)            │
│  ├── http2   (HTTP/2 实现)              │
│  └── websocket (WebSocket 实现)         │
└─────────────────────────────────────────┘
                  ↓
┌─────────────────────────────────────────┐
│  galay-http/protoc                      │
│  ├── http    (HTTP 协议数据结构)        │
│  ├── http2   (HTTP/2 帧与 HPACK)        │
│  └── websocket (WebSocket 帧)           │
└─────────────────────────────────────────┘
                  ↓
┌─────────────────────────────────────────┐
│  galay-http/utils                       │
│  ├── Builder (请求/响应构造器)          │
│  ├── Logger  (日志工具)                 │
│  └── Utils   (通用工具)                 │
└─────────────────────────────────────────┘
                  ↓
┌─────────────────────────────────────────┐
│  galay-kernel / galay-ssl               │
│  (协程运行时 / TLS 支持)                │
└─────────────────────────────────────────┘
```

## 运行时模型

### 服务端架构

```text
HttpServer
  ├── Runtime (内部托管)
  ├── IOScheduler (多个，负载均衡)
  ├── HttpRouter (路由分发)
  └── HttpConn (每个连接一个协程)
```

- `HttpServer` 内部托管 `Runtime` 与多个 `IOScheduler`
- 每个新连接分配到一个 `IOScheduler`，由其调度协程
- 路由器根据请求路径和方法分发到对应的处理器
- 处理器是协程函数，使用 `co_await` 进行异步 I/O

### 客户端架构

```text
Runtime (用户管理)
  └── IOScheduler (用户获取)
        └── spawn 客户端协程
              ├── HttpClient (HTTP/1.1)
              ├── WsClient (WebSocket)
              └── H2cClient (HTTP/2)
```

- 客户端不需要 `IOScheduler` 参数，直接创建即可
- 客户端内部使用当前协程的调度器
- 客户端方法返回 awaitable，通过 `co_await` 等待完成

### 协程模型

所有 I/O 操作返回 awaitable 对象：

```cpp
// 服务端
Coroutine handler(HttpConn& conn, HttpRequest req) {
    auto writer = conn.getWriter();
    auto result = co_await writer.sendResponse(response);
    co_return;
}

// 客户端
Coroutine client() {
    HttpClient client;
    co_await client.connect("http://host:80");
    auto session = client.getSession();
    auto writer = session.getWriter();
    auto reader = session.getReader();
    // 发送请求和接收响应
    co_return;
}
```

## HTTP 服务器

### 路由系统

`HttpRouter` 支持三种路由模式：

1. 精确匹配：`/api/users`
2. 参数路由：`/api/users/:id`
3. 通配符：`/static/*`

路由注册：

```cpp
HttpRouter router;

// 精确匹配
router.addHandler<HttpMethod::GET>("/", indexHandler);

// 参数路由
router.addHandler<HttpMethod::GET>("/users/:id", getUserHandler);

// 通配符
router.addHandler<HttpMethod::GET>("/static/*", staticHandler);
```

路由优先级：精确匹配 > 参数路由 > 通配符

### 静态文件服务

支持三种挂载模式：

1. `mount`：动态模式，按需加载文件
2. `mountHardly`：硬加载模式，启动时加载所有文件到内存
3. `mountNginxStyle`：Nginx 风格，支持 `try_files` 语义

传输模式：

- `MEMORY`：内存传输（小文件）
- `CHUNK`：分块传输（大文件）
- `SENDFILE`：零拷贝传输（Linux）
- `AUTO`：自动选择（推荐）

示例：

```cpp
// 动态挂载
StaticFileConfig config;
config.mode = StaticFileConfig::TransferMode::AUTO;
router.mount("/static", "./html", config);

// 硬加载挂载
StaticFileConfig memory_config;
memory_config.mode = StaticFileConfig::TransferMode::MEMORY;
router.mountHardly("/assets", "./assets", memory_config);

// Nginx 风格 try_files（静态命中优先，未命中回源代理）
router.tryFiles("/files", "./files", "upstream.example.com", 8080, config);
```

### 连接管理

- 支持 HTTP/1.1 Keep-Alive
- 自动处理连接复用
- 超时自动关闭
- 优雅关闭支持

## HTTP 客户端

### 会话管理

```cpp
HttpClient client;

// 建立连接
co_await client.connect("http://example.com:80");

// 获取 Session
auto session = client.getSession();
auto writer = session.getWriter();
auto reader = session.getReader();

// 发送多个请求（复用连接）
auto req1 = Http1_1RequestBuilder::get("/api/v1").host("example.com").build();
co_await writer.sendRequest(req1);
HttpResponse resp1;
co_await reader.getResponse(resp1);

auto req2 = Http1_1RequestBuilder::post("/api/v2").host("example.com").body(body).build();
co_await writer.sendRequest(req2);
HttpResponse resp2;
co_await reader.getResponse(resp2);

// 关闭连接
co_await client.close();
```

### 请求构建

使用 `Http1_1RequestBuilder` 构建请求：

```cpp
auto request = Http1_1RequestBuilder::get("/path")
    .host("example.com")
    .header("User-Agent", "Galay-HTTP/1.0")
    .build();

auto writer = session.getWriter();
co_await writer.sendRequest(request);
```

支持所有标准 HTTP 方法：GET、POST、PUT、DELETE、HEAD、OPTIONS、PATCH

## WebSocket

### 帧处理

WebSocket 支持以下帧类型：

- 数据帧：`Text`、`Binary`
- 控制帧：`Ping`、`Pong`、`Close`

### 消息分片

自动处理消息分片：

- 发送：自动分片大消息
- 接收：自动重组分片消息

### 扩展支持

- 掩码处理（客户端自动添加，服务端自动验证）
- Ping/Pong 心跳
- 优雅关闭握手

## HTTP/2

### 多路复用

- 单连接多流并发
- 流优先级支持
- 流量控制

### HPACK 压缩

- 动态表压缩
- 静态表查找
- Huffman 编码

### 帧类型

支持所有 HTTP/2 帧类型：

- `DATA`：数据传输
- `HEADERS`：头部传输
- `PRIORITY`：优先级设置
- `RST_STREAM`：流重置
- `SETTINGS`：设置交换
- `PUSH_PROMISE`：服务器推送
- `PING`：心跳
- `GOAWAY`：连接关闭
- `WINDOW_UPDATE`：流量控制
- `CONTINUATION`：头部延续

## TLS 支持

启用 `GALAY_HTTP_ENABLE_SSL` 后可用：

- `HttpsServer` / `HttpsClient`：HTTPS
- `WssClient`：WebSocket over TLS

TLS 配置：

```cpp
// 服务端
HttpsServerConfig config;
config.cert_path = "/path/to/cert.pem";
config.key_path = "/path/to/key.pem";

HttpsServer server(config);
server.start(std::move(router));

// 客户端
HttpsClient client;
co_await client.connect("https://example.com:443");
co_await client.handshake();
auto session = client.getSession();
```

## 模块化接口

提供 3 个 C++23 命名模块接口：

- `galay.http`：HTTP/1.1 相关
- `galay.http2`：HTTP/2 相关
- `galay.websocket`：WebSocket 相关

模块文件位于 `galay-http/module/`：

- `galay.http.cppm`
- `galay.http2.cppm`
- `galay.websocket.cppm`
- `ModulePrelude.hpp`

使用示例：

```cpp
import galay.http;
import galay.websocket;

// 或使用传统 include
#include "galay-http/kernel/http/HttpServer.h"
#include "galay-http/kernel/websocket/WsClient.h"
```

## 错误处理

统一使用 `std::expected` 进行错误处理：

```cpp
// HTTP 错误
std::expected<HttpResponse, HttpError> response = co_await session->get("/");
if (!response) {
    std::cerr << "错误: " << response.error().message() << '\n';
}

// WebSocket 错误
std::expected<std::optional<bool>, WsError> result = co_await reader.getMessage(msg, opcode);
if (!result.has_value()) {
    std::cerr << "错误: " << result.error().message() << '\n';
}
```

错误类型：

- `HttpError`：HTTP 协议错误
- `WsError`：WebSocket 协议错误
- `Http2Error`：HTTP/2 协议错误

## 性能优化

### 零拷贝

- `sendfile` 系统调用（Linux）
- `string_view` 避免字符串拷贝
- 引用传递减少对象拷贝

### 内存池

- 连接池复用
- 缓冲区复用
- 对象池管理

### 并发模型

- 多 IOScheduler 负载均衡
- 每连接一协程，轻量级并发
- 无锁设计，减少竞争

## 项目结构

```text
galay-http/
├── galay-http/
│   ├── kernel/          # 核心实现
│   │   ├── http/        # HTTP/1.1
│   │   ├── http2/       # HTTP/2
│   │   └── websocket/   # WebSocket
│   ├── protoc/          # 协议数据结构
│   │   ├── http/
│   │   ├── http2/
│   │   └── websocket/
│   ├── utils/           # 工具类
│   │   ├── Builder
│   │   ├── Logger
│   │   └── Utils
│   └── module/          # C++23 模块接口
├── examples/             # 示例代码
│   ├── common/          # 公共配置
│   └── include/         # 示例实现
├── test/                # 单元测试
├── benchmark/           # 性能测试
└── docs/                # 文档
```
