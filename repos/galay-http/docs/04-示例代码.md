# 04-示例代码

本文档提供 Galay-HTTP 的常见使用示例。完整可运行示例位于 `examples/include/` 目录。

## HTTP 服务器示例

### 基础 Echo 服务器

```cpp
#include "galay-http/kernel/http/HttpServer.h"
#include "galay-http/kernel/http/HttpRouter.h"
#include "galay-http/protoc/http/HttpRequest.h"
#include "galay-http/utils/Http1_1ResponseBuilder.h"

using namespace galay::http;
using namespace galay::kernel;

Coroutine echoHandler(HttpConn& conn, HttpRequest req) {
    std::string body = req.getBodyStr();

    auto response = Http1_1ResponseBuilder::ok()
        .header("Server", "Galay-HTTP/1.0")
        .text(body.empty() ? "Echo: (empty)" : "Echo: " + body)
        .build();

    auto writer = conn.getWriter();
    while (true) {
        auto result = co_await writer.sendResponse(response);
        if (!result || result.value()) break;
    }

    co_return;
}

int main() {
    HttpRouter router;
    router.addHandler<HttpMethod::POST>("/echo", echoHandler);

    HttpServerConfig config;
    config.host = "0.0.0.0";
    config.port = 8080;

    HttpServer server(config);
    server.start(std::move(router));

    while (true) {
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }

    return 0;
}
```

### RESTful API 服务器

```cpp
#include "galay-http/kernel/http/HttpServer.h"
#include "galay-http/kernel/http/HttpRouter.h"
#include "galay-http/utils/Http1_1ResponseBuilder.h"
#include <unordered_map>
#include <mutex>

using namespace galay::http;
using namespace galay::kernel;

// 简单的内存数据库
struct Database {
    std::unordered_map<std::string, std::string> users;
    std::mutex mutex;
};

Database db;

// GET /users/:id
// 注意：路由参数通过 HttpRouter 的 RouteMatch 传递，不在 HttpRequest 中
// 实际使用时需要在 HttpRouter 内部处理参数提取
Coroutine getUserHandler(HttpConn& conn, HttpRequest req) {
    // 从 URI 中手动解析 ID（实际项目中应通过 RouteMatch 传递）
    std::string uri = req.header().uri();
    std::string id = uri.substr(uri.find_last_of('/') + 1);

    std::lock_guard<std::mutex> lock(db.mutex);
    auto it = db.users.find(id);

    HttpResponse response;
    if (it != db.users.end()) {
        response = Http1_1ResponseBuilder::ok()
            .json("{\"id\":\"" + it->first + "\",\"name\":\"" + it->second + "\"}")
            .build();
    } else {
        response = Http1_1ResponseBuilder::notFound()
            .json("{\"error\":\"User not found\"}")
            .build();
    }

    auto writer = conn.getWriter();
    while (true) {
        auto result = co_await writer.sendResponse(response);
        if (!result || result.value()) break;
    }

    co_return;
}

int main() {
    HttpRouter router;
    router.addHandler<HttpMethod::GET>("/users/:id", getUserHandler);

    HttpServerConfig config;
    config.port = 8080;

    HttpServer server(config);
    server.start(std::move(router));

    while (true) {
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }

    return 0;
}
```

### 静态文件服务器

```cpp
#include "galay-http/kernel/http/HttpServer.h"
#include "galay-http/kernel/http/HttpRouter.h"

using namespace galay::http;

int main(int argc, char* argv[]) {
    int port = 8090;
    std::string root_dir = "./html";

    if (argc > 1) port = std::atoi(argv[1]);
    if (argc > 2) root_dir = argv[2];

    HttpRouter router;

    StaticFileConfig config;
    config.mode = StaticFileConfig::TransferMode::AUTO;
    router.mount("/", root_dir, config);

    HttpServerConfig config;
    config.port = port;

    HttpServer server(config);
    server.start(std::move(router));

    std::cout << "Static file server running on http://0.0.0.0:" << port << "\n";

    while (true) {
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }

    return 0;
}
```

## HTTP 客户端示例

### 基础 GET 请求

```cpp
#include "galay-http/kernel/http/HttpClient.h"
#include "galay-http/utils/Http1_1RequestBuilder.h"
#include "galay-kernel/kernel/Runtime.h"
#include <iostream>

using namespace galay::http;
using namespace galay::kernel;

Coroutine sendGetRequest() {
    HttpClient client;

    // 连接服务器
    auto connect_result = co_await client.connect("http://httpbin.org:80");
    if (!connect_result) {
        std::cerr << "连接失败\n";
        co_return;
    }

    // 获取 Session
    auto session = client.getSession();
    auto writer = session.getWriter();
    auto reader = session.getReader();

    // 构建并发送请求
    auto request = Http1_1RequestBuilder::get("/get")
        .host("httpbin.org")
        .build();

    while (true) {
        auto send_result = co_await writer.sendRequest(request);
        if (!send_result || send_result.value()) break;
    }

    // 接收响应
    HttpResponse response;
    auto recv_result = co_await reader.getResponse(response);
    if (recv_result) {
        std::cout << "状态码: " << static_cast<int>(response.header().code()) << "\n";
        std::cout << "响应体: " << response.getBodyStr() << "\n";
    }

    co_await client.close();
}

int main() {
    Runtime runtime;
    runtime.start();

    auto* scheduler = runtime.getNextIOScheduler();
    scheduler->spawn(sendGetRequest());

    std::this_thread::sleep_for(std::chrono::seconds(3));
    runtime.stop();

    return 0;
}
```

### POST JSON 请求

```cpp
Coroutine sendJsonRequest() {
    HttpClient client;

    auto connect_result = co_await client.connect("http://httpbin.org:80");
    if (!connect_result) {
        std::cerr << "连接失败\n";
        co_return;
    }

    auto session = client.getSession();
    auto writer = session.getWriter();
    auto reader = session.getReader();

    std::string json_body = R"({"name":"Alice","age":30})";

    auto request = Http1_1RequestBuilder::post("/post")
        .host("httpbin.org")
        .header("Content-Type", "application/json")
        .body(json_body)
        .build();

    while (true) {
        auto send_result = co_await writer.sendRequest(request);
        if (!send_result || send_result.value()) break;
    }

    HttpResponse response;
    auto recv_result = co_await reader.getResponse(response);
    if (recv_result) {
        std::cout << "状态码: " << static_cast<int>(response.header().code()) << "\n";
        std::cout << "响应: " << response.getBodyStr() << "\n";
    }

    co_await client.close();
}
```

## WebSocket 示例

### WebSocket 服务器

```cpp
#include "galay-http/kernel/http/HttpServer.h"
#include "galay-http/kernel/websocket/WsUpgrade.h"
#include "galay-http/kernel/websocket/WsConn.h"

using namespace galay::http;
using namespace galay::websocket;
using namespace galay::kernel;

Coroutine handleWebSocket(WsConn& ws_conn) {
    auto reader = ws_conn.getReader(WsReaderSetting{});
    auto writer = ws_conn.getWriter(WsWriterSetting::byServer());

    co_await writer.sendText("Welcome to WebSocket server!");

    while (true) {
        std::string message;
        WsOpcode opcode;

        auto result = co_await reader.getMessage(message, opcode);

        if (!result.has_value()) {
            if (result.error().code() == WsError::Code::CONNECTION_CLOSED) {
                std::cout << "连接已关闭\n";
            }
            break;
        }

        if (!result.value()) continue;

        if (opcode == WsOpcode::Text) {
            std::cout << "收到文本: " << message << "\n";
            co_await writer.sendText("Echo: " + message);
        } else if (opcode == WsOpcode::Ping) {
            co_await writer.sendPong(message);
        } else if (opcode == WsOpcode::Close) {
            break;
        }
    }

    co_await ws_conn.close();
}

Coroutine wsHandler(HttpConn& conn, HttpRequest req) {
    WsUpgrade upgrade;
    auto ws_conn = co_await upgrade.upgrade(conn, req);

    if (ws_conn) {
        co_await handleWebSocket(*ws_conn);
    }

    co_return;
}

int main() {
    HttpRouter router;
    router.addHandler<HttpMethod::GET>("/ws", wsHandler);

    HttpServerConfig config;
    config.port = 8080;

    HttpServer server(config);
    server.start(std::move(router));

    std::cout << "WebSocket server running on ws://0.0.0.0:8080/ws\n";

    while (true) {
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }

    return 0;
}
```

### WebSocket 客户端

```cpp
#include "galay-http/kernel/websocket/WsClient.h"
#include "galay-kernel/kernel/Runtime.h"
#include <iostream>

using namespace galay::websocket;
using namespace galay::kernel;

Coroutine wsClientExample() {
    WsClient client;

    // 连接服务器
    auto connect_result = co_await client.connect("ws://127.0.0.1:8080/ws");
    if (!connect_result) {
        std::cerr << "连接失败\n";
        co_return;
    }

    // 获取 Session 并升级
    auto session = client.getSession(WsWriterSetting::byClient());
    auto upgrader = session.upgrade();
    auto upgrade_result = co_await upgrader();
    if (!upgrade_result) {
        std::cerr << "升级失败\n";
        co_return;
    }

    // 获取连接
    auto conn = session.getConn();
    if (!conn) {
        std::cerr << "获取连接失败\n";
        co_return;
    }

    auto reader = conn->getReader(WsReaderSetting{});
    auto writer = conn->getWriter(WsWriterSetting::byClient());

    co_await writer.sendText("Hello, WebSocket!");

    std::string message;
    WsOpcode opcode;

    auto result = co_await reader.getMessage(message, opcode);
    if (result.has_value() && result.value()) {
        std::cout << "收到: " << message << "\n";
    }

    co_await writer.sendClose(1000, "Normal closure");
    co_await conn->close();
}
```

## HTTP/2 示例

### H2c 客户端

```cpp
#include "galay-http/kernel/http2/H2cClient.h"
#include "galay-kernel/kernel/Runtime.h"
#include <iostream>

using namespace galay::http2;
using namespace galay::kernel;

Coroutine h2cClientExample() {
    H2cClient client;

    // 连接服务器
    auto conn_result = co_await client.connect("127.0.0.1", 9080);
    if (!conn_result) {
        std::cerr << "连接失败\n";
        co_return;
    }

    // 升级到 HTTP/2
    co_await client.upgrade("/").wait();

    if (!client.isUpgraded()) {
        std::cerr << "升级失败\n";
        co_return;
    }

    // 发送 GET 请求
    auto stream = client.get("/");

    // 读取响应
    co_await stream->readResponse().wait();

    // 获取响应数据
    auto& response = stream->response();
    std::cout << "收到响应，头部数量: " << response.headers().size() << "\n";
    for (const auto& header : response.headers()) {
        std::cout << header.name << ": " << header.value << "\n";
    }
    std::cout << "响应体: " << response.body() << "\n";

    // 关闭连接
    co_await client.shutdown().wait();
}
```

## 完整示例位置

仓库中的完整可运行示例：

- `examples/include/E1-EchoServer.cpp` - HTTP Echo 服务器
- `examples/include/E2-EchoClient.cpp` - HTTP Echo 客户端
- `examples/include/E3-WebsocketServer.cpp` - WebSocket 服务器
- `examples/include/E4-WebsocketClient.cpp` - WebSocket 客户端
- `examples/include/E5-HttpsServer.cpp` - HTTPS 服务器
- `examples/include/E6-HttpsClient.cpp` - HTTPS 客户端
- `examples/include/E7-WssServer.cpp` - WSS 服务器
- `examples/include/E8-WssClient.cpp` - WSS 客户端
- `examples/include/E9-H2cEchoServer.cpp` - HTTP/2 服务器
- `examples/include/E10-H2cEchoClient.cpp` - HTTP/2 客户端
- `examples/include/E11-StaticServer.cpp` - 静态文件服务器
- `examples/include/E12-HttpProxy.cpp` - HTTP 反向代理

## 构建示例

```bash
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release
cmake --build build --parallel

# 运行示例
./build/examples/E1-EchoServer 8080
./build/examples/E3-WebsocketServer
./build/examples/E11-StaticServer 8090 ./html
```
