# 05-高级主题

## 性能优化

### 静态文件传输优化

根据文件大小选择合适的传输模式：

```cpp
HttpRouter router;

// 小文件（< 1MB）：内存传输
StaticFileConfig memory_config;
memory_config.mode = StaticFileConfig::TransferMode::MEMORY;
router.mount("/images", "./images", memory_config);

// 大文件：零拷贝传输
StaticFileConfig sendfile_config;
sendfile_config.mode = StaticFileConfig::TransferMode::SENDFILE;
router.mount("/videos", "./videos", sendfile_config);

// 自动选择（推荐）
StaticFileConfig auto_config;
auto_config.mode = StaticFileConfig::TransferMode::AUTO;
router.mount("/files", "./files", auto_config);
```

### Keep-Alive 连接复用

HTTP/1.1 默认启用 Keep-Alive，客户端可复用连接：

```cpp
Coroutine multipleRequests() {
    HttpClient client;
    co_await client.connect("http://api.example.com:80");

    auto session = client.getSession();
    auto writer = session.getWriter();
    auto reader = session.getReader();

    // 复用同一连接发送多个请求
    auto req1 = Http1_1RequestBuilder::get("/api/v1/users").host("api.example.com").build();
    co_await writer.sendRequest(req1);
    HttpResponse resp1;
    co_await reader.getResponse(resp1);

    auto req2 = Http1_1RequestBuilder::get("/api/v1/posts").host("api.example.com").build();
    co_await writer.sendRequest(req2);
    HttpResponse resp2;
    co_await reader.getResponse(resp2);

    co_await client.close();
}
```

### HTTP/2 多路复用

HTTP/2 支持单连接多流并发，显著提升性能。

## 中间件模式

### 日志中间件

```cpp
Coroutine loggingMiddleware(HttpConn& conn, HttpRequest req) {
    auto start = std::chrono::steady_clock::now();
    std::cout << "[" << httpMethodToString(req.header().method()) << "] "
              << req.header().uri() << "\n";

    // 调用实际处理器
    co_await actualHandler(conn, req);

    auto end = std::chrono::steady_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    std::cout << "Request took " << duration.count() << " ms\n";
}
```

### 认证中间件

```cpp
Coroutine authMiddleware(HttpConn& conn, HttpRequest req) {
    std::string auth_header;
    if (req.header().headerPairs().hasKey("Authorization")) {
        auth_header = req.header().headerPairs().getValue("Authorization");
    }

    if (auth_header.empty() || !validateToken(auth_header)) {
        auto response = Http1_1ResponseBuilder::unauthorized()
            .json("{\"error\":\"Unauthorized\"}")
            .build();

        auto writer = conn.getWriter();
        while (true) {
            auto result = co_await writer.sendResponse(response);
            if (!result || result.value()) break;
        }
        co_return;
    }

    co_await actualHandler(conn, req);
}
```

## WebSocket 高级用法

### 心跳保活

```cpp
Coroutine wsHeartbeat(WsWriter& writer) {
    while (true) {
        co_await galay::kernel::sleep(std::chrono::seconds(30));
        auto result = co_await writer.sendPing();
        if (!result) break;
    }
}
```

### 广播消息

```cpp
struct BroadcastManager {
    std::vector<WsWriter*> clients;
    std::mutex mutex;

    void addClient(WsWriter* writer) {
        std::lock_guard<std::mutex> lock(mutex);
        clients.push_back(writer);
    }

    Coroutine broadcast(const std::string& message) {
        std::lock_guard<std::mutex> lock(mutex);
        for (auto* client : clients) {
            co_await client->sendText(message);
        }
    }
};
```

## 错误处理策略

### 重试机制

```cpp
template<typename Func>
Coroutine retryWithBackoff(Func func, int max_retries = 3) {
    for (int i = 0; i < max_retries; ++i) {
        auto result = co_await func();
        if (result) co_return result;

        if (i < max_retries - 1) {
            auto delay = std::chrono::seconds(1 << i);  // 指数退避
            co_await galay::kernel::sleep(delay);
        }
    }
    co_return std::nullopt;
}
```

### 超时处理

```cpp
Coroutine requestWithTimeout() {
    HttpClient client;
    co_await client.connect("http://api.example.com:80");

    auto session = client.getSession();
    auto writer = session.getWriter();
    auto reader = session.getReader();

    auto request = Http1_1RequestBuilder::get("/api/slow")
        .host("api.example.com")
        .build();

    // 发送请求
    co_await writer.sendRequest(request);

    // 接收响应（带超时）
    HttpResponse response;
    auto read_awaitable = reader.getResponse(response);
    auto result = co_await read_awaitable.timeout(std::chrono::seconds(5));

    if (!result.has_value()) {
        std::cerr << "请求超时\n";
    }

    co_await client.close();
}
```

## 安全性

### HTTPS 配置

```cpp
HttpsServerConfig config;
config.port = 8443;
config.cert_file = "/etc/ssl/certs/server.crt";
config.key_file = "/etc/ssl/private/server.key";

HttpsServer server(config);
```

### 输入验证

```cpp
Coroutine validateInput(HttpConn& conn, HttpRequest req) {
    std::string body = req.body().getBodyStr();

    // 检查请求体大小
    if (body.size() > 1024 * 1024) {  // 1MB
        auto response = Http1_1ResponseBuilder::badRequest()
            .json("{\"error\":\"Request body too large\"}")
            .build();

        auto writer = conn.getWriter();
        while (true) {
            auto result = co_await writer.sendResponse(response);
            if (!result || result.value()) break;
        }
        co_return;
    }

    // 处理请求
}
```

### 速率限制

```cpp
struct RateLimiter {
    std::unordered_map<std::string, std::pair<int, std::chrono::steady_clock::time_point>> requests;
    std::mutex mutex;
    int max_requests = 100;
    std::chrono::seconds window = std::chrono::seconds(60);

    bool allowRequest(const std::string& client_ip) {
        std::lock_guard<std::mutex> lock(mutex);
        auto now = std::chrono::steady_clock::now();
        auto& [count, last_reset] = requests[client_ip];

        if (now - last_reset > window) {
            count = 0;
            last_reset = now;
        }

        if (count >= max_requests) return false;

        ++count;
        return true;
    }
};
```

## 与其他库集成

### 与 JSON 库集成

```cpp
#include <nlohmann/json.hpp>

using json = nlohmann::json;

Coroutine jsonApiHandler(HttpConn& conn, HttpRequest req) {
    try {
        json request_json = json::parse(req.body().getBodyStr());
        std::string name = request_json["name"];

        json response_json = {
            {"status", "success"},
            {"data", {{"name", name}}}
        };

        auto response = Http1_1ResponseBuilder::ok()
            .json(response_json.dump())
            .build();

        auto writer = conn.getWriter();
        while (true) {
            auto result = co_await writer.sendResponse(response);
            if (!result || result.value()) break;
        }

    } catch (const json::exception& e) {
        auto response = Http1_1ResponseBuilder::badRequest()
            .json("{\"error\":\"Invalid JSON\"}")
            .build();

        auto writer = conn.getWriter();
        while (true) {
            auto result = co_await writer.sendResponse(response);
            if (!result || result.value()) break;
        }
    }

    co_return;
}
```

### 与数据库集成

参考 galay-mysql 文档，可以在 HTTP 处理器中使用异步数据库客户端。

## 调试技巧

### 启用日志

```cpp
#include "galay-http/kernel/http/HttpLog.h"

int main() {
    spdlog::set_level(spdlog::level::debug);

    HttpServer server(config);
    server.start(std::move(router));

    return 0;
}
```

### 性能分析

```cpp
Coroutine profiledHandler(HttpConn& conn, HttpRequest req) {
    auto start = std::chrono::high_resolution_clock::now();

    // 处理请求
    auto response = Http1_1ResponseBuilder::ok()
        .text("Hello, World!")
        .build();

    auto writer = conn.getWriter();
    while (true) {
        auto result = co_await writer.sendResponse(response);
        if (!result || result.value()) break;
    }

    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    std::cout << "Handler took " << duration.count() << " μs\n";

    co_return;
}
```
