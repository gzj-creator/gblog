# 06-常见问题

## 编译相关

### Q: 编译时找不到 galay-kernel 头文件

**A:** 确保 CMake 能找到依赖库，使用 `CMAKE_PREFIX_PATH` 指定：

```bash
cmake -S . -B build \
  -DCMAKE_PREFIX_PATH="/path/to/galay-kernel;/path/to/galay-utils"
```

### Q: 链接时出现 undefined reference 错误

**A:** 检查链接库是否完整：

```cmake
target_link_libraries(your_target PRIVATE
    galay-http
    galay-kernel
    galay-utils
    spdlog::spdlog
)

# 启用 SSL 时还需要
target_link_libraries(your_target PRIVATE
    galay-ssl
    OpenSSL::SSL
    OpenSSL::Crypto
)
```

### Q: 模块编译失败

**A:** 模块编译有严格的工具链要求：

- CMake >= 3.28
- Ninja 或 Visual Studio 生成器
- GCC >= 14 或 Clang >= 16

不满足条件时会自动降级到 include 路径。

### Q: 编译时出现 C++23 特性不支持

**A:** 确保编译器支持 C++23：

```bash
# GCC
g++ --version  # 需要 >= 11

# Clang
clang++ --version  # 需要 >= 14
```

## 服务器相关

### Q: 服务器启动失败：Address already in use

**A:** 端口被占用，检查并释放端口：

```bash
# Linux
netstat -tlnp | grep 8080
kill <pid>

# macOS
lsof -i :8080
kill <pid>
```

或更换端口：

```cpp
HttpServerConfig config;
config.port = 8081;  // 使用其他端口
```

### Q: 如何处理大文件上传？

**A:** 配置最大请求体大小：

```cpp
HttpServerConfig config;
config.max_body_size = 100 * 1024 * 1024;  // 100MB
```

对于超大文件，建议使用分块上传或流式处理。

### Q: 如何实现 CORS？

**A:** 在处理器中添加 CORS 头部：

```cpp
Coroutine corsHandler(HttpConn& conn, HttpRequest req) {
    auto response = Http1_1ResponseBuilder::ok()
        .header("Access-Control-Allow-Origin", "*")
        .header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE")
        .header("Access-Control-Allow-Headers", "Content-Type")
        .text("Hello")
        .build();

    auto writer = conn.getWriter();
    while (true) {
        auto result = co_await writer.sendResponse(response);
        if (!result || result.value()) break;
    }

    co_return;
}
```

### Q: 如何获取客户端 IP 地址？

**A:** 当前版本需要从连接对象获取，或从 `X-Forwarded-For` 头部读取（如果使用了代理）：

```cpp
auto forwarded_for = req.getHeader("X-Forwarded-For");
if (forwarded_for) {
    std::string client_ip = *forwarded_for;
}
```

### Q: 静态文件服务器不工作

**A:** 检查以下几点：

1. 文件路径是否正确
2. 文件权限是否可读
3. 挂载路径是否正确

```cpp
// 确保路径存在
router.mount("/static", "./html", TransferMode::AUTO);

// 访问 http://localhost:8080/static/index.html
// 对应文件 ./html/index.html
```

## 客户端相关

### Q: 客户端连接失败

**A:** 检查以下几点：

1. 服务器是否运行
2. 主机名和端口是否正确
3. 网络连接是否正常
4. 防火墙是否阻止连接

```cpp
auto session = co_await client.connect("127.0.0.1", 8080);
if (!session) {
    std::cerr << "连接失败，检查服务器是否运行\n";
}
```

### Q: 如何设置请求超时？

**A:** 使用 `timeout()` 方法：

```cpp
auto response_aw = session->get("/api/data");
auto result = co_await response_aw.timeout(std::chrono::seconds(10));

if (!result.has_value()) {
    std::cerr << "请求超时\n";
}
```

### Q: 如何发送自定义头部？

**A:** 在请求方法中传递头部映射：

```cpp
std::unordered_map<std::string, std::string> headers = {
    {"Authorization", "Bearer token123"},
    {"User-Agent", "MyApp/1.0"}
};

auto response = co_await session->get("/api/data", headers);
```

### Q: 如何处理重定向？

**A:** 当前版本不自动处理重定向，需要手动检查状态码：

```cpp
auto response = co_await session->get("/redirect");
if (response && response->getStatus() == 302) {
    auto location = response->getHeader("Location");
    if (location) {
        // 手动跟随重定向
        auto redirect_response = co_await session->get(*location);
    }
}
```

## WebSocket 相关

### Q: WebSocket 连接断开

**A:** 可能原因：

1. 网络不稳定
2. 服务器超时关闭
3. 未处理 Ping/Pong 心跳

解决方案：

```cpp
// 启用自动 Ping/Pong 处理
WsReaderSetting setting;
setting.auto_handle_ping = true;
auto reader = ws_conn.getReader(setting);

// 或手动发送心跳
Coroutine heartbeat(WsWriter& writer) {
    while (true) {
        co_await galay::kernel::sleep(std::chrono::seconds(30));
        co_await writer.sendPing();
    }
}
```

### Q: WebSocket 消息过大

**A:** 配置最大消息大小：

```cpp
WsReaderSetting setting;
setting.max_frame_size = 10 * 1024 * 1024;      // 10MB
setting.max_message_size = 100 * 1024 * 1024;   // 100MB
auto reader = ws_conn.getReader(setting);
```

### Q: 如何区分文本和二进制消息？

**A:** 通过 `WsOpcode` 判断：

```cpp
std::string message;
WsOpcode opcode;
auto result = co_await reader.getMessage(message, opcode);

if (result.has_value() && result.value()) {
    if (opcode == WsOpcode::Text) {
        std::cout << "文本消息: " << message << "\n";
    } else if (opcode == WsOpcode::Binary) {
        std::cout << "二进制消息: " << message.size() << " 字节\n";
    }
}
```

### Q: WebSocket 客户端必须设置掩码吗？

**A:** 是的，根据 RFC 6455 规范，客户端发送的所有帧必须设置掩码：

```cpp
auto writer = ws_conn.getWriter(WsWriterSetting::byClient());  // mask = true
```

服务器端不应设置掩码：

```cpp
auto writer = ws_conn.getWriter(WsWriterSetting::byServer());  // mask = false
```

## HTTP/2 相关

### Q: H2c 升级失败

**A:** 确保服务器支持 HTTP/2 升级：

1. 服务器必须支持 `Upgrade: h2c` 头部
2. 检查服务器是否正确响应 101 Switching Protocols

### Q: 如何并发发送多个 HTTP/2 请求？

**A:** 创建多个流并发发送：

```cpp
std::vector<Http2Stream*> streams;
for (int i = 0; i < 10; ++i) {
    auto stream = client.createStream();
    if (stream) streams.push_back(*stream);
}

// 并发发送
for (auto* stream : streams) {
    co_await stream->sendHeaders(headers, true);
}
```

### Q: HTTP/2 流量控制错误

**A:** 确保正确处理 WINDOW_UPDATE 帧，当前版本自动处理流量控制。

## TLS/SSL 相关

### Q: HTTPS 服务器启动失败

**A:** 检查证书和密钥文件：

1. 文件路径是否正确
2. 文件权限是否可读
3. 证书和密钥是否匹配

```bash
# 验证证书
openssl x509 -in cert.pem -text -noout

# 验证密钥
openssl rsa -in key.pem -check
```

### Q: 如何生成自签名证书？

**A:** 使用 OpenSSL 生成：

```bash
# 生成私钥
openssl genrsa -out key.pem 2048

# 生成证书
openssl req -new -x509 -key key.pem -out cert.pem -days 365
```

### Q: WSS 连接失败

**A:** 确保：

1. 服务器证书有效
2. 客户端信任服务器证书
3. 端口正确（通常是 443）

## 性能相关

### Q: 如何提升服务器性能？

**A:** 优化建议：

1. 使用 Release 构建
2. 调整工作线程数
3. 使用静态文件硬加载
4. 启用 Keep-Alive
5. 使用 HTTP/2

```cpp
HttpServerConfig config;
config.worker_threads = std::thread::hardware_concurrency();
```

### Q: 内存占用过高

**A:** 优化建议：

1. 减小最大请求体大小
2. 使用动态挂载而非硬加载
3. 及时关闭不用的连接
4. 检查是否有内存泄漏

### Q: 如何进行压力测试？

**A:** 使用 wrk 或 ab 工具：

```bash
# wrk
wrk -t4 -c100 -d30s http://127.0.0.1:8080/

# ab
ab -n 10000 -c 100 http://127.0.0.1:8080/
```

## 其他

### Q: 如何贡献代码？

**A:** 欢迎提交 PR 到 GitHub 仓库：

1. Fork 仓库
2. 创建特性分支
3. 提交代码并编写测试
4. 发起 Pull Request

### Q: 如何报告 Bug？

**A:** 在 GitHub Issues 中提交，包含：

- 复现步骤
- 预期行为和实际行为
- 环境信息（OS、编译器版本）
- 相关日志和错误信息

### Q: 生产环境可以使用吗？

**A:** 项目处于活跃开发中，建议：

- 充分测试后再用于生产
- 关注 GitHub 更新和 Bug 修复
- 做好错误处理和监控
- 准备降级方案

### Q: 与其他 C++ HTTP 库相比有什么优势？

**A:**

- 现代 C++23 接口
- 基于协程的异步支持
- 类型安全的错误处理（`std::expected`）
- 统一的 HTTP/WebSocket/HTTP2 接口
- 零拷贝优化
- 模块化设计
