# 05. 调度器 API

## Scheduler 基类

`Scheduler` 是所有调度器的统一接口：

```cpp
class Scheduler {
public:
    virtual void start() = 0;
    virtual void stop() = 0;

    virtual bool spawn(Coroutine co) = 0;
    virtual bool spawnImmidiately(Coroutine co) = 0;

    virtual bool addTimer(Timer::ptr timer) = 0;
    virtual SchedulerType type() = 0;

    std::thread::id threadId() const;
};
```

## IOScheduler 抽象接口

`IOScheduler` 继承 `Scheduler`，负责注册各类 IO 事件（TCP/UDP/文件/文件监控/sendfile/custom）。

关键特性：

- 单线程事件循环 + 无锁协程队列
- 统一 awaitable 事件注册接口
- 内置 `TimingWheelTimerManager`（用于 IO 超时）

## 平台实现

### KqueueScheduler (macOS)

```cpp
KqueueScheduler(
    int max_events = GALAY_SCHEDULER_MAX_EVENTS,
    int batch_size = GALAY_SCHEDULER_BATCH_SIZE,
    int check_interval_ms = GALAY_SCHEDULER_CHECK_INTERVAL_MS);
```

### EpollScheduler (Linux)

```cpp
EpollScheduler(
    int max_events = GALAY_SCHEDULER_MAX_EVENTS,
    int batch_size = GALAY_SCHEDULER_BATCH_SIZE,
    int check_interval_ms = GALAY_SCHEDULER_CHECK_INTERVAL_MS);
```

### IOUringScheduler (Linux)

```cpp
IOUringScheduler(
    int queue_depth = GALAY_SCHEDULER_QUEUE_DEPTH,
    int batch_size = GALAY_SCHEDULER_BATCH_SIZE);
```

## 使用示例

```cpp
#include "galay-kernel/kernel/KqueueScheduler.h"

using namespace galay::kernel;

int main() {
    KqueueScheduler scheduler;
    scheduler.start();

    scheduler.spawn(myCoroutine());

    std::this_thread::sleep_for(std::chrono::seconds(10));
    scheduler.stop();
    return 0;
}
```

## 运行时推荐

生产场景建议优先用 `Runtime` 管理多个 IO/Compute 调度器：

- 自动创建默认数量调度器
- 轮询负载均衡 `getNextIOScheduler()` / `getNextComputeScheduler()`
- 自动启动/停止全局 `TimerScheduler`

详见：[13-运行时Runtime.md](13-运行时Runtime.md)

## 编译宏

| 宏 | 说明 |
|---|---|
| `USE_KQUEUE` | 使用 kqueue 后端 |
| `USE_EPOLL` | 使用 epoll 后端 |
| `USE_IOURING` | 使用 io_uring 后端 |
| `GALAY_SCHEDULER_MAX_EVENTS` | 单轮处理最大事件数 |
| `GALAY_SCHEDULER_BATCH_SIZE` | 协程批处理大小 |
| `GALAY_SCHEDULER_CHECK_INTERVAL_MS` | kqueue/epoll 轮询间隔 |
| `GALAY_SCHEDULER_QUEUE_DEPTH` | io_uring 队列深度 |
