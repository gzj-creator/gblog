# 06-协程

## Coroutine

`Coroutine` 是框架统一的协程返回类型：

```cpp
class Coroutine {
public:
    using promise_type = PromiseType;

    bool isValid() const;
    bool done() const;

    WaitResult wait();

    Scheduler* belongScheduler() const;
    void belongScheduler(Scheduler* scheduler);
    std::thread::id threadId() const;
};
```

## spawn 辅助函数

在协程内部可以使用：

```cpp
co_await spawn(otherCoroutine());
```

这会把子协程提交到当前协程所属调度器，不阻塞当前协程。

## wait 等待另一个协程

```cpp
Coroutine child();

Coroutine parent() {
    Coroutine c = child();
    co_await c.wait();
    co_return;
}
```

## timeout 机制

大部分 Awaitable 都支持 `.timeout()`，例如：

```cpp
#include "galay-kernel/kernel/Timeout.hpp"
using namespace std::chrono_literals;

auto result = co_await socket.recv(buf, len).timeout(5s);
if (!result && IOError::contains(result.error().code(), kTimeout)) {
    // 处理超时
}
```

## sleep 协程休眠

```cpp
#include "galay-kernel/common/Sleep.hpp"
using namespace std::chrono_literals;

Coroutine task() {
    co_await sleep(100ms);
    co_await sleep(1s);
}
```

注意：

- `sleep()` 基于全局 `TimerScheduler`
- 使用 `Runtime` 时会自动启动 `TimerScheduler`
- 若手动使用调度器，需要自己调用 `TimerScheduler::getInstance()->start()`

## 示例：带超时的会话处理

```cpp
Coroutine handleClient(TcpSocket client) {
    char buffer[4096];

    while (true) {
        auto recvResult = co_await client.recv(buffer, sizeof(buffer)).timeout(30s);
        if (!recvResult) {
            if (IOError::contains(recvResult.error().code(), kTimeout)) {
                // 空闲超时
            }
            break;
        }

        auto& bytes = recvResult.value();
        if (bytes.size() == 0) {
            break;
        }

        auto sendResult = co_await client.send(bytes.c_str(), bytes.size()).timeout(5s);
        if (!sendResult) {
            break;
        }
    }

    co_await client.close();
}
```
