# 07-网络IO

## TcpSocket

`TcpSocket` 为协程场景封装了 TCP 异步 IO：

```cpp
class TcpSocket {
public:
    explicit TcpSocket(IPType type = IPType::IPV4);
    explicit TcpSocket(GHandle handle);

    GHandle handle() const;
    IOController* controller();
    HandleOption option();

    std::expected<void, IOError> bind(const Host& host);
    std::expected<void, IOError> listen(int backlog = 128);

    AcceptAwaitable accept(Host* clientHost);
    ConnectAwaitable connect(const Host& host);

    RecvAwaitable recv(char* buffer, size_t length);
    SendAwaitable send(const char* buffer, size_t length);

    ReadvAwaitable readv(std::vector<struct iovec> iovecs);
    WritevAwaitable writev(std::vector<struct iovec> iovecs);

    SendFileAwaitable sendfile(int file_fd, off_t offset, size_t count);

    CloseAwaitable close();
};
```

说明：

- `TcpSocket` 构造时就会创建 socket，不需要 `create()`
- 建议在异步使用前显式设置 `handleNonBlock()`

### Echo 服务端示例

```cpp
Coroutine handleClient(GHandle handle) {
    TcpSocket client(handle);
    client.option().handleNonBlock();

    char buffer[4096];
    while (true) {
        auto recvResult = co_await client.recv(buffer, sizeof(buffer));
        if (!recvResult || recvResult.value().size() == 0) {
            break;
        }
        auto& bytes = recvResult.value();
        co_await client.send(bytes.c_str(), bytes.size());
    }

    co_await client.close();
}

Coroutine server(IOScheduler* scheduler) {
    TcpSocket listener;
    listener.option().handleReuseAddr();
    listener.option().handleNonBlock();

    if (!listener.bind(Host(IPType::IPV4, "0.0.0.0", 8080))) {
        co_return;
    }
    if (!listener.listen(1024)) {
        co_return;
    }

    while (true) {
        Host peer;
        auto accepted = co_await listener.accept(&peer);
        if (accepted) {
            scheduler->spawn(handleClient(accepted.value()));
        }
    }
}
```

### 客户端示例

```cpp
Coroutine client() {
    TcpSocket socket;
    socket.option().handleNonBlock();

    auto connected = co_await socket.connect(Host(IPType::IPV4, "127.0.0.1", 8080));
    if (!connected) {
        co_return;
    }

    const char* msg = "hello";
    co_await socket.send(msg, 5);

    char buf[1024];
    auto recvResult = co_await socket.recv(buf, sizeof(buf));
    (void)recvResult;

    co_await socket.close();
}
```

## UdpSocket

`UdpSocket` 提供协程友好的 UDP 收发：

```cpp
class UdpSocket {
public:
    explicit UdpSocket(IPType type = IPType::IPV4);
    explicit UdpSocket(GHandle handle);

    GHandle handle() const;
    IOController* controller();
    HandleOption option();

    std::expected<void, IOError> bind(const Host& host);

    RecvFromAwaitable recvfrom(char* buffer, size_t length, Host* from);
    SendToAwaitable sendto(const char* buffer, size_t length, const Host& to);

    CloseAwaitable close();
};
```

## Host

`Host` 封装 IPv4/IPv6 地址：

```cpp
enum class IPType : uint8_t { IPV4 = 0, IPV6 = 1 };

struct Host {
    Host();
    Host(IPType proto, const std::string& ip, uint16_t port);
    static Host fromSockAddr(const sockaddr_storage& addr);

    bool isIPv4() const;
    bool isIPv6() const;
    std::string ip() const;
    uint16_t port() const;
};
```

## HandleOption

当前支持的句柄选项：

```cpp
class HandleOption {
public:
    std::expected<void, IOError> handleBlock();
    std::expected<void, IOError> handleNonBlock();
    std::expected<void, IOError> handleReuseAddr();
    std::expected<void, IOError> handleReusePort();
};
```

## readv/writev 与 RingBuffer

`TcpSocket` 支持 `readv/writev`，建议与 [11-环形缓冲区.md](11-环形缓冲区.md) 配合，减少拷贝并提升吞吐。

## sendfile

`TcpSocket::sendfile()` 用于零拷贝发送文件，详见 [12-零拷贝发送文件.md](12-零拷贝发送文件.md)。

## 性能压测数据

网络 IO 汇总数据见 [02-性能测试.md](02-性能测试.md)，UDP 专项见 [04-UDP性能测试.md](04-UDP性能测试.md)。
