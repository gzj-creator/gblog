# 08-文件IO

## 平台模型

| 平台后端 | 文件 API | 说明 |
|---|---|---|
| `USE_KQUEUE` | `AsyncFile` | 普通文件异步读写接口 |
| `USE_IOURING` | `AsyncFile` | io_uring 原生文件异步 |
| `USE_EPOLL` | `AioFile` | 基于 libaio，面向批量提交 |

## AsyncFile（kqueue/io_uring）

```cpp
enum class FileOpenMode : int {
    Read, Write, ReadWrite, Append, Truncate
};

class AsyncFile {
public:
    AsyncFile();

    std::expected<void, IOError> open(const std::string& path,
                                      FileOpenMode mode,
                                      int permissions = 0644);

    FileReadAwaitable read(char* buffer, size_t length, off_t offset = 0);
    FileWriteAwaitable write(const char* buffer, size_t length, off_t offset = 0);

    CloseAwaitable close();

    std::expected<size_t, IOError> size() const;
    std::expected<void, IOError> sync();

    GHandle handle() const;
};
```

### AsyncFile 示例

```cpp
Coroutine readWholeFile(const std::string& path) {
    AsyncFile file;

    auto opened = file.open(path, FileOpenMode::Read);
    if (!opened) {
        co_return;
    }

    auto sizeResult = file.size();
    if (!sizeResult) {
        co_await file.close();
        co_return;
    }

    std::vector<char> buffer(sizeResult.value());
    auto readResult = co_await file.read(buffer.data(), buffer.size(), 0);
    (void)readResult;

    co_await file.close();
}
```

## AioFile（epoll + libaio）

`AioFile` 是 Linux epoll 模式下的批量文件 IO 接口。

```cpp
enum class AioOpenMode : int {
    Read,
    Write,
    ReadWrite,
};

class AioFile {
public:
    AioFile(int max_events = 64);

    std::expected<void, IOError> open(const std::string& path,
                                      AioOpenMode mode,
                                      int permissions = 0644);

    void preRead(char* buffer, size_t length, off_t offset);
    void preWrite(const char* buffer, size_t length, off_t offset);

    void preReadBatch(const std::vector<std::tuple<char*, size_t, off_t>>& reads);
    void preWriteBatch(const std::vector<std::tuple<const char*, size_t, off_t>>& writes);

    AioCommitAwaitable commit(); // co_await 后返回 std::expected<std::vector<ssize_t>, IOError>

    void clear();
    void close();

    static char* allocAlignedBuffer(size_t size, size_t alignment = 512);
    static void freeAlignedBuffer(char* buffer);
};
```

### AioFile 示例（512 对齐）

```cpp
Coroutine epollAioRead(const std::string& path) {
    AioFile file;
    auto opened = file.open(path, AioOpenMode::Read);
    if (!opened) {
        co_return;
    }

    char* buf = AioFile::allocAlignedBuffer(4096, 512);
    if (!buf) {
        file.close();
        co_return;
    }

    file.preRead(buf, 4096, 0);
    auto result = co_await file.commit();
    (void)result;

    AioFile::freeAlignedBuffer(buf);
    file.close();
}
```

## 与 FileWatcher 的关系

文件变更监控不是 `AsyncFile/AioFile` 的职责，使用独立组件 `FileWatcher`，详见 [14-文件监控.md](14-文件监控.md)。

## 性能测试入口

- 基准程序：`benchmark/B7-FileIo.cc`
- 可执行文件：`./build/bin/B7-FileIo`

## 性能压测数据

文件 IO 汇总数据见 [02-性能测试.md](02-性能测试.md)。
