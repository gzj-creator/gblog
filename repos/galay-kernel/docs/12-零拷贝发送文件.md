# 12. 零拷贝发送文件

## 概述

`TcpSocket::sendfile()` 使用内核零拷贝路径把文件内容发送到 socket，适合大文件下载/分发场景。

```cpp
SendFileAwaitable sendfile(int file_fd, off_t offset, size_t count);
```

返回值：`std::expected<size_t, IOError>`（本次实际发送字节数）。

## 基本示例

```cpp
Coroutine sendFileOnce(TcpSocket client, const char* path) {
    int fd = ::open(path, O_RDONLY);
    if (fd < 0) {
        co_await client.close();
        co_return;
    }

    off_t offset = 0;
    size_t total = 0;

    while (true) {
        auto sent = co_await client.sendfile(fd, offset, 1024 * 1024);
        if (!sent || sent.value() == 0) {
            break;
        }
        offset += static_cast<off_t>(sent.value());
        total += sent.value();
    }

    ::close(fd);
    co_await client.close();
}
```

## 对比基准

仓库内已提供对比程序：

- 源码：`benchmark/B13-Sendfile.cc`
- 可执行文件：`./build/bin/B13-Sendfile`

运行示例：

```bash
cmake --build build --target B13-Sendfile
./build/bin/B13-Sendfile
```

## 性能基准

`B13-Sendfile` 会输出 `sendfile` 与 `read+send` 的耗时和吞吐对比结果。

## 功能测试

- `test/T23-SendfileBasic.cc`
- `test/T22-Sendfile.cc`

运行示例：

```bash
cmake --build build --target T23-SendfileBasic T22-Sendfile
./build/bin/T23-SendfileBasic
./build/bin/T22-Sendfile
```

## 注意事项

1. `sendfile` 可能出现“部分发送”，需要循环发送直到完成。
2. 文件描述符生命周期由调用方管理（打开/关闭）。
3. 建议 socket 处于非阻塞模式，并结合 `.timeout()` 做超时保护。
4. 项目编译标准为 **C++23**（顶层 `CMakeLists.txt` 已设置 `CMAKE_CXX_STANDARD 23`）。
