# 15. 异步同步原语

## AsyncMutex

`AsyncMutex` 是协程友好的互斥锁，锁竞争时挂起协程而不是阻塞线程。

```cpp
class AsyncMutex {
public:
    explicit AsyncMutex(size_t initial_capacity = 32);

    AsyncMutexAwaitable lock(); // co_await -> std::expected<void, IOError>
    void unlock();

    bool isLocked() const;
};
```

### 示例

```cpp
AsyncMutex mutex;
int sharedCounter = 0;

Coroutine worker() {
    auto locked = co_await mutex.lock().timeout(std::chrono::milliseconds(100));
    if (!locked) {
        co_return;
    }

    ++sharedCounter;
    mutex.unlock();
}
```

## AsyncWaiter

`AsyncWaiter<T>` 用于跨协程/跨线程等待一次结果，常见于 IO 协程等待计算协程返回。

```cpp
template<typename T>
class AsyncWaiter {
public:
    AsyncWaiterAwaitable<T> wait(); // co_await -> std::expected<T, IOError>
    bool notify(T result);

    bool isWaiting() const;
    bool isReady() const;
};

// void 特化
AsyncWaiter<void> waiter;
```

### 示例：IO 等待 Compute 结果

```cpp
Coroutine computeJob(AsyncWaiter<int>* waiter) {
    int sum = 0;
    for (int i = 0; i < 10000; ++i) {
        sum += i;
    }
    waiter->notify(sum);
}

Coroutine ioTask(ComputeScheduler* compute) {
    AsyncWaiter<int> waiter;
    compute->spawn(computeJob(&waiter));

    auto result = co_await waiter.wait().timeout(std::chrono::seconds(1));
    if (result) {
        int value = result.value();
        (void)value;
    }
}
```

## 使用建议

1. `AsyncMutex` 适合同一进程内协程临界区保护。
2. `AsyncWaiter` 设计为“一次通知/一次等待”模型，单实例不要重复复用。
3. 超时场景建议统一配合 `.timeout()`，并检查 `kTimeout`。
