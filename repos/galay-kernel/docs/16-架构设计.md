# 16-架构设计

## 整体分层

Galay-Kernel 采用分层架构设计：

```text
Application Layer
  ├─ User Coroutines
  └─ High-level APIs (TcpSocket, AsyncFile, MpscChannel, etc.)
        ↓
Async Layer
  ├─ Awaitable Abstractions (CustomAwaitable, Timeout)
  ├─ Coroutine Support (Coroutine, PromiseType)
  └─ Async Primitives (AsyncMutex, AsyncWaiter)
        ↓
Scheduler Layer
  ├─ Runtime (Multi-scheduler management)
  ├─ IOScheduler (Event-driven I/O)
  ├─ ComputeScheduler (CPU-bound tasks)
  └─ TimerScheduler (Global timer)
        ↓
Platform Layer
  ├─ Kqueue (macOS)
  ├─ Epoll (Linux)
  └─ IoUring (Linux, optional)
        ↓
System Calls
```

## 核心模块职责

### Runtime

- 统一管理多个 IOScheduler 和 ComputeScheduler
- 自动创建默认数量的调度器（基于 CPU 核数）
- 提供轮询负载均衡获取调度器
- 自动启动/停止全局 TimerScheduler
- 统一启动/停止所有调度器

### IOScheduler

- 事件驱动的 I/O 调度
- 管理协程队列和事件循环
- 支持多平台后端（kqueue/epoll/io_uring）
- 处理网络 I/O、文件 I/O、定时器事件
- 协程生命周期管理

### ComputeScheduler

- CPU 密集型任务调度
- 基于线程池的任务执行
- 支持协程和普通任务
- 避免阻塞 IOScheduler

### TimerScheduler

- 全局线程安全定时器
- 基于最小堆的高效定时器管理
- 支持 `sleep()` 协程休眠
- 支持 `.timeout()` 超时机制

## 协程模型

### Coroutine 生命周期

```text
创建 -> spawn -> 调度器队列 -> 执行 -> 挂起(co_await) -> 恢复 -> 完成
```

### Promise Type

- 管理协程状态
- 处理返回值和异常
- 支持 `co_await`、`co_return`
- 关联调度器和线程 ID

### Awaitable 机制

所有异步操作都基于 `CustomAwaitable`：

```cpp
template<typename T>
class CustomAwaitable {
    bool await_ready();
    void await_suspend(std::coroutine_handle<>);
    T await_resume();
};
```

支持链式组合：

```text
Connect -> Send -> Recv -> Close
```

## 网络 I/O 架构

### TcpSocket

- 封装 socket 文件描述符
- 提供协程友好的异步接口
- 支持 `connect`、`accept`、`send`、`recv`、`close`
- 支持超时机制
- 自动处理 EAGAIN/EWOULDBLOCK

### UdpSocket

- 无连接的数据报传输
- 支持 `sendto`、`recvfrom`
- 支持广播和多播

### Host

- 封装 IP 地址和端口
- 支持 IPv4 和 IPv6
- 提供地址解析功能

## 文件 I/O 架构

### AsyncFile (kqueue/io_uring)

- 基于平台原生异步文件 I/O
- macOS 使用 kqueue
- Linux 使用 io_uring（需启用）
- 支持 `read`、`write`、`close`

### AioFile (epoll + libaio)

- Linux epoll 后端的文件 I/O
- 基于 libaio 实现异步读写
- 适用于不支持 io_uring 的环境

### FileWatcher

- 文件系统监控
- macOS 使用 kqueue
- Linux 使用 inotify
- 支持监控文件创建、修改、删除

## 并发原语

### MpscChannel

- 多生产者单消费者通道
- 线程安全的消息传递
- 支持协程间通信
- 基于无锁队列实现
- 位于 `galay::kernel` 命名空间

### UnsafeChannel

- 单生产者单消费者通道
- 非线程安全，性能更高
- 适用于单线程协程通信
- 位于 `galay::kernel` 命名空间

### AsyncMutex

- 异步互斥锁
- 支持 `co_await` 获取锁
- 需要手动调用 `unlock()`
- 位于 `galay::kernel` 命名空间

### AsyncWaiter

- 异步等待原语
- 支持跨调度器通信
- 用于 IO 和 Compute 调度器协作
- 位于 `galay::kernel` 命名空间

## 内存管理

### RingBuffer

- 环形缓冲区实现
- 支持 scatter-gather I/O
- 零拷贝数据传输
- 自动扩容和收缩

### Bytes

- 字节序列容器
- 支持零拷贝视图
- 自动内存管理

## 平台抽象

### Kqueue (macOS)

- 高效的事件通知机制
- 支持网络 I/O、文件 I/O、定时器
- 统一的事件接口

### Epoll (Linux)

- 边缘触发和水平触发
- 高并发场景性能优异
- 配合 libaio 实现文件 I/O

### IoUring (Linux)

- 新一代异步 I/O 接口
- 零系统调用开销
- 支持网络和文件 I/O
- 需要较新的内核版本（5.1+）

## 错误处理

### 统一错误模型

所有异步操作返回 `std::expected<T, IOError>`：

```cpp
auto result = co_await socket.recv(buf, len);
if (!result) {
    // 处理错误
    auto& error = result.error();
}
```

### 错误类型

- 连接错误
- 超时错误
- 系统调用错误
- 协议错误

## 性能优化

### 零拷贝

- `sendfile` 系统调用
- RingBuffer 零拷贝视图
- 直接内存映射

### 批量操作

- 批量事件处理
- 批量协程调度
- 减少系统调用次数

### 内存池

- 预分配缓冲区
- 对象池复用
- 减少内存分配开销

### 负载均衡

- 轮询分配调度器
- 避免单个调度器过载
- 充分利用多核 CPU

## 线程模型

### IOScheduler 线程

- 每个 IOScheduler 独占一个线程
- 事件循环运行在该线程
- 协程在该线程上执行

### ComputeScheduler 线程池

- 多个工作线程
- 任务队列分发
- 避免阻塞 I/O 线程

### TimerScheduler 线程

- 独立的定时器线程
- 处理所有定时器事件
- 唤醒挂起的协程

## 扩展性

### 自定义 Awaitable

用户可以实现自定义 Awaitable：

```cpp
class MyAwaitable {
    bool await_ready() { return false; }
    void await_suspend(std::coroutine_handle<> h) {
        // 注册回调
    }
    T await_resume() {
        // 返回结果
    }
};
```

### 自定义调度器

可以继承 `Scheduler` 实现自定义调度逻辑：

```cpp
class MyScheduler : public Scheduler {
    void spawn(Coroutine coro) override;
    void stop() override;
};
```

## 设计原则

### 协程优先

- 所有异步操作都支持 `co_await`
- 统一的协程接口
- 避免回调地狱

### 零成本抽象

- 编译期优化
- 内联函数
- 模板特化

### 平台无关

- 统一的 API 接口
- 平台差异在底层处理
- 用户代码可移植

### 类型安全

- 使用 `std::expected` 而非异常
- 强类型错误处理
- 编译期类型检查

## 典型使用模式

### 单 IOScheduler

```cpp
IOScheduler scheduler;
scheduler.spawn(myCoroutine());
scheduler.loop();
```

### Runtime 多调度器

```cpp
Runtime runtime;
runtime.start();

auto* io = runtime.getNextIOScheduler();
io->spawn(ioTask());

auto* compute = runtime.getNextComputeScheduler();
compute->spawn(cpuTask());

runtime.stop();
```

### IO + Compute 协作

```cpp
Coroutine ioTask(Runtime* rt) {
    AsyncWaiter<int> waiter;

    auto* compute = rt->getNextComputeScheduler();
    compute->spawn(computeJob(&waiter));

    auto result = co_await waiter.wait();
    // 使用计算结果
}
```

## 与其他框架对比

### vs Boost.Asio

- 更现代的 C++23 协程支持
- 更简洁的 API 设计
- 更好的平台集成（io_uring）

### vs libuv

- 原生 C++ 接口
- 协程友好
- 类型安全

### vs Tokio (Rust)

- 类似的异步运行时设计
- C++ 实现
- 更灵活的调度器管理
