# 17-示例代码

本文档提供 Galay-Kernel 的常见使用场景示例。所有示例代码位于 `examples/` 目录。

## 示例目录结构

```text
examples/
├── common/   # 示例共享配置
├── include/  # 传统头文件版本
└── import/   # C++23 模块 import 版本
```

## 构建示例

```bash
# 构建所有 include 版本示例
cmake --build build --target E1-SendfileExample E2-TcpEchoServer E3-TcpClient E4-CoroutineBasic E5-UdpEcho --parallel

# 构建 import 版本（需先启用模块）
cmake .. -DENABLE_CPP23_MODULES=ON -G Ninja
cmake --build build --target E1-SendfileExampleImport E2-TcpEchoServerImport --parallel
```

## 1. 协程基础示例

演示协程的创建、spawn 和等待。

### 简单协程

```cpp
#include "galay-kernel/kernel/Coroutine.h"
#include "galay-kernel/kernel/ComputeScheduler.h"

using namespace galay::kernel;

Coroutine simpleTask(int id) {
    std::cout << "Task " << id << " started\n";

    // 模拟计算工作
    int sum = 0;
    for (int i = 0; i < 1000; ++i) {
        sum += i;
    }

    std::cout << "Task " << id << " completed, sum = " << sum << "\n";
    co_return;
}

int main() {
    ComputeScheduler scheduler;
    scheduler.start();

    scheduler.spawn(simpleTask(1));

    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    scheduler.stop();
    return 0;
}
```

### 父子协程

```cpp
Coroutine childTask(int id) {
    std::cout << "Child task " << id << " running\n";
    co_return;
}

Coroutine parentTask() {
    std::cout << "Parent task started\n";

    // Spawn 多个子协程
    for (int i = 0; i < 3; ++i) {
        co_await spawn(childTask(i));
    }

    std::cout << "All child tasks spawned\n";
    co_return;
}
```

### 协程等待

```cpp
Coroutine waitExample() {
    // 创建协程
    Coroutine task = simpleTask(100);

    // 等待协程完成
    co_await task.wait();

    std::cout << "Task completed\n";
    co_return;
}
```

运行示例：

```bash
./build/bin/E4-CoroutineBasic
```

## 2. TCP Echo 服务器

演示如何创建一个简单的 TCP Echo 服务器。

```cpp
#include "galay-kernel/kernel/Runtime.h"
#include "galay-kernel/async/TcpSocket.h"

using namespace galay::kernel;
using namespace galay::async;

Coroutine handleClient(GHandle handle, IOScheduler* scheduler) {
    TcpSocket client(handle);
    client.option().handleNonBlock();

    char buffer[4096];
    while (true) {
        auto recvResult = co_await client.recv(buffer, sizeof(buffer));
        if (!recvResult || recvResult.value().size() == 0) {
            break;
        }

        auto& bytes = recvResult.value();
        std::cout << "Received: " << bytes.toStringView() << "\n";

        // 回显数据
        co_await client.send(bytes.c_str(), bytes.size());
    }

    co_await client.close();
}

Coroutine server(IOScheduler* scheduler) {
    TcpSocket listener(IPType::IPV4);
    listener.option().handleReuseAddr();
    listener.option().handleNonBlock();

    if (!listener.bind(Host(IPType::IPV4, "0.0.0.0", 8080))) {
        co_return;
    }
    if (!listener.listen(1024)) {
        co_return;
    }

    std::cout << "Server listening on 0.0.0.0:8080\n";

    while (true) {
        Host peer;
        auto acceptResult = co_await listener.accept(&peer);
        if (acceptResult) {
            std::cout << "Client connected: " << peer.ip() << ":" << peer.port() << "\n";
            co_await spawn(handleClient(acceptResult.value(), scheduler));
        }
    }
}

int main() {
    Runtime runtime;
    runtime.start();

    auto* io = runtime.getNextIOScheduler();
    io->spawn(server(io));

    std::cout << "Press Enter to stop...\n";
    std::cin.get();

    runtime.stop();
    return 0;
}
```

运行示例：

```bash
./build/bin/E2-TcpEchoServer

# 在另一个终端测试
telnet 127.0.0.1 8080
```

## 3. TCP 客户端

演示如何创建 TCP 客户端并发送请求。

```cpp
#include "galay-kernel/kernel/Runtime.h"
#include "galay-kernel/async/TcpSocket.h"

using namespace galay::kernel;
using namespace galay::async;

Coroutine client() {
    TcpSocket socket(IPType::IPV4);
    socket.option().handleNonBlock();

    // 连接服务器
    Host server(IPType::IPV4, "127.0.0.1", 8080);
    auto connectResult = co_await socket.connect(server);
    if (!connectResult) {
        std::cerr << "Connect failed: " << connectResult.error().message() << "\n";
        co_return;
    }

    std::cout << "Connected to server\n";

    // 发送数据
    const char* message = "Hello, Server!";
    auto sendResult = co_await socket.send(message, strlen(message));
    if (!sendResult) {
        std::cerr << "Send failed: " << sendResult.error().message() << "\n";
        co_await socket.close();
        co_return;
    }

    // 接收响应
    char buffer[1024];
    auto recvResult = co_await socket.recv(buffer, sizeof(buffer));
    if (!recvResult) {
        std::cerr << "Recv failed: " << recvResult.error().message() << "\n";
        co_await socket.close();
        co_return;
    }

    auto& bytes = recvResult.value();
    std::cout << "Received: " << bytes.toStringView() << "\n";

    co_await socket.close();
}

int main() {
    Runtime runtime;
    runtime.start();

    auto* io = runtime.getNextIOScheduler();
    io->spawn(client());

    std::this_thread::sleep_for(std::chrono::seconds(2));
    runtime.stop();
    return 0;
}
```

运行示例：

```bash
# 先启动服务器
./build/bin/E2-TcpEchoServer

# 在另一个终端运行客户端
./build/bin/E3-TcpClient
```

## 4. UDP Echo 示例

演示 UDP 数据报通信。

```cpp
#include "galay-kernel/kernel/Runtime.h"
#include "galay-kernel/async/UdpSocket.h"

using namespace galay::kernel;
using namespace galay::async;

Coroutine udpServer(IOScheduler* scheduler) {
    UdpSocket socket(IPType::IPV4);
    socket.option().handleNonBlock();

    if (!socket.bind(Host(IPType::IPV4, "0.0.0.0", 9090))) {
        co_return;
    }

    std::cout << "UDP server listening on 0.0.0.0:9090\n";

    char buffer[1024];
    while (true) {
        Host peer;
        auto recvResult = co_await socket.recvfrom(buffer, sizeof(buffer), &peer);
        if (!recvResult) {
            break;
        }

        auto& bytes = recvResult.value();
        std::cout << "Received from " << peer.ip() << ":" << peer.port()
                  << " - " << bytes.toStringView() << "\n";

        // 回显数据
        co_await socket.sendto(bytes.c_str(), bytes.size(), peer);
    }

    co_await socket.close();
}

int main() {
    Runtime runtime;
    runtime.start();

    auto* io = runtime.getNextIOScheduler();
    io->spawn(udpServer(io));

    std::cout << "Press Enter to stop...\n";
    std::cin.get();

    runtime.stop();
    return 0;
}
```

运行示例：

```bash
./build/bin/E5-UdpEcho

# 在另一个终端测试
echo "Hello UDP" | nc -u 127.0.0.1 9090
```

## 5. 文件 I/O 示例

演示异步文件读写。

```cpp
#include "galay-kernel/kernel/Runtime.h"
#include "galay-kernel/async/AsyncFile.h"

using namespace galay::kernel;
using namespace galay::async;

Coroutine fileExample() {
    AsyncFile file;

    // 打开文件（同步操作）
    auto openResult = file.open("test.txt", FileOpenMode::ReadWrite, 0644);
    if (!openResult) {
        std::cerr << "Open failed: " << openResult.error().message() << "\n";
        co_return;
    }

    // 写入数据
    const char* data = "Hello, Async File!\n";
    auto writeResult = co_await file.write(data, strlen(data), 0);
    if (!writeResult) {
        std::cerr << "Write failed: " << writeResult.error().message() << "\n";
        co_await file.close();
        co_return;
    }

    std::cout << "Written " << writeResult.value() << " bytes\n";

    // 读取数据
    char buffer[1024];
    auto readResult = co_await file.read(buffer, sizeof(buffer), 0);
    if (!readResult) {
        std::cerr << "Read failed: " << readResult.error().message() << "\n";
        co_await file.close();
        co_return;
    }

    std::cout << "Read " << readResult.value() << " bytes\n";

    co_await file.close();
}
```

## 6. MpscChannel 示例

演示多生产者单消费者通道。

```cpp
#include "galay-kernel/kernel/Runtime.h"
#include "galay-kernel/concurrency/MpscChannel.h"

using namespace galay::kernel;

Coroutine producer(MpscChannel<int>* channel, int id) {
    for (int i = 0; i < 5; ++i) {
        int value = id * 100 + i;
        channel->send(std::move(value));  // send() 是同步的
        std::cout << "Producer " << id << " sent: " << value << "\n";
    }
}

Coroutine consumer(MpscChannel<int>* channel) {
    for (int i = 0; i < 15; ++i) {
        auto result = co_await channel->recv();
        if (result) {
            std::cout << "Consumer received: " << result.value() << "\n";
        }
    }
}

int main() {
    Runtime runtime;
    runtime.start();

    auto* io = runtime.getNextIOScheduler();

    MpscChannel<int> channel;

    // 启动消费者
    io->spawn(consumer(&channel));

    // 启动多个生产者
    for (int i = 0; i < 3; ++i) {
        io->spawn(producer(&channel, i));
    }

    std::this_thread::sleep_for(std::chrono::seconds(2));
    runtime.stop();
    return 0;
}
```

运行示例：

```bash
./build/bin/E6-MpscChannel
```

## 7. AsyncMutex 示例

演示异步互斥锁。

```cpp
#include "galay-kernel/kernel/Runtime.h"
#include "galay-kernel/concurrency/AsyncMutex.h"

using namespace galay::kernel;

int sharedCounter = 0;

Coroutine worker(AsyncMutex* mutex, int id) {
    for (int i = 0; i < 5; ++i) {
        auto lockResult = co_await mutex->lock();
        if (!lockResult) {
            continue;
        }

        // 临界区
        int oldValue = sharedCounter;
        co_await sleep(std::chrono::milliseconds(10));
        sharedCounter = oldValue + 1;

        std::cout << "Worker " << id << " incremented counter to "
                  << sharedCounter << "\n";

        mutex->unlock();  // 手动解锁
    }
}

int main() {
    Runtime runtime;
    runtime.start();

    auto* io = runtime.getNextIOScheduler();

    AsyncMutex mutex;

    // 启动多个工作协程
    for (int i = 0; i < 3; ++i) {
        io->spawn(worker(&mutex, i));
    }

    std::this_thread::sleep_for(std::chrono::seconds(2));
    runtime.stop();

    std::cout << "Final counter: " << sharedCounter << "\n";
    return 0;
}
```

## 8. Sleep 和 Timeout 示例

演示协程休眠和超时机制。

```cpp
#include "galay-kernel/kernel/Runtime.h"
#include "galay-kernel/common/Sleep.hpp"
#include "galay-kernel/async/TcpSocket.h"

using namespace galay::kernel;
using namespace galay::async;
using namespace std::chrono_literals;

Coroutine sleepExample() {
    std::cout << "Start\n";

    co_await sleep(1s);
    std::cout << "After 1 second\n";

    co_await sleep(2s);
    std::cout << "After 3 seconds\n";
}

Coroutine timeoutExample() {
    TcpSocket socket(IPType::IPV4);
    socket.option().handleNonBlock();

    Host server(IPType::IPV4, "192.0.2.1", 8080);  // 不可达地址

    // 设置 5 秒超时
    auto result = co_await socket.connect(server).timeout(5s);

    if (!result) {
        if (IOError::contains(result.error().code(), kTimeout)) {
            std::cout << "Connection timeout\n";
        } else {
            std::cout << "Connection failed: " << result.error().message() << "\n";
        }
    }

    co_await socket.close();
}

int main() {
    Runtime runtime;
    runtime.start();

    auto* io = runtime.getNextIOScheduler();

    io->spawn(sleepExample());
    io->spawn(timeoutExample());

    std::this_thread::sleep_for(10s);
    runtime.stop();
    return 0;
}
```

运行示例：

```bash
./build/bin/E9-TimerSleep
```

## 9. Sendfile 零拷贝示例

演示零拷贝文件发送。

```cpp
#include "galay-kernel/kernel/Runtime.h"
#include "galay-kernel/async/TcpSocket.h"
#include "galay-kernel/async/Sendfile.h"

using namespace galay::kernel;
using namespace galay::async;

Coroutine fileServer(IOScheduler* scheduler) {
    TcpSocket listener(IPType::IPV4);
    listener.option().handleReuseAddr();
    listener.option().handleNonBlock();

    if (!listener.bind(Host(IPType::IPV4, "0.0.0.0", 8080))) {
        co_return;
    }
    if (!listener.listen(128)) {
        co_return;
    }

    std::cout << "File server listening on 0.0.0.0:8080\n";

    while (true) {
        Host peer;
        auto acceptResult = co_await listener.accept(&peer);
        if (!acceptResult) {
            continue;
        }

        TcpSocket client(acceptResult.value());
        client.option().handleNonBlock();

        // 打开文件
        int fd = open("large_file.bin", O_RDONLY);
        if (fd < 0) {
            co_await client.close();
            continue;
        }

        // 零拷贝发送文件
        auto sendResult = co_await client.sendfile(fd, 0, 1024 * 1024);

        close(fd);
        co_await client.close();

        if (sendResult) {
            std::cout << "Sent " << sendResult.value() << " bytes\n";
        }
    }
}
```

运行示例：

```bash
./build/bin/E1-SendfileExample
```

## 10. Runtime 多调度器示例

演示 IO 和 Compute 调度器协作。

```cpp
#include "galay-kernel/kernel/Runtime.h"
#include "galay-kernel/concurrency/AsyncWaiter.h"

using namespace galay::kernel;

Coroutine computeTask(AsyncWaiter<int>* waiter) {
    // CPU 密集型计算
    int result = 0;
    for (int i = 0; i < 1000000; ++i) {
        result += i;
    }

    // 通知 IO 协程
    waiter->notify(result);
    co_return;
}

Coroutine ioTask(Runtime* runtime) {
    AsyncWaiter<int> waiter;

    // 将计算任务提交到 Compute 调度器
    auto* compute = runtime->getNextComputeScheduler();
    compute->spawn(computeTask(&waiter));

    // 等待计算结果
    auto result = co_await waiter.wait();

    std::cout << "Computation result: " << result.value() << "\n";
}

int main() {
    Runtime runtime;
    runtime.start();

    auto* io = runtime.getNextIOScheduler();
    io->spawn(ioTask(&runtime));

    std::this_thread::sleep_for(std::chrono::seconds(2));
    runtime.stop();
    return 0;
}
```

## 完整示例列表

| 示例 | 文件 | 说明 |
|------|------|------|
| E1 | E1-SendfileExample.cc | 零拷贝文件发送 |
| E2 | E2-TcpEchoServer.cc | TCP Echo 服务器 |
| E3 | E3-TcpClient.cc | TCP 客户端 |
| E4 | E4-CoroutineBasic.cc | 协程基础用法 |
| E5 | E5-UdpEcho.cc | UDP Echo 服务器 |
| E6 | E6-MpscChannel.cc | 多生产者单消费者通道 |
| E7 | E7-UnsafeChannel.cc | 单生产者单消费者通道 |
| E8 | E8-AsyncSync.cc | 异步同步原语 |
| E9 | E9-TimerSleep.cc | 定时器和休眠 |

## 下一步

- 查看 [API 文档](01-API文档.md) 了解完整接口
- 查看 [高级主题](19-高级主题.md) 学习性能优化
- 查看 [常见问题](18-常见问题.md) 解决疑难问题
