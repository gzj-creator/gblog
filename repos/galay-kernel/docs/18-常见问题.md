# 18-常见问题

## 编译相关

### Q: 编译时找不到 spdlog 头文件

**A:** 确保安装了 spdlog，或禁用日志：

```bash
# macOS
brew install spdlog

# Ubuntu/Debian
sudo apt-get install libspdlog-dev

# 或禁用日志
cmake .. -DENABLE_LOG=OFF
```

### Q: 链接时出现 undefined reference 错误

**A:** 检查链接库是否完整：

```cmake
target_link_libraries(your_target PRIVATE
    galay-kernel
    spdlog::spdlog
    pthread
)
```

Linux 下可能还需要：

```cmake
# epoll 后端需要 libaio
target_link_libraries(your_target PRIVATE aio)

# io_uring 后端需要 liburing
target_link_libraries(your_target PRIVATE uring)
```

### Q: 编译时出现 C++23 特性不支持

**A:** 确保编译器支持 C++23：

```bash
# GCC
g++ --version  # 需要 >= 11

# Clang
clang++ --version  # 需要 >= 14
```

在 CMakeLists.txt 中显式指定：

```cmake
set(CMAKE_CXX_STANDARD 23)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
```

### Q: macOS 上编译失败

**A:** 确保使用 Homebrew 的 GCC 或 Clang：

```bash
# 安装 GCC
brew install gcc

# 使用 GCC 编译
cmake .. -DCMAKE_CXX_COMPILER=/opt/homebrew/bin/g++-13

# 或使用 LLVM Clang
brew install llvm
cmake .. -DCMAKE_CXX_COMPILER=/opt/homebrew/opt/llvm/bin/clang++
```

### Q: Linux 上 io_uring 编译失败

**A:** 检查内核版本和 liburing：

```bash
# 检查内核版本（需要 >= 5.1）
uname -r

# 安装 liburing
sudo apt-get install liburing-dev

# 或禁用 io_uring
cmake .. -DDISABLE_IOURING=ON
```

### Q: import 编译失败

**A:** import 编译有严格的工具链要求：

- CMake >= 3.28
- Ninja 或 Visual Studio 生成器
- 不支持 AppleClang

检查工具链版本：

```bash
cmake --version
ninja --version
```

不满足条件时会自动降级到 include 路径。

## 运行时相关

### Q: 运行时错误：Address already in use

**A:** 端口被占用，解决方案：

1. 更换端口
2. 查找并关闭占用进程：

```bash
# Linux
lsof -i :8080
kill -9 <PID>

# macOS
lsof -i :8080
kill -9 <PID>
```

3. 设置 SO_REUSEADDR：

```cpp
listener.option().handleReuseAddr();
```

### Q: 运行时错误：Too many open files

**A:** 文件描述符限制过低，增加限制：

```bash
# 临时增加
ulimit -n 65536

# 永久修改（Linux）
# 编辑 /etc/security/limits.conf
* soft nofile 65536
* hard nofile 65536
```

### Q: 协程没有执行

**A:** 检查以下几点：

1. 调度器是否启动：

```cpp
scheduler.start();
```

2. 协程是否提交：

```cpp
scheduler.spawn(myCoroutine());
```

3. 主线程是否等待：

```cpp
std::this_thread::sleep_for(std::chrono::seconds(1));
```

4. 调度器是否停止过早：

```cpp
// 错误：立即停止
scheduler.start();
scheduler.spawn(myCoroutine());
scheduler.stop();  // 协程还没执行

// 正确：等待协程执行
scheduler.start();
scheduler.spawn(myCoroutine());
std::this_thread::sleep_for(std::chrono::seconds(1));
scheduler.stop();
```

### Q: 程序崩溃或段错误

**A:** 常见原因：

1. 协程生命周期问题：

```cpp
// 错误：局部变量在协程完成前销毁
void foo() {
    IOScheduler scheduler;
    scheduler.start();
    scheduler.spawn(myCoroutine());
    // scheduler 在这里销毁，但协程可能还在运行
}

// 正确：等待协程完成
void foo() {
    IOScheduler scheduler;
    scheduler.start();
    scheduler.spawn(myCoroutine());
    std::this_thread::sleep_for(std::chrono::seconds(1));
    scheduler.stop();
}
```

2. 悬空指针：

```cpp
// 错误：传递局部变量指针
Coroutine task() {
    int value = 42;
    co_await someOperation(&value);  // value 可能在协程挂起时销毁
}

// 正确：使用堆分配或确保生命周期
Coroutine task() {
    auto value = std::make_shared<int>(42);
    co_await someOperation(value.get());
}
```

3. 多线程访问非线程安全对象：

```cpp
// 错误：多个协程并发访问同一个 TcpSocket
TcpSocket socket(IPType::IPV4);
co_await spawn(task1(&socket));
co_await spawn(task2(&socket));  // 冲突！

// 正确：每个协程使用独立的 socket
co_await spawn(task1(createSocket()));
co_await spawn(task2(createSocket()));
```

### Q: 内存泄漏

**A:** 检查以下几点：

1. 协程是否正常完成
2. 资源是否正确释放（socket、文件等）
3. 使用 RAII 管理资源

```cpp
Coroutine task() {
    TcpSocket socket(IPType::IPV4);
    // ...
    co_await socket.close();  // 确保关闭
}
```

使用工具检测：

```bash
# Valgrind
valgrind --leak-check=full ./your_program

# AddressSanitizer
cmake .. -DCMAKE_CXX_FLAGS="-fsanitize=address"
```

## 网络相关

### Q: 连接失败：Connection refused

**A:** 检查以下几点：

1. 服务器是否运行
2. 端口是否正确
3. 防火墙是否允许连接
4. 绑定地址是否正确（0.0.0.0 vs 127.0.0.1）

### Q: 连接超时

**A:** 设置超时参数：

```cpp
using namespace std::chrono_literals;

auto result = co_await socket.connect(host).timeout(5s);
if (!result && IOError::contains(result.error().code(), kTimeout)) {
    std::cout << "Connection timeout\n";
}
```

### Q: 接收数据不完整

**A:** TCP 是流式协议，需要循环接收：

```cpp
std::vector<char> buffer;
size_t totalReceived = 0;
size_t expectedSize = 1024;

while (totalReceived < expectedSize) {
    char temp[4096];
    auto result = co_await socket.recv(temp, sizeof(temp));
    if (!result || result.value().size() == 0) {
        break;
    }
    auto& bytes = result.value();
    buffer.insert(buffer.end(), bytes.begin(), bytes.end());
    totalReceived += bytes.size();
}
```

### Q: 发送大数据失败

**A:** 分块发送：

```cpp
const char* data = ...;
size_t totalSize = ...;
size_t sent = 0;

while (sent < totalSize) {
    size_t chunkSize = std::min(size_t(4096), totalSize - sent);
    auto result = co_await socket.send(data + sent, chunkSize);
    if (!result) {
        break;
    }
    sent += result.value();
}
```

### Q: UDP 数据包丢失

**A:** UDP 不保证可靠传输，解决方案：

1. 应用层实现重传机制
2. 使用 TCP 代替
3. 增加缓冲区大小：

```cpp
socket.option().handleRecvBufSize(1024 * 1024);
socket.option().handleSendBufSize(1024 * 1024);
```

## 协程相关

### Q: co_await 后程序卡住

**A:** 可能原因：

1. 事件未触发（如等待永不到来的数据）
2. 调度器未运行
3. 死锁

添加超时避免无限等待：

```cpp
auto result = co_await operation().timeout(10s);
```

### Q: 协程间如何通信？

**A:** 使用通道或等待原语：

```cpp
// MpscChannel（在 galay::kernel 命名空间）
#include "galay-kernel/concurrency/MpscChannel.h"
MpscChannel<int> channel;
channel.send(42);  // send() 是同步的
auto value = co_await channel.recv();

// AsyncWaiter（在 galay::kernel 命名空间）
#include "galay-kernel/concurrency/AsyncWaiter.h"
AsyncWaiter<int> waiter;
waiter.notify(42);
auto value = co_await waiter.wait();
```

### Q: 如何在协程中执行 CPU 密集型任务？

**A:** 使用 ComputeScheduler：

```cpp
Coroutine ioTask(Runtime* runtime) {
    AsyncWaiter<int> waiter;

    auto* compute = runtime->getNextComputeScheduler();
    compute->spawn(cpuTask(&waiter));

    auto result = co_await waiter.wait();
}
```

### Q: 协程异常如何处理？

**A:** 使用 try-catch：

```cpp
Coroutine task() {
    try {
        auto result = co_await operation();
        if (!result) {
            // 处理错误
        }
    } catch (const std::exception& e) {
        std::cerr << "Exception: " << e.what() << "\n";
    }
}
```

## 文件 I/O 相关

### Q: 文件打开失败

**A:** 检查以下几点：

1. 文件路径是否正确
2. 权限是否足够
3. 文件是否存在（读取时）
4. 目录是否存在（创建时）

```cpp
auto result = file.open("test.txt", FileOpenMode::ReadWrite, 0644);
if (!result) {
    std::cerr << "Open failed: " << result.error().message() << "\n";
    std::cerr << "Error code: " << result.error().code() << "\n";
}
```

### Q: 文件读写性能差

**A:** 优化建议：

1. 增加缓冲区大小
2. 使用 io_uring（Linux）
3. 批量读写
4. 使用 sendfile 零拷贝（适用于文件传输）

### Q: AioFile vs AsyncFile 如何选择？

**A:**

- macOS：只能使用 AsyncFile（基于 kqueue）
- Linux + io_uring：使用 AsyncFile（性能最好）
- Linux + epoll：使用 AioFile（基于 libaio）

```cpp
#if defined(USE_KQUEUE) || defined(USE_IOURING)
AsyncFile file;  // kqueue (macOS) 或 io_uring (Linux)
#else
AioFile file;    // libaio (Linux epoll)
#endif
```

## 性能相关

### Q: 如何提升性能？

**A:** 优化策略：

1. 使用 Release 构建：

```bash
cmake .. -DCMAKE_BUILD_TYPE=Release
```

2. 增加调度器数量：

```cpp
Runtime runtime(8, 4);  // 8个IO + 4个Compute
```

3. 使用零拷贝：

```cpp
co_await socket.sendfile(fd, offset, size);
```

4. 批量操作：

```cpp
// 批量接收连接
for (int i = 0; i < 10; ++i) {
    auto result = co_await listener.accept(&peer);
    if (result) {
        co_await spawn(handleClient(result.value()));
    }
}
```

5. 禁用日志：

```bash
cmake .. -DENABLE_LOG=OFF
```

### Q: 如何测试性能？

**A:** 使用内置基准测试：

```bash
# TCP 服务器
./build/bin/B2-TcpServer 8080

# TCP 客户端压测
./build/bin/B3-TcpClient -h 127.0.0.1 -p 8080 -c 1000 -s 1024 -d 30
```

或使用第三方工具：

```bash
# wrk (HTTP)
wrk -t4 -c100 -d30s http://127.0.0.1:8080

# iperf (TCP)
iperf3 -s  # 服务器
iperf3 -c 127.0.0.1 -t 30  # 客户端
```

### Q: 内存占用过高

**A:** 优化建议：

1. 减少调度器数量
2. 限制并发连接数
3. 及时释放资源
4. 使用对象池

### Q: CPU 占用过高

**A:** 可能原因：

1. 忙等待（busy loop）
2. 调度器数量过多
3. 日志输出过多

解决方案：

```cpp
// 避免忙等待
while (condition) {
    co_await sleep(10ms);  // 而不是空循环
}

// 减少日志
#ifdef ENABLE_LOG
spdlog::set_level(spdlog::level::warn);
#endif
```

## 定时器相关

### Q: sleep() 不工作

**A:** 确保 TimerScheduler 已启动：

```cpp
// 使用 Runtime 会自动启动
Runtime runtime;
runtime.start();

// 手动使用调度器需要显式启动
TimerScheduler::getInstance()->start();
```

### Q: 定时器精度不够

**A:** 定时器基于系统时钟，精度受限于：

1. 操作系统调度
2. 系统负载
3. 定时器分辨率

对于高精度需求，考虑使用硬件定时器或实时系统。

### Q: 大量定时器性能问题

**A:** TimerScheduler 使用最小堆，时间复杂度 O(log n)，支持大量定时器。如果仍有性能问题：

1. 合并相近的定时器
2. 使用时间轮算法（需自行实现）
3. 减少定时器数量

## 调试相关

### Q: 如何启用调试日志？

**A:** 设置 spdlog 日志级别：

```cpp
#include <spdlog/spdlog.h>

int main() {
    spdlog::set_level(spdlog::level::debug);
    // ...
}
```

### Q: 如何调试协程？

**A:** 调试技巧：

1. 添加日志：

```cpp
Coroutine task() {
    LogInfo("Task started");
    auto result = co_await operation();
    LogInfo("Operation completed");
}
```

2. 使用 GDB：

```bash
gdb ./your_program
break myCoroutine
run
```

3. 打印协程状态：

```cpp
Coroutine coro = myCoroutine();
std::cout << "Valid: " << coro.isValid() << "\n";
std::cout << "Done: " << coro.done() << "\n";
```

### Q: 如何分析性能瓶颈？

**A:** 使用性能分析工具：

```bash
# perf (Linux)
perf record -g ./your_program
perf report

# Instruments (macOS)
instruments -t "Time Profiler" ./your_program

# gprof
cmake .. -DCMAKE_CXX_FLAGS="-pg"
./your_program
gprof your_program gmon.out
```

## 平台相关

### Q: macOS 和 Linux 行为不一致

**A:** 平台差异：

1. macOS 使用 kqueue，Linux 使用 epoll/io_uring
2. 文件 I/O 实现不同
3. 系统调用语义差异

尽量使用统一的高层 API，避免直接使用平台特定功能。

### Q: 如何跨平台编译？

**A:** 使用 CMake 工具链文件：

```bash
# Linux -> Windows (MinGW)
cmake .. -DCMAKE_TOOLCHAIN_FILE=mingw-w64.cmake

# macOS -> Linux (交叉编译)
cmake .. -DCMAKE_TOOLCHAIN_FILE=linux-cross.cmake
```

### Q: Windows 支持吗？

**A:** 当前版本不支持 Windows。计划在未来版本中添加 IOCP 支持。

## 其他

### Q: 如何贡献代码？

**A:** 欢迎提交 PR：

1. Fork 仓库
2. 创建特性分支
3. 提交代码并编写测试
4. 发起 Pull Request

### Q: 如何报告 Bug？

**A:** 在 GitHub Issues 中提交，包含：

- 复现步骤
- 预期行为和实际行为
- 环境信息（OS、编译器、CMake 版本）
- 相关日志和错误信息
- 最小可复现示例

### Q: 生产环境可以使用吗？

**A:** 项目处于活跃开发中，建议：

- 充分测试后再用于生产
- 关注 GitHub 更新和 Bug 修复
- 做好错误处理和监控
- 准备降级方案

### Q: 与 Boost.Asio 相比有什么优势？

**A:**

- 更现代的 C++23 协程支持
- 更简洁的 API 设计
- 原生支持 io_uring
- 更好的类型安全（std::expected）
- 内置多调度器管理（Runtime）

### Q: 性能如何？

**A:** 参考 [性能测试](02-性能测试.md) 文档。关键指标：

- TCP Echo: 100K+ QPS（单核）
- UDP Echo: 200K+ QPS（单核）
- 延迟: < 1ms（P99）

### Q: 有商业支持吗？

**A:** 当前为开源项目，暂无商业支持。可通过 GitHub Issues 获取社区支持。
