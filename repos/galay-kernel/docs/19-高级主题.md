# 19-高级主题

本文档涵盖性能优化、最佳实践、高级用法等主题。

## 性能优化

### 1. 选择合适的后端

不同平台和场景选择不同的 I/O 后端：

```bash
# macOS: 自动使用 kqueue（最优）
cmake .. -DCMAKE_BUILD_TYPE=Release

# Linux: 使用 io_uring（最优，需要内核 5.1+）
cmake .. -DCMAKE_BUILD_TYPE=Release -DDISABLE_IOURING=OFF

# Linux: 使用 epoll（兼容性好）
cmake .. -DCMAKE_BUILD_TYPE=Release -DDISABLE_IOURING=ON
```

性能对比（参考值）：

- io_uring: 100%（最快）
- kqueue: 95%
- epoll: 85%

### 2. 调度器数量优化

根据工作负载调整调度器数量：

```cpp
// I/O 密集型：更多 IOScheduler
Runtime runtime(16, 4);  // 16个IO + 4个Compute

// CPU 密集型：更多 ComputeScheduler
Runtime runtime(4, 16);  // 4个IO + 16个Compute

// 混合负载：平衡配置
Runtime runtime(8, 8);   // 8个IO + 8个Compute

// 自动配置（推荐）
Runtime runtime;  // 2*CPU核数 IO + CPU核数 Compute
```

经验法则：

- IOScheduler 数量 = 1.5 ~ 2 × CPU 核数
- ComputeScheduler 数量 = CPU 核数
- 总线程数不超过 CPU 核数的 3 倍

### 3. 零拷贝技术

使用 sendfile 系统调用实现零拷贝文件传输：

```cpp
#include "galay-kernel/async/Sendfile.h"

Coroutine fileTransfer(TcpSocket& socket, const char* filepath) {
    int fd = open(filepath, O_RDONLY);
    if (fd < 0) {
        co_return;
    }

    struct stat st;
    fstat(fd, &st);
    off_t fileSize = st.st_size;

    // 零拷贝发送整个文件
    auto result = co_await socket.sendfile(fd, 0, fileSize);

    close(fd);

    if (result) {
        std::cout << "Sent " << result.value() << " bytes\n";
    }
}
```

性能提升：

- 减少 2 次内存拷贝
- 减少用户态/内核态切换
- 吞吐量提升 2-3 倍

### 4. 批量操作

批量处理可以减少系统调用和上下文切换：

```cpp
// 批量接收连接
Coroutine acceptLoop(TcpSocket& listener, IOScheduler* scheduler) {
    std::vector<Coroutine> clients;

    while (true) {
        // 一次性接收多个连接
        for (int i = 0; i < 10; ++i) {
            Host peer;
            auto result = co_await listener.accept(&peer);
            if (result) {
                clients.push_back(handleClient(result.value()));
            } else {
                break;
            }
        }

        // 批量提交协程
        for (auto& client : clients) {
            scheduler->spawn(std::move(client));
        }
        clients.clear();
    }
}
```

### 5. 内存池和对象池

复用对象减少内存分配开销：

```cpp
template<typename T>
class ObjectPool {
    std::vector<std::unique_ptr<T>> pool;
    std::mutex mutex;

public:
    T* acquire() {
        std::lock_guard lock(mutex);
        if (pool.empty()) {
            return new T();
        }
        auto obj = pool.back().release();
        pool.pop_back();
        return obj;
    }

    void release(T* obj) {
        std::lock_guard lock(mutex);
        pool.emplace_back(obj);
    }
};

// 使用示例
ObjectPool<char[4096]> bufferPool;

Coroutine task() {
    auto* buffer = bufferPool.acquire();
    // 使用 buffer
    bufferPool.release(buffer);
}
```

### 6. RingBuffer 优化

RingBuffer 支持高效的 scatter-gather I/O：

```cpp
#include "galay-kernel/common/RingBuffer.h"

Coroutine efficientRecv(TcpSocket& socket) {
    RingBuffer buffer(16 * 1024);  // 16KB 缓冲区

    while (true) {
        // 直接写入 RingBuffer
        auto result = co_await socket.recv(
            buffer.writeBegin(),
            buffer.writeableSize()
        );

        if (!result || result.value().size() == 0) {
            break;
        }

        buffer.commitWrite(result.value().size());

        // 处理数据
        while (buffer.readableSize() > 0) {
            // 解析协议
            auto data = buffer.readBegin();
            size_t consumed = parseProtocol(data, buffer.readableSize());
            buffer.commitRead(consumed);
        }
    }
}
```

### 7. 禁用日志

生产环境禁用调试日志可显著提升性能：

```bash
cmake .. -DENABLE_LOG=OFF
```

或运行时调整日志级别：

```cpp
#include <spdlog/spdlog.h>

int main() {
    // 只输出错误和警告
    spdlog::set_level(spdlog::level::warn);
}
```

### 8. 编译器优化

使用编译器优化选项：

```bash
# Release 构建
cmake .. -DCMAKE_BUILD_TYPE=Release

# 激进优化
cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS="-O3 -march=native"

# LTO（链接时优化）
cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_INTERPROCEDURAL_OPTIMIZATION=ON
```

## 最佳实践

### 1. 错误处理

始终检查返回值：

```cpp
Coroutine task() {
    TcpSocket socket(IPType::IPV4);

    auto connectResult = co_await socket.connect(host);
    if (!connectResult) {
        LogError("Connect failed: {}", connectResult.error().message());
        co_return;
    }

    auto sendResult = co_await socket.send(data, size);
    if (!sendResult) {
        LogError("Send failed: {}", sendResult.error().message());
        co_await socket.close();
        co_return;
    }

    co_await socket.close();
}
```

### 2. 资源管理

使用 RAII 管理资源：

```cpp
class SocketGuard {
    TcpSocket& socket;
    bool closed = false;

public:
    explicit SocketGuard(TcpSocket& s) : socket(s) {}

    ~SocketGuard() {
        if (!closed) {
            // 注意：析构函数中不能 co_await
            // 需要在外部显式关闭
        }
    }

    Coroutine close() {
        if (!closed) {
            co_await socket.close();
            closed = true;
        }
    }
};

Coroutine task() {
    TcpSocket socket(IPType::IPV4);
    SocketGuard guard(socket);

    // 使用 socket
    // ...

    co_await guard.close();
}
```

### 3. 超时设置

为所有 I/O 操作设置超时：

```cpp
using namespace std::chrono_literals;

Coroutine robustTask() {
    TcpSocket socket(IPType::IPV4);

    // 连接超时
    auto connectResult = co_await socket.connect(host).timeout(5s);
    if (!connectResult) {
        if (IOError::contains(connectResult.error().code(), kTimeout)) {
            LogWarn("Connect timeout");
        }
        co_return;
    }

    // 接收超时
    char buffer[4096];
    auto recvResult = co_await socket.recv(buffer, sizeof(buffer)).timeout(30s);
    if (!recvResult) {
        if (IOError::contains(recvResult.error().code(), kTimeout)) {
            LogWarn("Recv timeout");
        }
        co_await socket.close();
        co_return;
    }

    co_await socket.close();
}
```

### 4. 协程生命周期

确保协程在调度器停止前完成：

```cpp
int main() {
    Runtime runtime;
    runtime.start();

    auto* io = runtime.getNextIOScheduler();

    // 使用 shared_ptr 跟踪协程完成
    auto done = std::make_shared<std::atomic<bool>>(false);

    io->spawn([done]() -> Coroutine {
        // 任务逻辑
        co_await doWork();
        done->store(true);
    }());

    // 等待完成
    while (!done->load()) {
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }

    runtime.stop();
    return 0;
}
```

### 5. 避免阻塞操作

不要在协程中执行阻塞操作：

```cpp
// 错误：阻塞 IOScheduler
Coroutine badTask() {
    std::this_thread::sleep_for(1s);  // 阻塞！
    co_return;
}

// 正确：使用协程休眠
Coroutine goodTask() {
    co_await sleep(1s);  // 不阻塞
    co_return;
}

// 错误：阻塞 I/O
Coroutine badIO() {
    FILE* f = fopen("file.txt", "r");  // 阻塞！
    fread(buffer, 1, size, f);
    fclose(f);
    co_return;
}

// 正确：使用异步文件 I/O
Coroutine goodIO() {
    AsyncFile file;
    auto openResult = file.open("file.txt", FileOpenMode::Read);
    if (openResult) {
        co_await file.read(buffer, size, 0);
        co_await file.close();
    }
}
```

### 6. CPU 密集型任务

将 CPU 密集型任务放到 ComputeScheduler：

```cpp
Coroutine ioTask(Runtime* runtime) {
    // I/O 操作
    auto data = co_await fetchData();

    // CPU 密集型计算
    AsyncWaiter<Result> waiter;
    auto* compute = runtime->getNextComputeScheduler();
    compute->spawn(processData(data, &waiter));

    // 等待计算结果
    auto result = co_await waiter.wait();

    // 继续 I/O 操作
    co_await sendResult(result.value());
}

Coroutine processData(Data data, AsyncWaiter<Result>* waiter) {
    // 执行计算
    Result result = heavyComputation(data);

    // 通知 I/O 协程
    waiter->notify(result);
    co_return;
}
```

## 高级用法

### 1. 自定义 Awaitable

实现自定义异步操作：

```cpp
class TimerAwaitable {
    std::chrono::milliseconds duration;
    std::coroutine_handle<> handle;

public:
    explicit TimerAwaitable(std::chrono::milliseconds d) : duration(d) {}

    bool await_ready() const noexcept {
        return duration.count() == 0;
    }

    void await_suspend(std::coroutine_handle<> h) {
        handle = h;
        // 注册定时器
        TimerScheduler::getInstance()->addTimer(
            duration,
            [this]() { handle.resume(); }
        );
    }

    void await_resume() const noexcept {}
};

Coroutine task() {
    co_await TimerAwaitable(std::chrono::seconds(1));
    std::cout << "1 second elapsed\n";
}
```

### 2. 协程取消

实现协程取消机制：

```cpp
class CancellationToken {
    std::atomic<bool> cancelled{false};

public:
    void cancel() { cancelled.store(true); }
    bool isCancelled() const { return cancelled.load(); }
};

Coroutine cancellableTask(CancellationToken& token) {
    while (!token.isCancelled()) {
        // 执行任务
        co_await doWork();

        // 定期检查取消标志
        if (token.isCancelled()) {
            std::cout << "Task cancelled\n";
            break;
        }
    }
}

int main() {
    Runtime runtime;
    runtime.start();

    CancellationToken token;
    auto* io = runtime.getNextIOScheduler();
    io->spawn(cancellableTask(token));

    // 5 秒后取消
    std::this_thread::sleep_for(std::chrono::seconds(5));
    token.cancel();

    runtime.stop();
    return 0;
}
```

### 3. 协程池

实现协程池复用协程：

```cpp
class CoroutinePool {
    IOScheduler* scheduler;
    std::queue<std::function<Coroutine()>> tasks;
    std::mutex mutex;
    size_t activeWorkers = 0;
    size_t maxWorkers;

public:
    CoroutinePool(IOScheduler* sched, size_t max)
        : scheduler(sched), maxWorkers(max) {}

    void submit(std::function<Coroutine()> task) {
        std::lock_guard lock(mutex);
        tasks.push(std::move(task));
        tryStartWorker();
    }

private:
    void tryStartWorker() {
        if (activeWorkers < maxWorkers && !tasks.empty()) {
            activeWorkers++;
            scheduler->spawn(worker());
        }
    }

    Coroutine worker() {
        while (true) {
            std::function<Coroutine()> task;
            {
                std::lock_guard lock(mutex);
                if (tasks.empty()) {
                    activeWorkers--;
                    co_return;
                }
                task = std::move(tasks.front());
                tasks.pop();
            }

            co_await task();
        }
    }
};
```

### 4. 连接池

实现 TCP 连接池：

```cpp
class ConnectionPool {
    IOScheduler* scheduler;
    std::queue<std::unique_ptr<TcpSocket>> available;
    std::mutex mutex;
    Host serverHost;
    size_t maxConnections;

public:
    ConnectionPool(IOScheduler* sched, Host host, size_t max)
        : scheduler(sched), serverHost(host), maxConnections(max) {}

    Coroutine acquire() {
        {
            std::lock_guard lock(mutex);
            if (!available.empty()) {
                auto conn = std::move(available.front());
                available.pop();
                co_return conn.release();
            }
        }

        // 创建新连接
        auto socket = std::make_unique<TcpSocket>(IPType::IPV4);
        socket->option().handleNonBlock();

        auto result = co_await socket->connect(serverHost);
        if (!result) {
            co_return nullptr;
        }

        co_return socket.release();
    }

    void release(TcpSocket* socket) {
        std::lock_guard lock(mutex);
        if (available.size() < maxConnections) {
            available.emplace(socket);
        } else {
            delete socket;
        }
    }
};
```

### 5. 请求管道化

实现 HTTP 请求管道化：

```cpp
class PipelinedClient {
    TcpSocket socket;
    std::queue<AsyncWaiter<Response>*> pendingResponses;

public:
    Coroutine sendRequest(const Request& req, AsyncWaiter<Response>* waiter) {
        // 发送请求
        auto data = req.serialize();
        co_await socket.send(data.data(), data.size());

        // 加入等待队列
        pendingResponses.push(waiter);
    }

    Coroutine receiveLoop() {
        while (true) {
            // 接收响应
            auto response = co_await receiveResponse();

            // 通知等待者
            if (!pendingResponses.empty()) {
                auto* waiter = pendingResponses.front();
                pendingResponses.pop();
                waiter->notify(response);
            }
        }
    }
};
```

### 6. 负载均衡

实现简单的负载均衡器：

```cpp
class LoadBalancer {
    std::vector<Host> backends;
    std::atomic<size_t> nextIndex{0};

public:
    void addBackend(Host host) {
        backends.push_back(host);
    }

    Host getNext() {
        size_t index = nextIndex.fetch_add(1) % backends.size();
        return backends[index];
    }

    Coroutine handleClient(TcpSocket client) {
        // 选择后端
        Host backend = getNext();

        // 连接后端
        TcpSocket backendSocket(IPType::IPV4);
        backendSocket.option().handleNonBlock();
        auto result = co_await backendSocket.connect(backend);
        if (!result) {
            co_await client.close();
            co_return;
        }

        // 双向转发
        co_await bidirectionalForward(client, backendSocket);

        co_await client.close();
        co_await backendSocket.close();
    }
};
```

## 性能测试

### 1. 基准测试框架

```cpp
class Benchmark {
    std::string name;
    std::chrono::steady_clock::time_point start;
    size_t operations = 0;

public:
    explicit Benchmark(std::string n) : name(std::move(n)) {
        start = std::chrono::steady_clock::now();
    }

    ~Benchmark() {
        auto end = std::chrono::steady_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(
            end - start
        );

        double opsPerSec = operations * 1000.0 / duration.count();
        std::cout << name << ": " << operations << " ops in "
                  << duration.count() << " ms ("
                  << opsPerSec << " ops/sec)\n";
    }

    void recordOp() { operations++; }
};

Coroutine benchmarkTask(Benchmark* bench) {
    for (int i = 0; i < 10000; ++i) {
        co_await doOperation();
        bench->recordOp();
    }
}
```

### 2. 延迟测量

```cpp
class LatencyTracker {
    std::vector<std::chrono::microseconds> latencies;

public:
    void record(std::chrono::microseconds latency) {
        latencies.push_back(latency);
    }

    void report() {
        std::sort(latencies.begin(), latencies.end());

        auto p50 = latencies[latencies.size() * 50 / 100];
        auto p95 = latencies[latencies.size() * 95 / 100];
        auto p99 = latencies[latencies.size() * 99 / 100];

        std::cout << "P50: " << p50.count() << " us\n";
        std::cout << "P95: " << p95.count() << " us\n";
        std::cout << "P99: " << p99.count() << " us\n";
    }
};

Coroutine measureLatency(LatencyTracker* tracker) {
    auto start = std::chrono::steady_clock::now();

    co_await operation();

    auto end = std::chrono::steady_clock::now();
    auto latency = std::chrono::duration_cast<std::chrono::microseconds>(
        end - start
    );

    tracker->record(latency);
}
```

## 故障排查

### 1. 性能分析

使用 perf 分析热点：

```bash
# 记录性能数据
perf record -g ./your_program

# 查看报告
perf report

# 火焰图
perf script | stackcollapse-perf.pl | flamegraph.pl > flame.svg
```

### 2. 内存分析

使用 Valgrind 检测内存问题：

```bash
# 内存泄漏
valgrind --leak-check=full --show-leak-kinds=all ./your_program

# 内存错误
valgrind --tool=memcheck ./your_program
```

### 3. 死锁检测

使用 ThreadSanitizer：

```bash
cmake .. -DCMAKE_CXX_FLAGS="-fsanitize=thread"
./your_program
```

## 参考资源

- [性能测试](02-性能测试.md) - 详细的性能测试结果
- [架构设计](16-架构设计.md) - 内部实现原理
- [API 文档](01-API文档.md) - 完整的 API 参考
- [示例代码](17-示例代码.md) - 实用示例
