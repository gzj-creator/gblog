# 01-架构设计

本文档详细介绍 Galay MCP 的架构设计、核心组件和设计理念。

## 整体架构

Galay MCP 采用分层架构设计，从底层到上层依次为：

```
┌─────────────────────────────────────────────────────────┐
│           应用层 (Application Layer)                     │
│  McpStdioClient/Server  │  McpHttpClient/Server         │
├─────────────────────────────────────────────────────────┤
│           协议层 (Protocol Layer)                        │
│  JSON-RPC 2.0 消息处理  │  MCP 方法路由                 │
├─────────────────────────────────────────────────────────┤
│         编解码层 (Codec Layer)                           │
│  simdjson (解析)  │  JsonWriter (序列化)                │
├─────────────────────────────────────────────────────────┤
│          传输层 (Transport Layer)                        │
│  Stdio (stdin/stdout)  │  HTTP (Galay-HTTP)             │
├─────────────────────────────────────────────────────────┤
│           基础层 (Foundation Layer)                      │
│  Galay-Kernel  │  Galay-Utils                           │
└─────────────────────────────────────────────────────────┘
```

## 核心组件

### 1. 传输层

#### Stdio 传输

- **实现**: 基于标准输入输出流
- **消息格式**: 每行一条 JSON-RPC 消息，以换行符分隔
- **适用场景**: 进程间通信、命令行工具、管道连接
- **特点**: 简单、轻量、易于调试

```cpp
// 消息示例
{"jsonrpc":"2.0","id":1,"method":"tools/call","params":{...}}\n
```

#### HTTP 传输

- **实现**: 基于 Galay-HTTP 框架
- **消息格式**: HTTP POST 请求，Body 为 JSON-RPC 消息
- **适用场景**: 网络服务、微服务架构、远程调用
- **特点**: 标准化、可扩展、支持负载均衡

```http
POST /mcp HTTP/1.1
Content-Type: application/json

{"jsonrpc":"2.0","id":1,"method":"tools/call","params":{...}}
```

### 2. 编解码层

#### JSON 解析 (simdjson)

- **高性能**: 使用 SIMD 指令加速解析
- **零拷贝**: DOM 视图避免不必要的内存分配
- **类型安全**: 提供类型检查和转换

```cpp
// 解析示例
auto doc = JsonDocument::Parse(jsonString);
if (doc) {
    JsonElement root = doc.value().Root();
    JsonObject obj;
    if (JsonHelper::GetObject(root, obj)) {
        auto value = obj["key"];
    }
}
```

#### JSON 序列化 (JsonWriter)

- **流式写入**: 边构建边输出，内存占用小
- **类型安全**: 编译期类型检查
- **高效**: 避免中间字符串拼接

```cpp
// 序列化示例
JsonWriter writer;
writer.StartObject();
writer.Key("result");
writer.Number(42);
writer.EndObject();
std::string json = writer.TakeString();
```

### 3. 协议层

#### JSON-RPC 2.0

遵循 JSON-RPC 2.0 规范，支持：

- **请求 (Request)**: 带 ID 的方法调用，需要响应
- **响应 (Response)**: 对请求的回复，包含结果或错误
- **通知 (Notification)**: 不带 ID 的方法调用，无需响应

```cpp
// 请求结构
struct JsonRpcRequest {
    std::string jsonrpc = "2.0";
    std::optional<int64_t> id;
    std::string method;
    std::optional<JsonString> params;
};

// 响应结构
struct JsonRpcResponse {
    std::string jsonrpc = "2.0";
    int64_t id;
    std::optional<JsonString> result;
    std::optional<JsonString> error;
};
```

#### MCP 方法路由

支持的 MCP 方法：

| 方法 | 说明 | 类型 |
|------|------|------|
| `initialize` | 初始化握手 | Request |
| `notifications/initialized` | 初始化完成通知 | Notification |
| `ping` | 心跳检测 | Request |
| `tools/list` | 获取工具列表 | Request |
| `tools/call` | 调用工具 | Request |
| `resources/list` | 获取资源列表 | Request |
| `resources/read` | 读取资源 | Request |
| `prompts/list` | 获取提示列表 | Request |
| `prompts/get` | 获取提示 | Request |

### 4. 应用层

#### 服务器端

**McpStdioServer**:
- 同步阻塞模型
- 从 stdin 读取请求，向 stdout 写入响应
- 线程安全的工具/资源/提示注册表
- 支持动态添加工具、资源和提示

**McpHttpServer**:
- 异步协程模型
- 基于 Galay-HTTP 的 HTTP 服务器
- 工具处理函数为协程，支持异步操作
- 必须在 `start()` 前完成所有注册

#### 客户端

**McpStdioClient**:
- 同步阻塞模型
- 向 stdout 发送请求，从 stdin 读取响应
- 请求-响应模式，每次调用等待结果
- 线程安全的请求发送

**McpHttpClient**:
- 异步协程模型
- 基于 Galay-HTTP 的 HTTP 客户端
- 所有操作返回协程，需要 `co_await`
- 支持连接复用和并发请求

## 数据结构设计

### 核心数据类型

```cpp
// JSON 字符串类型（原始 JSON）
using JsonString = std::string;

// JSON 元素类型（simdjson DOM 视图）
using JsonElement = simdjson::dom::element;

// JSON 对象类型
using JsonObject = simdjson::dom::object;

// JSON 数组类型
using JsonArray = simdjson::dom::array;
```

### MCP 数据结构

```cpp
// 工具定义
struct Tool {
    std::string name;           // 工具名称
    std::string description;    // 工具描述
    JsonString inputSchema;     // 输入参数的 JSON Schema
};

// 资源定义
struct Resource {
    std::string uri;            // 资源 URI
    std::string name;           // 资源名称
    std::string description;    // 资源描述
    std::string mimeType;       // MIME 类型
};

// 提示定义
struct Prompt {
    std::string name;           // 提示名称
    std::string description;    // 提示描述
    std::vector<PromptArgument> arguments;  // 参数列表
};

// 内容项
struct Content {
    ContentType type;           // 内容类型
    std::string text;           // 文本内容
    std::string data;           // 图片数据（base64）
    std::string mimeType;       // MIME 类型
    std::string uri;            // 资源 URI
};
```

## 错误处理

### std::expected 模式

使用 C++23 的 `std::expected` 进行错误处理，避免异常开销：

```cpp
// 返回值或错误
std::expected<JsonString, McpError> callTool(
    const std::string& toolName,
    const JsonString& arguments
);

// 使用示例
auto result = client.callTool("add", args);
if (result) {
    // 成功：使用 result.value()
    std::cout << result.value() << '\n';
} else {
    // 失败：使用 result.error()
    std::cerr << result.error().message() << '\n';
}
```

### 错误类型

```cpp
class McpError {
public:
    int code() const;                    // 错误码
    const std::string& message() const;  // 错误消息
    const std::string& details() const;  // 详细信息

    // 工厂方法
    static McpError parseError(const std::string& details);
    static McpError invalidRequest(const std::string& details);
    static McpError methodNotFound(const std::string& method);
    static McpError invalidParams(const std::string& details);
    static McpError internalError(const std::string& details);
};
```

### 错误码

遵循 JSON-RPC 2.0 错误码规范：

| 错误码 | 说明 |
|--------|------|
| -32700 | 解析错误 |
| -32600 | 无效请求 |
| -32601 | 方法未找到 |
| -32602 | 无效参数 |
| -32603 | 内部错误 |
| -32000 ~ -32099 | 服务器自定义错误 |

## 并发模型

### Stdio 模式

- **服务器**: 单线程事件循环，顺序处理请求
- **客户端**: 使用互斥锁保护请求发送，支持多线程调用
- **线程安全**: 工具/资源/提示注册表使用读写锁

```cpp
// 服务器主循环
void McpStdioServer::run() {
    while (m_running) {
        auto message = readMessage();  // 阻塞读取
        if (message) {
            handleRequest(*message);    // 处理请求
        }
    }
}
```

### HTTP 模式

- **服务器**: 协程异步模型，每个连接一个协程
- **客户端**: 协程异步模型，支持并发请求
- **线程安全**: 基于 Galay-Kernel 的调度器

```cpp
// 服务器协程处理
kernel::Coroutine McpHttpServer::handleRequest(http::HttpConn& conn) {
    auto body = co_await conn.readBody();
    auto response = processRequest(body);
    co_await conn.writeResponse(response);
}
```

## Schema 构建器

提供链式 API 简化 JSON Schema 构建：

```cpp
auto schema = SchemaBuilder()
    .addString("name", "User name", true)
    .addNumber("age", "User age", false)
    .addEnum("role", "User role", {"admin", "user"}, true)
    .addArray("tags", "User tags", "string", false)
    .build();
```

生成的 Schema：

```json
{
  "type": "object",
  "properties": {
    "name": {
      "type": "string",
      "description": "User name"
    },
    "age": {
      "type": "number",
      "description": "User age"
    },
    "role": {
      "type": "string",
      "description": "User role",
      "enum": ["admin", "user"]
    },
    "tags": {
      "type": "array",
      "description": "User tags",
      "items": {"type": "string"}
    }
  },
  "required": ["name", "role"]
}
```

## 性能优化

### 1. 零拷贝解析

使用 simdjson 的 DOM 视图，避免字符串拷贝：

```cpp
// 不拷贝原始 JSON
JsonElement element = doc.Root();
JsonObject obj;
JsonHelper::GetObject(element, obj);  // 视图，无拷贝
```

### 2. 缓存机制

服务器端缓存工具/资源/提示列表：

```cpp
// 首次调用时构建缓存
const JsonString& McpStdioServer::getToolsListResult() {
    if (m_toolsListCache.empty()) {
        // 构建并缓存
        m_toolsListCache = buildToolsList();
    }
    return m_toolsListCache;
}
```

### 3. 流式序列化

使用 JsonWriter 流式构建 JSON，避免中间字符串：

```cpp
JsonWriter writer;
writer.StartObject();
for (const auto& item : items) {
    writer.Key(item.name);
    writer.String(item.value);
}
writer.EndObject();
return writer.TakeString();  // 一次性获取结果
```

### 4. 协程异步

HTTP 模式使用协程避免线程阻塞：

```cpp
// 异步读取请求体
auto body = co_await conn.readBody();

// 异步处理（可能涉及 I/O）
auto result = co_await processAsync(body);

// 异步发送响应
co_await conn.writeResponse(result);
```

## 扩展性设计

### 1. 自定义传输层

可以实现自定义传输层，只需遵循消息格式：

```cpp
class MyTransport {
public:
    // 读取一条消息
    std::expected<JsonString, McpError> readMessage();

    // 写入一条消息
    std::expected<void, McpError> writeMessage(const JsonString& msg);
};
```

### 2. 自定义工具处理

工具处理函数可以执行任意操作：

```cpp
// Stdio 模式：同步处理
server.addTool("my_tool", "Description", schema,
    [](const JsonElement& args) -> std::expected<JsonString, McpError> {
        // 同步处理逻辑
        return result;
    }
);

// HTTP 模式：异步处理
server.addTool("my_tool", "Description", schema,
    [](const JsonElement& args, std::expected<JsonString, McpError>& result)
    -> kernel::Coroutine {
        // 异步处理逻辑
        auto data = co_await fetchDataAsync();
        result = processData(data);
    }
);
```

### 3. 自定义资源读取

资源读取函数可以从任意来源获取数据：

```cpp
server.addResource("file:///data.txt", "Data file", "text/plain",
    [](const std::string& uri) -> std::expected<std::string, McpError> {
        // 从文件系统、数据库、网络等读取
        return readFromSource(uri);
    }
);
```

## 设计原则

### 1. 类型安全

- 使用强类型而非字符串魔法值
- 编译期类型检查
- `std::expected` 显式错误处理

### 2. 零成本抽象

- 内联小函数
- 避免虚函数开销
- 编译期优化

### 3. 易用性

- 链式 API（SchemaBuilder）
- 合理的默认值
- 清晰的错误消息

### 4. 可扩展性

- 插件式工具注册
- 自定义传输层
- 灵活的处理函数

### 5. 标准兼容

- 遵循 MCP 2024-11-05 规范
- 遵循 JSON-RPC 2.0 规范
- 使用标准 C++23 特性

## 下一步

- [API 参考](02-API参考.md) - 完整的 API 文档
- [使用指南](03-使用指南.md) - 详细的使用说明
- [示例代码](04-示例代码.md) - 实用示例
