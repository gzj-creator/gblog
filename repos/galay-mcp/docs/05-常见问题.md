# 05-常见问题

本文档收集了 Galay MCP 使用过程中的常见问题和解决方案。

## 目录

- [编译问题](#编译问题)
- [连接问题](#连接问题)
- [工具调用问题](#工具调用问题)
- [资源管理问题](#资源管理问题)
- [性能问题](#性能问题)
- [调试问题](#调试问题)
- [协议问题](#协议问题)

## 编译问题

### Q: 编译时提示找不到 simdjson

**问题**:
```
fatal error: simdjson.h: No such file or directory
```

**解决方案**:

1. 安装 simdjson：
```bash
# macOS
brew install simdjson

# Ubuntu/Debian
sudo apt-get install libsimdjson-dev

# 从源码编译
git clone https://github.com/simdjson/simdjson.git
cd simdjson
cmake -S . -B build
cmake --build build
sudo cmake --install build
```

2. 如果已安装但仍找不到，指定路径：
```bash
cmake -DCMAKE_PREFIX_PATH=/path/to/simdjson ..
```

### Q: 编译时提示 C++23 特性不支持

**问题**:
```
error: 'std::expected' has not been declared
```

**解决方案**:

1. 确保使用支持 C++23 的编译器：
   - GCC 13+
   - Clang 16+

2. 检查编译器版本：
```bash
g++ --version
clang++ --version
```

3. 指定编译器：
```bash
cmake -DCMAKE_CXX_COMPILER=g++-13 ..
# 或
cmake -DCMAKE_CXX_COMPILER=clang++-16 ..
```

### Q: C++23 模块编译失败

**问题**:
```
error: module file not found
```

**解决方案**:

1. 确保满足模块编译条件：
   - CMake >= 3.28
   - 使用 Ninja 或 Visual Studio 生成器
   - Clang 需要 `clang-scan-deps`

2. 使用 Ninja：
```bash
cmake -S . -B build -G Ninja -DBUILD_MODULE_EXAMPLES=ON
```

3. 如果不支持模块，使用传统 include：
```cpp
// 不使用 import galay.mcp;
#include "galay-mcp/server/McpStdioServer.h"
#include "galay-mcp/client/McpStdioClient.h"
```

### Q: 找不到 Galay 依赖

**问题**:
```
CMake Error: Could not find a package configuration file provided by "galay-kernel"
```

**解决方案**:

1. 确保已安装 Galay 依赖：
```bash
# 克隆并安装 galay-kernel
git clone https://github.com/gzj-creator/galay-kernel.git
cd galay-kernel
cmake -S . -B build
cmake --build build
sudo cmake --install build

# 同样安装 galay-utils 和 galay-http
```

2. 或指定 Galay 路径：
```bash
cmake -DCMAKE_PREFIX_PATH="/path/to/galay-kernel;/path/to/galay-utils" ..
```

## 连接问题

### Q: Stdio 客户端无法连接到服务器

**问题**:
客户端初始化失败或无响应。

**解决方案**:

1. 确保通过管道正确连接：
```bash
# 正确方式
./server | ./client

# 错误方式（分别运行）
./server
./client
```

2. 检查服务器是否正常启动：
```bash
# 查看服务器日志
./server 2>server.log | ./client
cat server.log
```

3. 验证消息格式：
```bash
# 手动测试
echo '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2024-11-05","clientInfo":{"name":"test","version":"1.0"},"capabilities":{}}}' | ./server
```

### Q: HTTP 客户端连接超时

**问题**:
```
Error: Connection timeout
```

**解决方案**:

1. 确保服务器已启动：
```bash
# 检查服务器是否在运行
netstat -an | grep 8080
# 或
lsof -i :8080
```

2. 检查防火墙设置：
```bash
# macOS
sudo pfctl -d  # 临时禁用防火墙测试

# Linux
sudo ufw status
sudo ufw allow 8080
```

3. 验证 URL 格式：
```cpp
// 正确
client.connect("http://127.0.0.1:8080/mcp");

// 错误
client.connect("127.0.0.1:8080");  // 缺少协议
client.connect("http://127.0.0.1:8080");  // 缺少路径
```

### Q: HTTP 服务器启动失败

**问题**:
```
Error: Address already in use
```

**解决方案**:

1. 检查端口是否被占用：
```bash
lsof -i :8080
```

2. 杀死占用端口的进程：
```bash
kill -9 <PID>
```

3. 使用其他端口：
```cpp
McpHttpServer server("0.0.0.0", 8081);  // 使用 8081
```

## 工具调用问题

### Q: 工具调用返回 "Method not found"

**问题**:
```
Error -32601: Method not found
```

**解决方案**:

1. 确保工具已注册：
```cpp
// 服务器端
server.addTool("my_tool", "Description", schema, handler);
```

2. 检查工具名称拼写：
```cpp
// 客户端
auto result = client.callTool("my_tool", args);  // 名称必须完全匹配
```

3. 列出可用工具：
```cpp
auto tools = client.listTools();
if (tools) {
    for (const auto& tool : *tools) {
        std::cout << tool.name << '\n';
    }
}
```

### Q: 工具调用返回 "Invalid params"

**问题**:
```
Error -32602: Invalid params
```

**解决方案**:

1. 检查参数格式：
```cpp
// 正确
JsonWriter writer;
writer.StartObject();
writer.Key("param1");
writer.String("value1");
writer.EndObject();

// 错误
JsonWriter writer;
writer.String("value1");  // 缺少对象包装
```

2. 验证必需参数：
```cpp
// Schema 定义
auto schema = SchemaBuilder()
    .addString("name", "User name", true)  // required=true
    .build();

// 调用时必须提供
JsonWriter writer;
writer.StartObject();
writer.Key("name");  // 必须包含
writer.String("Alice");
writer.EndObject();
```

3. 检查参数类型：
```cpp
// Schema 要求 number
.addNumber("age", "User age", true)

// 调用时提供正确类型
writer.Key("age");
writer.Number(30);  // 不是 writer.String("30")
```

### Q: 工具处理函数中如何处理可选参数？

**解决方案**:

```cpp
server.addTool("search", "Search", schema,
    [](const JsonElement& args) -> std::expected<JsonString, McpError> {
        JsonObject obj;
        JsonHelper::GetObject(args, obj);

        // 必需参数
        std::string query;
        auto queryVal = obj["query"];
        if (queryVal.error() || !JsonHelper::GetString(queryVal.value(), query)) {
            return std::unexpected(McpError::invalidParams("Missing query"));
        }

        // 可选参数（提供默认值）
        int64_t limit = 10;  // 默认值
        auto limitVal = obj["limit"];
        if (!limitVal.error() && limitVal.is_int64()) {
            limit = limitVal.get_int64().value();
        }

        // 使用参数...
    }
);
```

## 资源管理问题

### Q: 资源读取失败

**问题**:
```
Error: Resource not found
```

**解决方案**:

1. 确保资源已注册：
```cpp
server.addResource("file:///data.txt", "Data", "text/plain", reader);
```

2. 检查 URI 格式：
```cpp
// 正确
"file:///absolute/path/to/file.txt"
"http://example.com/resource"
"custom://resource/id"

// 错误
"file://relative/path"  // 缺少第三个斜杠
"/absolute/path"  // 缺少协议
```

3. 验证资源读取函数：
```cpp
server.addResource("file:///test.txt", "Test", "text/plain",
    [](const std::string& uri) -> std::expected<std::string, McpError> {
        // 添加日志
        std::cerr << "Reading resource: " << uri << '\n';

        // 检查文件是否存在
        std::ifstream file("test.txt");
        if (!file) {
            std::cerr << "File not found\n";
            return std::unexpected(McpError::internalError("File not found"));
        }

        // 读取内容...
    }
);
```

### Q: 如何处理大文件资源？

**解决方案**:

1. 分块读取：
```cpp
server.addResource("file:///large.dat", "Large file", "application/octet-stream",
    [](const std::string& uri) -> std::expected<std::string, McpError> {
        std::ifstream file("large.dat", std::ios::binary);
        if (!file) {
            return std::unexpected(McpError::internalError("File not found"));
        }

        // 检查文件大小
        file.seekg(0, std::ios::end);
        size_t size = file.tellg();
        file.seekg(0, std::ios::beg);

        if (size > 10 * 1024 * 1024) {  // 10MB
            return std::unexpected(McpError::internalError("File too large"));
        }

        // 读取文件
        std::string content(size, '\0');
        file.read(&content[0], size);
        return content;
    }
);
```

2. 使用流式传输（HTTP 模式）：
```cpp
// 在 HTTP 模式下，可以使用分块传输
// 具体实现取决于 Galay-HTTP 的 API
```

## 性能问题

### Q: Stdio 模式性能较低

**解决方案**:

1. 使用缓冲 I/O：
```cpp
// 服务器端已默认使用缓冲
// 客户端可以批量发送请求
```

2. 减少日志输出：
```cpp
// 生产环境禁用调试日志
#ifndef NDEBUG
    std::cerr << "Debug info\n";
#endif
```

3. 考虑使用 HTTP 模式：
```cpp
// HTTP 模式支持并发请求
McpHttpServer server("0.0.0.0", 8080);
```

### Q: HTTP 模式延迟较高

**解决方案**:

1. 启用 HTTP keep-alive：
```cpp
// Galay-HTTP 默认启用
// 确保客户端复用连接
```

2. 使用连接池：
```cpp
// 创建多个客户端实例
std::vector<std::unique_ptr<McpHttpClient>> clients;
for (int i = 0; i < 10; ++i) {
    clients.push_back(std::make_unique<McpHttpClient>(runtime));
}
```

3. 优化工具处理函数：
```cpp
// 避免阻塞操作
server.addTool("fast_tool", "Fast tool", schema,
    [](const JsonElement& args, std::expected<JsonString, McpError>& result)
    -> kernel::Coroutine {
        // 使用异步操作
        auto data = co_await fetchDataAsync();
        result = processData(data);
    }
);
```

### Q: 内存占用过高

**解决方案**:

1. 避免缓存大量数据：
```cpp
// 不好
std::map<std::string, std::string> cache;  // 无限增长

// 好
std::map<std::string, std::string> cache;
if (cache.size() > 1000) {
    cache.clear();  // 定期清理
}
```

2. 使用引用避免拷贝：
```cpp
// 不好
std::string processData(std::string data) {
    // 拷贝参数
}

// 好
std::string processData(const std::string& data) {
    // 引用，无拷贝
}
```

3. 及时释放资源：
```cpp
server.addTool("process", "Process", schema,
    [](const JsonElement& args) -> std::expected<JsonString, McpError> {
        {
            // 使用作用域限制生命周期
            std::vector<char> buffer(1024 * 1024);
            // 处理数据...
        }  // buffer 在此释放

        return result;
    }
);
```

## 调试问题

### Q: 如何查看原始 JSON 消息？

**解决方案**:

1. Stdio 模式：
```bash
# 保存输入输出
./server 2>server.log | tee client_input.log | ./client | tee server_input.log

# 查看日志
cat server.log
cat client_input.log
cat server_input.log
```

2. HTTP 模式：
```bash
# 使用 curl 查看
curl -v -X POST http://127.0.0.1:8080/mcp \
  -H "Content-Type: application/json" \
  -d '{"jsonrpc":"2.0","id":1,"method":"tools/list","params":{}}'

# 使用 tcpdump 抓包
sudo tcpdump -i lo0 -A port 8080
```

3. 代码中添加日志：
```cpp
server.addTool("debug_tool", "Debug", schema,
    [](const JsonElement& args) -> std::expected<JsonString, McpError> {
        // 打印原始 JSON
        std::string rawJson;
        JsonHelper::GetRawJson(args, rawJson);
        std::cerr << "Received args: " << rawJson << '\n';

        // 处理...

        std::cerr << "Returning result: " << result << '\n';
        return result;
    }
);
```

### Q: 如何调试协程代码？

**解决方案**:

1. 使用日志跟踪执行流程：
```cpp
Coroutine myTask() {
    std::cerr << "Task started\n";

    co_await someOperation();
    std::cerr << "After someOperation\n";

    co_await anotherOperation();
    std::cerr << "After anotherOperation\n";

    std::cerr << "Task completed\n";
}
```

2. 使用调试器：
```bash
# GDB
gdb ./my_program
(gdb) break myTask
(gdb) run
(gdb) next

# LLDB
lldb ./my_program
(lldb) breakpoint set --name myTask
(lldb) run
(lldb) next
```

3. 检查协程状态：
```cpp
// 确保协程正确完成
if (!result.has_value()) {
    std::cerr << "Coroutine failed: " << result.error().message() << '\n';
}
```

### Q: 如何测试工具处理函数？

**解决方案**:

```cpp
#include <cassert>

// 定义工具处理函数
auto myHandler = [](const JsonElement& args) -> std::expected<JsonString, McpError> {
    // 实现...
};

// 测试函数
void testMyHandler() {
    // 构建测试参数
    JsonWriter argsWriter;
    argsWriter.StartObject();
    argsWriter.Key("param1");
    argsWriter.String("value1");
    argsWriter.EndObject();

    // 解析参数
    auto argsDoc = JsonDocument::Parse(argsWriter.TakeString());
    assert(argsDoc.has_value());

    // 调用处理函数
    auto result = myHandler(argsDoc.value().Root());

    // 验证结果
    assert(result.has_value());

    // 解析结果
    auto resultDoc = JsonDocument::Parse(result.value());
    assert(resultDoc.has_value());

    JsonObject obj;
    assert(JsonHelper::GetObject(resultDoc.value().Root(), obj));

    // 验证字段
    auto field = obj["expected_field"];
    assert(!field.error());

    std::cout << "Test passed\n";
}

int main() {
    testMyHandler();
    return 0;
}
```

## 协议问题

### Q: 如何处理协议版本不匹配？

**解决方案**:

1. 检查服务器支持的版本：
```cpp
auto init_result = client.initialize("my-client", "1.0.0");
if (init_result) {
    auto info = client.getServerInfo();
    std::cout << "Server protocol version: " << info.version << '\n';
}
```

2. 实现版本协商：
```cpp
// 服务器端
server.setServerInfo("my-server", "1.0.0");

// 客户端检查版本
if (client.getServerInfo().version != "1.0.0") {
    std::cerr << "Version mismatch\n";
}
```

### Q: 如何扩展 MCP 协议？

**解决方案**:

1. 添加自定义方法：
```cpp
// 服务器端处理自定义方法
// 注意：这不是标准 MCP 方法
server.addTool("custom/method", "Custom method", schema, handler);
```

2. 使用工具参数传递自定义数据：
```cpp
auto schema = SchemaBuilder()
    .addString("standard_param", "Standard parameter", true)
    .addObject("custom_data", "Custom data", customSchema, false)
    .build();
```

3. 在响应中添加自定义字段：
```cpp
JsonWriter writer;
writer.StartObject();
writer.Key("result");
writer.String("standard result");
writer.Key("custom_field");  // 自定义字段
writer.String("custom value");
writer.EndObject();
```

### Q: 如何处理超时？

**解决方案**:

1. Stdio 模式（使用定时器）：
```cpp
#include <future>
#include <chrono>

auto future = std::async(std::launch::async, [&]() {
    return client.callTool("slow_tool", args);
});

if (future.wait_for(std::chrono::seconds(5)) == std::future_status::timeout) {
    std::cerr << "Tool call timeout\n";
} else {
    auto result = future.get();
}
```

2. HTTP 模式（设置超时）：
```cpp
// 在 Galay-HTTP 层设置超时
// 具体 API 取决于 Galay-HTTP 的实现
```

## 其他问题

### Q: 如何实现工具的访问控制？

**解决方案**:

```cpp
class AuthManager {
private:
    std::set<std::string> m_authorizedClients;

public:
    bool isAuthorized(const std::string& clientName) {
        return m_authorizedClients.count(clientName) > 0;
    }

    void authorize(const std::string& clientName) {
        m_authorizedClients.insert(clientName);
    }
};

AuthManager authManager;
authManager.authorize("trusted-client");

server.addTool("sensitive_tool", "Sensitive operation", schema,
    [&authManager](const JsonElement& args) -> std::expected<JsonString, McpError> {
        // 检查授权（需要从上下文获取客户端名称）
        // 注意：当前 API 不直接支持，需要扩展
        if (!authManager.isAuthorized("current-client")) {
            return std::unexpected(McpError::custom(-32000, "Unauthorized", ""));
        }

        // 执行操作...
    }
);
```

### Q: 如何实现工具的速率限制？

**解决方案**:

```cpp
#include <chrono>
#include <map>

class RateLimiter {
private:
    std::map<std::string, std::vector<std::chrono::steady_clock::time_point>> m_requests;
    std::mutex m_mutex;
    size_t m_maxRequests = 10;
    std::chrono::seconds m_window{60};

public:
    bool allowRequest(const std::string& clientId) {
        std::lock_guard<std::mutex> lock(m_mutex);

        auto now = std::chrono::steady_clock::now();
        auto& requests = m_requests[clientId];

        // 移除过期请求
        requests.erase(
            std::remove_if(requests.begin(), requests.end(),
                [this, now](const auto& time) {
                    return now - time > m_window;
                }),
            requests.end()
        );

        // 检查限制
        if (requests.size() >= m_maxRequests) {
            return false;
        }

        requests.push_back(now);
        return true;
    }
};

RateLimiter limiter;

server.addTool("rate_limited_tool", "Rate limited", schema,
    [&limiter](const JsonElement& args) -> std::expected<JsonString, McpError> {
        if (!limiter.allowRequest("client-id")) {
            return std::unexpected(McpError::custom(-32000, "Rate limit exceeded", ""));
        }

        // 执行操作...
    }
);
```

## 获取更多帮助

如果以上解决方案无法解决你的问题，可以：

1. 查看 [GitHub Issues](https://github.com/gzj-creator/galay-mcp/issues)
2. 查看 [MCP 规范](https://modelcontextprotocol.io/)
3. 查看 [Galay-Kernel 文档](https://github.com/gzj-creator/galay-kernel)
4. 提交新的 Issue 描述你的问题

## 相关文档

- [快速开始](00-快速开始.md) - 快速上手指南
- [架构设计](01-架构设计.md) - 架构和设计理念
- [API 参考](02-API参考.md) - 完整的 API 文档
- [使用指南](03-使用指南.md) - 详细的使用说明
- [示例代码](04-示例代码.md) - 实用示例
