# 06-示例代码

以下示例默认给出模块化导入版本：支持模块时使用 `import galay.mongo;`，否则按需包含对应头文件。

仓库中的可直接运行示例在 `examples/`：

- include 版本：`examples/include/E1-SyncPing.cc`
- include 版本：`examples/include/E2-AsyncPing.cc`
- include 版本：`examples/include/E3-SyncCrud.cc`
- include 版本：`examples/include/E4-AsyncPipeline.cc`
- include 版本：`examples/include/E5-AsyncCommandCrud.cc`
- import 版本：`examples/import/E1-SyncPing.cc`
- import 版本：`examples/import/E2-AsyncPing.cc`
- import 版本：`examples/import/E3-SyncCrud.cc`
- import 版本：`examples/import/E4-AsyncPipeline.cc`
- import 版本：`examples/import/E5-AsyncCommandCrud.cc`

## 同步 Ping

```cpp
#include "galay-mongo/sync/MongoClient.h"
using namespace galay::mongo;

int main() {
    MongoClient session;

    MongoConfig cfg;
    cfg.host = "127.0.0.1";
    cfg.port = 27017;
    cfg.database = "test";

    auto connected = session.connect(cfg);
    if (!connected) {
        std::cerr << "Connect failed: " << connected.error().message() << '\n';
        return 1;
    }

    auto ping = session.ping(cfg.database);
    if (!ping) {
        std::cerr << "Ping failed: " << ping.error().message() << '\n';
        session.close();
        return 1;
    }

    std::cout << "Mongo ping OK\n";
    session.close();
    return 0;
}
```

## 异步 Ping

```cpp
#include <atomic>
#include <chrono>
#include <iostream>
#include <thread>
#include <galay-kernel/kernel/Runtime.h>

#if defined(__cpp_modules) && __cpp_modules >= 201907L
import galay.mongo;
#else
#include "galay-mongo/async/AsyncMongoClient.h"
#endif

using namespace galay::kernel;
using namespace galay::mongo;

struct State {
    std::atomic<bool> done{false};
};

Coroutine app(IOScheduler* scheduler, State* state, MongoConfig cfg) {
    AsyncMongoClient client(scheduler);

    std::expected<bool, MongoError> conn = co_await client.connect(cfg);
    if (!conn) {
        std::cerr << "connect failed: " << conn.error().message() << '\n';
        state->done.store(true, std::memory_order_release);
        co_return;
    }

    std::expected<MongoReply, MongoError> rsp = co_await client.ping(cfg.database);
    if (!rsp) {
        std::cerr << "ping failed: " << rsp.error().message() << '\n';
        co_await client.close();
        state->done.store(true, std::memory_order_release);
        co_return;
    }

    std::cout << "Async Mongo ping OK\n";
    co_await client.close();
    state->done.store(true, std::memory_order_release);
}

int main() {
    MongoConfig cfg;
    cfg.host = "127.0.0.1";
    cfg.port = 27017;
    cfg.database = "test";

    Runtime runtime;
    runtime.start();

    auto* scheduler = runtime.getNextIOScheduler();
    if (!scheduler) return 1;

    State state;
    scheduler->spawn(app(scheduler, &state, cfg));

    using namespace std::chrono_literals;
    while (!state.done.load(std::memory_order_acquire)) {
        std::this_thread::sleep_for(50ms);
    }

    runtime.stop();
    return 0;
}
```

## 同步 CRUD 操作

```cpp
#include <chrono>
#include <iostream>
#include "galay-mongo/sync/MongoClient.h"

using namespace galay::mongo;

int64_t makeUniqueId() {
    return static_cast<int64_t>(
        std::chrono::duration_cast<std::chrono::microseconds>(
            std::chrono::system_clock::now().time_since_epoch()).count());
}

int main() {
    MongoClient session;

    MongoConfig cfg;
    cfg.host = "127.0.0.1";
    cfg.port = 27017;
    cfg.database = "test";

    auto connected = session.connect(cfg);
    if (!connected) {
        std::cerr << "Connect failed: " << connected.error().message() << '\n';
        return 1;
    }

    const std::string collection = "users";
    const int64_t doc_id = makeUniqueId();

    // 插入文档
    MongoDocument doc;
    doc.append("_id", doc_id);
    doc.append("name", "Alice");
    doc.append("age", int32_t(25));

    auto inserted = session.insertOne(cfg.database, collection, doc);
    if (!inserted) {
        std::cerr << "Insert failed: " << inserted.error().message() << '\n';
        session.close();
        return 1;
    }
    std::cout << "Inserted document with _id: " << doc_id << '\n';

    // 查询文档
    MongoDocument filter;
    filter.append("_id", doc_id);

    auto found = session.findOne(cfg.database, collection, filter);
    if (!found) {
        std::cerr << "Find failed: " << found.error().message() << '\n';
        session.close();
        return 1;
    }
    std::cout << "Found document\n";

    // 更新文档
    MongoDocument set_doc;
    set_doc.append("age", int32_t(26));

    MongoDocument update_doc;
    update_doc.append("$set", std::move(set_doc));

    auto updated = session.updateOne(cfg.database, collection, filter, update_doc);
    if (!updated) {
        std::cerr << "Update failed: " << updated.error().message() << '\n';
        session.close();
        return 1;
    }
    std::cout << "Updated document\n";

    // 删除文档
    auto deleted = session.deleteOne(cfg.database, collection, filter);
    if (!deleted) {
        std::cerr << "Delete failed: " << deleted.error().message() << '\n';
        session.close();
        return 1;
    }
    std::cout << "Deleted document\n";

    session.close();
    std::cout << "Sync CRUD example OK\n";
    return 0;
}
```

## 异步 Pipeline（单连接多 in-flight）

```cpp
#include <atomic>
#include <chrono>
#include <iostream>
#include <thread>
#include <vector>
#include <galay-kernel/kernel/Runtime.h>

#if defined(__cpp_modules) && __cpp_modules >= 201907L
import galay.mongo;
#else
#include "galay-mongo/async/AsyncMongoClient.h"
#endif

using namespace galay::kernel;
using namespace galay::mongo;

struct State {
    std::atomic<bool> done{false};
    std::atomic<bool> ok{true};
};

Coroutine run(IOScheduler* scheduler, State* state, MongoConfig cfg) {
    AsyncMongoClient client(scheduler);

    std::expected<bool, MongoError> conn = co_await client.connect(cfg);
    if (!conn) {
        std::cerr << "connect failed: " << conn.error().message() << '\n';
        state->ok.store(false, std::memory_order_relaxed);
        state->done.store(true, std::memory_order_release);
        co_return;
    }

    // 准备多个命令
    std::vector<MongoDocument> commands;
    commands.reserve(3);

    MongoDocument c1;
    c1.append("ping", int32_t(1));
    commands.push_back(std::move(c1));

    MongoDocument c2;
    c2.append("hello", int32_t(1));
    commands.push_back(std::move(c2));

    MongoDocument c3;
    c3.append("ping", int32_t(1));
    commands.push_back(std::move(c3));

    // 单连接多 in-flight 发送
    std::expected<std::vector<MongoPipelineResponse>, MongoError> result =
        co_await client.pipeline(cfg.database, std::move(commands));

    if (!result) {
        std::cerr << "pipeline failed: " << result.error().message() << '\n';
        state->ok.store(false, std::memory_order_relaxed);
        state->done.store(true, std::memory_order_release);
        co_return;
    }

    // 处理每个响应
    for (const auto& item : *result) {
        if (item.ok()) {
            std::cout << "requestId=" << item.request_id << " ok\n";
        } else {
            std::cerr << "requestId=" << item.request_id
                      << " error=" << item.error->message() << '\n';
            state->ok.store(false, std::memory_order_relaxed);
        }
    }

    co_await client.close();
    state->done.store(true, std::memory_order_release);
}

int main() {
    MongoConfig cfg;
    cfg.host = "127.0.0.1";
    cfg.port = 27017;
    cfg.database = "test";

    Runtime runtime;
    runtime.start();

    auto* scheduler = runtime.getNextIOScheduler();
    if (!scheduler) return 1;

    State state;
    scheduler->spawn(run(scheduler, &state, cfg));

    using namespace std::chrono_literals;
    while (!state.done.load(std::memory_order_acquire)) {
        std::this_thread::sleep_for(50ms);
    }

    runtime.stop();

    if (!state.ok.load(std::memory_order_relaxed)) {
        std::cerr << "Async pipeline failed\n";
        return 1;
    }

    std::cout << "Async pipeline example OK\n";
    return 0;
}
```

## 异步命令式 CRUD

```cpp
#include <atomic>
#include <chrono>
#include <iostream>
#include <thread>
#include <galay-kernel/kernel/Runtime.h>

#if defined(__cpp_modules) && __cpp_modules >= 201907L
import galay.mongo;
#else
#include "galay-mongo/async/AsyncMongoClient.h"
#endif

using namespace galay::kernel;
using namespace galay::mongo;

struct State {
    std::atomic<bool> done{false};
};

Coroutine run(IOScheduler* scheduler, State* state, MongoConfig cfg) {
    AsyncMongoClient client(scheduler);

    std::expected<bool, MongoError> conn = co_await client.connect(cfg);
    if (!conn) {
        std::cerr << "connect failed: " << conn.error().message() << '\n';
        state->done.store(true, std::memory_order_release);
        co_return;
    }

    const std::string collection = "users";
    const int64_t doc_id = std::chrono::duration_cast<std::chrono::microseconds>(
        std::chrono::system_clock::now().time_since_epoch()).count();

    // 插入命令
    MongoDocument insert_cmd;
    insert_cmd.append("insert", collection);

    MongoDocument doc;
    doc.append("_id", doc_id);
    doc.append("name", "Bob");
    doc.append("age", int32_t(30));

    MongoArray docs;
    docs.append(std::move(doc));
    insert_cmd.append("documents", std::move(docs));

    std::expected<MongoReply, MongoError> insert_rsp =
        co_await client.command(cfg.database, std::move(insert_cmd));

    if (!insert_rsp || !insert_rsp->ok()) {
        std::cerr << "insert failed\n";
        co_await client.close();
        state->done.store(true, std::memory_order_release);
        co_return;
    }
    std::cout << "Inserted document\n";

    // 查询命令
    MongoDocument find_cmd;
    find_cmd.append("find", collection);

    MongoDocument filter;
    filter.append("_id", doc_id);
    find_cmd.append("filter", std::move(filter));

    std::expected<MongoReply, MongoError> find_rsp =
        co_await client.command(cfg.database, std::move(find_cmd));

    if (!find_rsp || !find_rsp->ok()) {
        std::cerr << "find failed\n";
        co_await client.close();
        state->done.store(true, std::memory_order_release);
        co_return;
    }
    std::cout << "Found document\n";

    // 删除命令
    MongoDocument delete_cmd;
    delete_cmd.append("delete", collection);

    MongoDocument delete_filter;
    delete_filter.append("_id", doc_id);

    MongoDocument delete_spec;
    delete_spec.append("q", std::move(delete_filter));
    delete_spec.append("limit", int32_t(1));

    MongoArray deletes;
    deletes.append(std::move(delete_spec));
    delete_cmd.append("deletes", std::move(deletes));

    std::expected<MongoReply, MongoError> delete_rsp =
        co_await client.command(cfg.database, std::move(delete_cmd));

    if (!delete_rsp || !delete_rsp->ok()) {
        std::cerr << "delete failed\n";
        co_await client.close();
        state->done.store(true, std::memory_order_release);
        co_return;
    }
    std::cout << "Deleted document\n";

    co_await client.close();
    state->done.store(true, std::memory_order_release);
}

int main() {
    MongoConfig cfg;
    cfg.host = "127.0.0.1";
    cfg.port = 27017;
    cfg.database = "test";

    Runtime runtime;
    runtime.start();

    auto* scheduler = runtime.getNextIOScheduler();
    if (!scheduler) return 1;

    State state;
    scheduler->spawn(run(scheduler, &state, cfg));

    using namespace std::chrono_literals;
    while (!state.done.load(std::memory_order_acquire)) {
        std::this_thread::sleep_for(50ms);
    }

    runtime.stop();
    std::cout << "Async command CRUD example OK\n";
    return 0;
}
```

## 认证示例（SCRAM-SHA-256）

```cpp
#include "galay-mongo/sync/MongoClient.h"
using namespace galay::mongo;

int main() {
    MongoClient session;

    MongoConfig cfg;
    cfg.host = "127.0.0.1";
    cfg.port = 27017;
    cfg.database = "test";
    cfg.username = "admin";
    cfg.password = "password";
    cfg.auth_database = "admin";

    auto connected = session.connect(cfg);
    if (!connected) {
        std::cerr << "Connect failed: " << connected.error().message() << '\n';
        return 1;
    }

    auto ping = session.ping(cfg.database);
    if (!ping) {
        std::cerr << "Ping failed: " << ping.error().message() << '\n';
        session.close();
        return 1;
    }

    std::cout << "Authenticated ping OK\n";
    session.close();
    return 0;
}
```

## 错误处理最佳实践

### 同步错误处理

```cpp
void handleQuerySync() {
    MongoClient session;

    MongoConfig cfg;
    cfg.host = "127.0.0.1";
    cfg.port = 27017;
    cfg.database = "test";

    auto conn = session.connect(cfg);
    if (!conn) {
        auto& err = conn.error();
        switch (err.type()) {
            case MONGO_ERROR_CONNECTION:
                std::cerr << "网络连接失败: " << err.message() << '\n';
                break;
            case MONGO_ERROR_AUTH:
                std::cerr << "认证失败: " << err.message() << '\n';
                break;
            case MONGO_ERROR_TIMEOUT:
                std::cerr << "连接超时: " << err.message() << '\n';
                break;
            default:
                std::cerr << "未知错误: " << err.message() << '\n';
        }
        return;
    }

    MongoDocument cmd;
    cmd.append("ping", int32_t(1));

    auto res = session.command(cfg.database, cmd);
    if (!res) {
        auto& err = res.error();
        if (err.type() == MONGO_ERROR_SERVER) {
            std::cerr << "服务器错误 [" << err.serverCode() << "]: "
                      << err.message() << '\n';
        } else {
            std::cerr << "命令失败: " << err.message() << '\n';
        }
        session.close();
        return;
    }

    session.close();
}
```

### 异步错误处理

```cpp
Coroutine handleQueryAsync(IOScheduler* scheduler) {
    AsyncMongoClient client(scheduler);

    MongoConfig cfg;
    cfg.host = "127.0.0.1";
    cfg.port = 27017;
    cfg.database = "test";

    std::expected<bool, MongoError> conn = co_await client.connect(cfg);
    if (!conn) {
        auto& err = conn.error();
        switch (err.type()) {
            case MONGO_ERROR_CONNECTION:
                std::cerr << "网络连接失败: " << err.message() << '\n';
                break;
            case MONGO_ERROR_AUTH:
                std::cerr << "认证失败: " << err.message() << '\n';
                break;
            case MONGO_ERROR_TIMEOUT:
                std::cerr << "连接超时: " << err.message() << '\n';
                break;
            default:
                std::cerr << "未知错误: " << err.message() << '\n';
        }
        co_return;
    }

    MongoDocument cmd;
    cmd.append("ping", int32_t(1));

    std::expected<MongoReply, MongoError> res =
        co_await client.command(cfg.database, std::move(cmd));

    if (!res) {
        auto& err = res.error();
        if (err.type() == MONGO_ERROR_SERVER) {
            std::cerr << "服务器错误 [" << err.serverCode() << "]: "
                      << err.message() << '\n';
        } else {
            std::cerr << "命令失败: " << err.message() << '\n';
        }
        co_await client.close();
        co_return;
    }

    co_await client.close();
}
```

## 聚合管道示例

```cpp
MongoDocument match_stage;
MongoDocument match_filter;
match_filter.append("age", MongoDocument().append("$gte", int32_t(18)));
match_stage.append("$match", std::move(match_filter));

MongoDocument group_stage;
MongoDocument group_spec;
group_spec.append("_id", "$city");
group_spec.append("count", MongoDocument().append("$sum", int32_t(1)));
group_stage.append("$group", std::move(group_spec));

MongoArray pipeline;
pipeline.append(std::move(match_stage));
pipeline.append(std::move(group_stage));

MongoDocument aggregate_cmd;
aggregate_cmd.append("aggregate", "users");
aggregate_cmd.append("pipeline", std::move(pipeline));
aggregate_cmd.append("cursor", MongoDocument());

auto result = session.command("test", aggregate_cmd);
if (!result || !result->ok()) {
    std::cerr << "Aggregate failed\n";
    return;
}

std::cout << "Aggregation completed\n";
```

## 索引操作示例

```cpp
// 创建索引
MongoDocument index_key;
index_key.append("name", int32_t(1));

MongoDocument index_spec;
index_spec.append("key", std::move(index_key));
index_spec.append("name", "name_1");

MongoArray indexes;
indexes.append(std::move(index_spec));

MongoDocument create_index_cmd;
create_index_cmd.append("createIndexes", "users");
create_index_cmd.append("indexes", std::move(indexes));

auto result = session.command("test", create_index_cmd);
if (!result || !result->ok()) {
    std::cerr << "Create index failed\n";
    return;
}

std::cout << "Index created\n";
```

## 测试程序运行

```bash
# 同步 ping
GALAY_MONGO_HOST=127.0.0.1 \
GALAY_MONGO_PORT=27017 \
GALAY_MONGO_DB=test \
./build/examples/E1-SyncPing-Include

# 异步 ping
GALAY_MONGO_HOST=127.0.0.1 \
GALAY_MONGO_PORT=27017 \
GALAY_MONGO_DB=test \
./build/examples/E2-AsyncPing-Include

# 同步 CRUD
GALAY_MONGO_HOST=127.0.0.1 \
GALAY_MONGO_PORT=27017 \
GALAY_MONGO_DB=test \
./build/examples/E3-SyncCrud-Include

# 异步 Pipeline
GALAY_MONGO_HOST=127.0.0.1 \
GALAY_MONGO_PORT=27017 \
GALAY_MONGO_DB=test \
./build/examples/E4-AsyncPipeline-Include

# 异步命令式 CRUD
GALAY_MONGO_HOST=127.0.0.1 \
GALAY_MONGO_PORT=27017 \
GALAY_MONGO_DB=test \
./build/examples/E5-AsyncCommandCrud-Include
```
