# 07-高级主题

## 性能优化

### 1. 异步 Pipeline 优化

使用 pipeline 可以在单连接上并发发送多个命令，减少网络往返：

```cpp
// 低效：串行发送
for (int i = 0; i < 10; ++i) {
    auto res = co_await client.ping("test");
}

// 高效：pipeline 批量发送
std::vector<MongoDocument> commands;
for (int i = 0; i < 10; ++i) {
    MongoDocument cmd;
    cmd.append("ping", int32_t(1));
    commands.push_back(std::move(cmd));
}
auto results = co_await client.pipeline("test", std::move(commands));
```

### 2. 缓冲区配置

调整异步客户端的缓冲区大小：

```cpp
AsyncMongoConfig cfg;
cfg.buffer_size = 32768;  // 增加到 32KB，适合大文档场景
cfg.pipeline_reserve_per_command = 128;  // 每条命令预留更多空间

AsyncMongoClient client(scheduler, cfg);
```

### 3. 批量操作

使用批量插入、更新、删除命令：

```cpp
// 批量插入
MongoDocument insert_cmd;
insert_cmd.append("insert", "users");

MongoArray docs;
for (const auto& user : users) {
    MongoDocument doc;
    doc.append("name", user.name);
    doc.append("age", int32_t(user.age));
    docs.append(std::move(doc));
}
insert_cmd.append("documents", std::move(docs));

auto result = co_await client.command("test", std::move(insert_cmd));
```

### 4. 索引优化

为常用查询字段创建索引：

```cpp
MongoDocument index_key;
index_key.append("email", int32_t(1));  // 升序索引

MongoDocument index_spec;
index_spec.append("key", std::move(index_key));
index_spec.append("name", "email_1");
index_spec.append("unique", true);  // 唯一索引

MongoArray indexes;
indexes.append(std::move(index_spec));

MongoDocument create_index_cmd;
create_index_cmd.append("createIndexes", "users");
create_index_cmd.append("indexes", std::move(indexes));

session.command("test", create_index_cmd);
```

### 5. 投影优化

只查询需要的字段：

```cpp
MongoDocument filter;
filter.append("age", MongoDocument().append("$gte", int32_t(18)));

MongoDocument projection;
projection.append("name", int32_t(1));
projection.append("email", int32_t(1));
projection.append("_id", int32_t(0));  // 排除 _id

auto result = session.findOne("test", "users", filter, projection);
```

## 超时策略

### 连接超时

通过 `MongoConfig::connect_timeout_ms` 设置：

```cpp
MongoConfig cfg;
cfg.connect_timeout_ms = 5000;  // 5 秒连接超时
```

### 发送/接收超时

通过 `AsyncMongoConfig` 设置：

```cpp
// 仅接收超时（常用于长查询）
AsyncMongoConfig cfg;
cfg.recv_timeout = std::chrono::seconds(30);
AsyncMongoClient client(scheduler, cfg);

// 发送和接收超时
AsyncMongoConfig cfg = AsyncMongoConfig::withTimeout(
    std::chrono::seconds(5),   // 发送超时
    std::chrono::seconds(30)   // 接收超时
);
AsyncMongoClient client(scheduler, cfg);

// 无超时（默认）
AsyncMongoConfig cfg = AsyncMongoConfig::noTimeout();
AsyncMongoClient client(scheduler, cfg);
```

### 超时处理

```cpp
auto res = co_await client.command("test", cmd);
if (!res) {
    if (res.error().type() == MONGO_ERROR_TIMEOUT) {
        std::cerr << "命令超时，考虑优化查询或增加超时时间\n";
    }
    co_return;
}
```

## 认证管理

### SCRAM-SHA-256 认证

同步和异步客户端都支持 SCRAM-SHA-256：

```cpp
MongoConfig cfg;
cfg.host = "127.0.0.1";
cfg.port = 27017;
cfg.database = "test";
cfg.username = "admin";
cfg.password = "password";
cfg.auth_database = "admin";  // 认证数据库

// 同步
MongoClient session;
auto conn = session.connect(cfg);

// 异步
AsyncMongoClient client(scheduler);
auto conn = co_await client.connect(cfg);
```

### 认证错误处理

```cpp
auto conn = session.connect(cfg);
if (!conn) {
    if (conn.error().type() == MONGO_ERROR_AUTH) {
        std::cerr << "认证失败: " << conn.error().message() << '\n';
        // 检查用户名、密码、认证数据库是否正确
    }
}
```

## 聚合管道

### 基本聚合

```cpp
// $match 阶段
MongoDocument match_stage;
MongoDocument match_filter;
match_filter.append("status", "active");
match_stage.append("$match", std::move(match_filter));

// $group 阶段
MongoDocument group_stage;
MongoDocument group_spec;
group_spec.append("_id", "$category");
group_spec.append("total", MongoDocument().append("$sum", int32_t(1)));
group_spec.append("avgPrice", MongoDocument().append("$avg", "$price"));
group_stage.append("$group", std::move(group_spec));

// $sort 阶段
MongoDocument sort_stage;
MongoDocument sort_spec;
sort_spec.append("total", int32_t(-1));  // 降序
sort_stage.append("$sort", std::move(sort_spec));

// 构建 pipeline
MongoArray pipeline;
pipeline.append(std::move(match_stage));
pipeline.append(std::move(group_stage));
pipeline.append(std::move(sort_stage));

// 执行聚合
MongoDocument aggregate_cmd;
aggregate_cmd.append("aggregate", "products");
aggregate_cmd.append("pipeline", std::move(pipeline));
aggregate_cmd.append("cursor", MongoDocument());

auto result = session.command("test", aggregate_cmd);
```

### 聚合操作符

常用聚合操作符：

- `$match`：过滤文档
- `$group`：分组聚合
- `$sort`：排序
- `$limit`：限制结果数量
- `$skip`：跳过指定数量
- `$project`：投影字段
- `$unwind`：展开数组
- `$lookup`：关联查询

### 聚合表达式

```cpp
// $sum
MongoDocument sum_expr;
sum_expr.append("$sum", int32_t(1));

// $avg
MongoDocument avg_expr;
avg_expr.append("$avg", "$price");

// $max / $min
MongoDocument max_expr;
max_expr.append("$max", "$score");

// $push（收集到数组）
MongoDocument push_expr;
push_expr.append("$push", "$name");
```

## 索引管理

### 创建索引

```cpp
// 单字段索引
MongoDocument index_key;
index_key.append("email", int32_t(1));  // 1=升序, -1=降序

MongoDocument index_spec;
index_spec.append("key", std::move(index_key));
index_spec.append("name", "email_1");
index_spec.append("unique", true);  // 唯一索引

MongoArray indexes;
indexes.append(std::move(index_spec));

MongoDocument create_index_cmd;
create_index_cmd.append("createIndexes", "users");
create_index_cmd.append("indexes", std::move(indexes));

session.command("test", create_index_cmd);
```

### 复合索引

```cpp
MongoDocument compound_key;
compound_key.append("category", int32_t(1));
compound_key.append("price", int32_t(-1));

MongoDocument index_spec;
index_spec.append("key", std::move(compound_key));
index_spec.append("name", "category_1_price_-1");

MongoArray indexes;
indexes.append(std::move(index_spec));

MongoDocument create_index_cmd;
create_index_cmd.append("createIndexes", "products");
create_index_cmd.append("indexes", std::move(indexes));

session.command("test", create_index_cmd);
```

### 查看索引

```cpp
MongoDocument list_indexes_cmd;
list_indexes_cmd.append("listIndexes", "users");

auto result = session.command("test", list_indexes_cmd);
```

### 删除索引

```cpp
MongoDocument drop_index_cmd;
drop_index_cmd.append("dropIndexes", "users");
drop_index_cmd.append("index", "email_1");  // 索引名称

session.command("test", drop_index_cmd);
```

## 事务支持

MongoDB 4.0+ 支持多文档事务（需要副本集或分片集群）：

```cpp
// 开始会话
MongoDocument start_session_cmd;
start_session_cmd.append("startSession", int32_t(1));
auto session_result = client.command("admin", start_session_cmd);

// 开始事务
MongoDocument start_tx_cmd;
start_tx_cmd.append("startTransaction", int32_t(1));
// ... 添加 session id

// 执行操作
// ...

// 提交事务
MongoDocument commit_cmd;
commit_cmd.append("commitTransaction", int32_t(1));
// ... 添加 session id

// 或回滚
MongoDocument abort_cmd;
abort_cmd.append("abortTransaction", int32_t(1));
// ... 添加 session id
```

注意：当前版本的事务支持需要手动管理会话 ID，未来版本会提供更高级的封装。

## 字段类型处理

### BSON 类型映射

galay-mongo 支持的 BSON 类型：

| BSON 类型 | C++ 类型 | 说明 |
|---|---|---|
| Null | `MongoValue::Null` | 空值 |
| Bool | `bool` | 布尔值 |
| Int32 | `int32_t` | 32 位整数 |
| Int64 | `int64_t` | 64 位整数 |
| Double | `double` | 浮点数 |
| String | `std::string` | 字符串 |
| Binary | `std::vector<uint8_t>` | 二进制数据 |
| Document | `MongoDocument` | 嵌套文档 |
| Array | `MongoArray` | 数组 |
| ObjectId | `Binary` (12 字节) | 对象 ID |
| DateTime | `int64_t` | 日期时间（毫秒时间戳） |
| Timestamp | `int64_t` | 时间戳 |

### 构建文档

```cpp
MongoDocument doc;

// 基本类型
doc.append("null_field", MongoValue::Null());
doc.append("bool_field", true);
doc.append("int32_field", int32_t(42));
doc.append("int64_field", int64_t(1234567890));
doc.append("double_field", 3.14);
doc.append("string_field", "hello");

// 二进制数据
std::vector<uint8_t> binary_data = {0x01, 0x02, 0x03};
doc.append("binary_field", binary_data);

// 嵌套文档
MongoDocument nested;
nested.append("key", "value");
doc.append("nested_field", std::move(nested));

// 数组
MongoArray arr;
arr.append(int32_t(1));
arr.append(int32_t(2));
arr.append(int32_t(3));
doc.append("array_field", std::move(arr));
```

### 读取文档

```cpp
const MongoValue* value = doc.find("string_field");
if (value && value->isString()) {
    std::string str = value->toString();
}

// 或使用 at（会抛出异常如果不存在）
try {
    const MongoValue& val = doc.at("int32_field");
    if (val.isInt32()) {
        int32_t num = val.toInt32();
    }
} catch (const std::out_of_range&) {
    std::cerr << "Field not found\n";
}
```

## 连接状态管理

### 检查连接状态

```cpp
// 同步客户端
if (!session.isConnected()) {
    std::cerr << "连接已断开\n";
}

// 异步客户端
if (client.isClosed()) {
    std::cerr << "连接已关闭\n";
}
```

### Ping 保活

```cpp
// 定期 ping 保持连接活跃
auto ping = co_await client.ping("test");
if (!ping) {
    std::cerr << "Ping 失败，连接可能已断开\n";
}
```

## 错误恢复策略

### 连接重试

```cpp
Coroutine connectWithRetry(IOScheduler* scheduler,
                           AsyncMongoClient& client,
                           const MongoConfig& config,
                           int max_retries = 3) {
    for (int i = 0; i < max_retries; ++i) {
        auto conn = co_await client.connect(config);
        if (conn) {
            std::cout << "连接成功\n";
            co_return;
        }

        if (i < max_retries - 1) {
            std::cerr << "连接失败，" << (i + 1) << " 秒后重试...\n";
            co_await galay::kernel::sleep(std::chrono::seconds(i + 1));
        } else {
            std::cerr << "连接失败，已达最大重试次数\n";
        }
    }
}
```

### 命令重试

```cpp
Coroutine executeWithRetry(AsyncMongoClient& client,
                           const std::string& database,
                           MongoDocument command,
                           int max_retries = 3) {
    for (int i = 0; i < max_retries; ++i) {
        auto res = co_await client.command(database, command);
        if (res && res->ok()) {
            co_return;
        }

        if (i < max_retries - 1) {
            std::cerr << "命令失败，重试中...\n";
        } else {
            std::cerr << "命令失败，已达最大重试次数\n";
        }
    }
}
```

## 安全性

### 防止注入攻击

MongoDB 使用 BSON 协议，不存在传统的 SQL 注入问题，但仍需注意：

```cpp
// 安全：使用结构化查询
MongoDocument filter;
filter.append("username", user_input);  // 自动转义

// 危险：使用 $where 操作符
MongoDocument dangerous_filter;
dangerous_filter.append("$where", "this.username == '" + user_input + "'");
// 不要这样做！
```

### 密码安全

不要在代码中硬编码密码：

```cpp
// 从环境变量读取
const char* password = std::getenv("MONGO_PASSWORD");
if (!password) {
    std::cerr << "未设置 MONGO_PASSWORD 环境变量\n";
    return;
}

MongoConfig cfg;
cfg.password = password;
```

### 连接加密

当前版本暂不支持 TLS/SSL 连接，计划在未来版本中添加。

## 日志管理

### 设置日志级别

```cpp
// 异步客户端支持自定义 logger
auto logger = spdlog::stdout_color_mt("mongo_client");
logger->set_level(spdlog::level::debug);

AsyncMongoClient client(scheduler);
client.setLogger(logger);
```

### 全局日志配置

```cpp
#include <spdlog/spdlog.h>

int main() {
    // 设置全局日志级别
    spdlog::set_level(spdlog::level::info);

    // 设置日志格式
    spdlog::set_pattern("[%Y-%m-%d %H:%M:%S.%e] [%^%l%$] %v");

    // ...
}
```

## 调试技巧

### 打印 BSON 文档

```cpp
void printDocument(const MongoDocument& doc) {
    for (const auto& [key, value] : doc.fields()) {
        std::cout << key << ": ";
        if (value.isString()) {
            std::cout << value.toString();
        } else if (value.isInt32()) {
            std::cout << value.toInt32();
        } else if (value.isInt64()) {
            std::cout << value.toInt64();
        } else if (value.isDouble()) {
            std::cout << value.toDouble();
        } else if (value.isBool()) {
            std::cout << (value.toBool() ? "true" : "false");
        } else if (value.isNull()) {
            std::cout << "null";
        }
        std::cout << '\n';
    }
}
```

### 性能分析

```cpp
auto start = std::chrono::steady_clock::now();

// 执行操作
auto res = co_await client.command("test", cmd);

auto end = std::chrono::steady_clock::now();
auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
std::cout << "命令耗时: " << duration.count() << " ms\n";
```

### 网络抓包

使用 tcpdump 或 Wireshark 分析 MongoDB 协议：

```bash
# 抓取 MongoDB 流量
sudo tcpdump -i any -s 0 -w mongo.pcap port 27017

# 使用 Wireshark 打开 mongo.pcap 分析
```

## 常见陷阱

### 1. 忘记检查错误

```cpp
// 错误：不检查返回值
auto res = co_await client.command("test", cmd);
const auto& reply = res.value();  // 可能崩溃！

// 正确：检查错误
auto res = co_await client.command("test", cmd);
if (!res || !res->ok()) {
    std::cerr << "命令失败\n";
    co_return;
}
const auto& reply = res.value();
```

### 2. 文档移动后使用

```cpp
// 错误：移动后继续使用
MongoDocument doc;
doc.append("key", "value");
client.command("test", std::move(doc));
doc.append("key2", "value2");  // 未定义行为！

// 正确：不要在移动后使用
MongoDocument doc;
doc.append("key", "value");
auto res = co_await client.command("test", std::move(doc));
// doc 已失效，不要再使用
```

### 3. 超时设置过短

```cpp
// 错误：超时过短导致正常查询失败
AsyncMongoConfig cfg;
cfg.recv_timeout = std::chrono::milliseconds(100);  // 太短！

// 正确：根据实际查询时间设置合理超时
AsyncMongoConfig cfg;
cfg.recv_timeout = std::chrono::seconds(30);
```

### 4. 并发使用同一个客户端

```cpp
// 错误：并发使用同一个客户端实例
AsyncMongoClient client(scheduler);
scheduler->spawn(query1(client));
scheduler->spawn(query2(client));  // 冲突！

// 正确：每个协程使用独立客户端
scheduler->spawn(query1(scheduler));  // 内部创建新客户端
scheduler->spawn(query2(scheduler));  // 内部创建新客户端
```

## 与其他库集成

### 与 JSON 库集成

```cpp
#include <nlohmann/json.hpp>

nlohmann::json documentToJson(const MongoDocument& doc) {
    nlohmann::json result;

    for (const auto& [key, value] : doc.fields()) {
        if (value.isNull()) {
            result[key] = nullptr;
        } else if (value.isBool()) {
            result[key] = value.getBool();
        } else if (value.isInt32()) {
            result[key] = value.getInt32();
        } else if (value.isInt64()) {
            result[key] = value.getInt64();
        } else if (value.isDouble()) {
            result[key] = value.getDouble();
        } else if (value.isString()) {
            result[key] = value.getString();
        }
    }

    return result;
}
```

### 与 HTTP 服务器集成

```cpp
// 使用 galay-http
#include <galay-http/server/HttpServer.h>

Coroutine handleRequest(HttpRequest& req, HttpResponse& resp,
                        AsyncMongoClient& client) {
    MongoDocument filter;
    filter.append("id", req.getParam("id"));

    auto result = co_await client.command("test",
        MongoDocument().append("find", "users").append("filter", std::move(filter)));

    if (result && result->ok()) {
        nlohmann::json json = documentToJson(result.value());
        resp.setBody(json.dump());
        resp.setHeader("Content-Type", "application/json");
    } else {
        resp.setStatus(500);
        resp.setBody("Database error");
    }
}
```

## 迁移指南

### 从 MongoDB C Driver 迁移

```cpp
// MongoDB C Driver
mongoc_client_t* client = mongoc_client_new("mongodb://localhost:27017");
mongoc_collection_t* collection = mongoc_client_get_collection(client, "test", "users");
bson_t* query = BCON_NEW("name", BCON_UTF8("Alice"));
mongoc_cursor_t* cursor = mongoc_collection_find_with_opts(collection, query, NULL, NULL);
// ...
bson_destroy(query);
mongoc_cursor_destroy(cursor);
mongoc_collection_destroy(collection);
mongoc_client_destroy(client);

// galay-mongo 同步版本
MongoClient session;
session.connect("localhost", 27017, "test");
MongoDocument filter;
filter.append("name", "Alice");
auto result = session.findOne("test", "users", filter);
session.close();
```

### 从 MongoDB C++ Driver 迁移

```cpp
// MongoDB C++ Driver
mongocxx::client client{mongocxx::uri{"mongodb://localhost:27017"}};
auto collection = client["test"]["users"];
auto result = collection.find_one(document{} << "name" << "Alice" << finalize);

// galay-mongo 同步版本
MongoClient session;
session.connect("localhost", 27017, "test");
MongoDocument filter;
filter.append("name", "Alice");
auto result = session.findOne("test", "users", filter);
session.close();
```
