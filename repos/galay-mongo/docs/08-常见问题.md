# 08-常见问题

## 编译相关

### Q: 编译时找不到 galay-kernel 头文件

**A:** 确保 CMake 能找到依赖库，使用 `CMAKE_PREFIX_PATH` 指定：

```bash
cmake -S . -B build \
  -DCMAKE_PREFIX_PATH="/path/to/galay-kernel;/path/to/galay-utils"
```

或者设置环境变量：

```bash
export CMAKE_PREFIX_PATH="/path/to/galay-kernel:/path/to/galay-utils"
cmake -S . -B build
```

### Q: 链接时出现 undefined reference 错误

**A:** 检查链接库是否完整：

```cmake
target_link_libraries(your_target PRIVATE
    galay-mongo
    galay-kernel
    OpenSSL::SSL
    OpenSSL::Crypto
    spdlog::spdlog
)
```

### Q: import 编译失败

**A:** import 编译有严格的工具链要求：

- Linux 系统
- CMake >= 3.28
- Ninja 或 Visual Studio 生成器
- GCC >= 14

不满足条件时会自动降级到 include 路径。检查工具链版本：

```bash
cmake --version
g++ --version
ninja --version
```

### Q: 编译时出现 C++23 特性不支持

**A:** 确保编译器支持 C++23：

```bash
# GCC
g++ --version  # 需要 >= 13

# Clang
clang++ --version  # 需要 >= 16
```

在 CMakeLists.txt 中显式指定：

```cmake
set(CMAKE_CXX_STANDARD 23)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
```

## 连接相关

### Q: 连接失败：Connection refused

**A:** 检查以下几点：

1. MongoDB 服务是否运行：
   ```bash
   systemctl status mongod
   # 或
   ps aux | grep mongod
   ```

2. 端口是否正确（默认 27017）：
   ```bash
   netstat -tlnp | grep 27017
   ```

3. 防火墙是否允许连接：
   ```bash
   sudo ufw allow 27017
   ```

4. MongoDB 是否允许远程连接（检查 bindIp）：
   ```bash
   # /etc/mongod.conf
   net:
     bindIp: 0.0.0.0  # 允许所有 IP
   ```

### Q: 连接失败：Authentication failed

**A:** 检查认证配置：

```cpp
MongoConfig cfg;
cfg.username = "admin";
cfg.password = "password";
cfg.auth_database = "admin";  // 通常是 admin
```

确认：
- 用户名和密码是否正确
- `auth_database` 是否正确（通常是 `admin`）
- MongoDB 是否启用了认证

查看 MongoDB 用户：

```javascript
use admin
db.getUsers()
```

创建用户：

```javascript
use admin
db.createUser({
  user: "admin",
  pwd: "password",
  roles: [{role: "root", db: "admin"}]
})
```

### Q: 连接超时

**A:** 调整超时参数：

```cpp
MongoConfig cfg;
cfg.connect_timeout_ms = 10000;  // 增加到 10 秒

// 异步客户端还可以设置发送/接收超时
AsyncMongoConfig async_cfg;
async_cfg.send_timeout = std::chrono::seconds(5);
async_cfg.recv_timeout = std::chrono::seconds(30);
AsyncMongoClient client(scheduler, async_cfg);
```

### Q: 连接一段时间后断开

**A:** MongoDB 有连接超时配置。解决方案：

1. 定期 ping 保活：
   ```cpp
   co_await client.ping("test");
   ```

2. 检测连接状态并重连：
   ```cpp
   if (client.isClosed()) {
       co_await client.connect(cfg);
   }
   ```

3. 调整 MongoDB 服务器配置：
   ```yaml
   # /etc/mongod.conf
   net:
     maxIncomingConnections: 1000
   ```

## 查询相关

### Q: 查询返回空结果

**A:** 检查以下几点：

1. 数据库和集合名称是否正确
2. 过滤条件是否正确
3. 数据库中是否有数据

调试方法：

```cpp
// 查询所有文档
MongoDocument empty_filter;
auto result = session.findOne("test", "users", empty_filter);

// 检查集合是否存在
MongoDocument list_collections_cmd;
list_collections_cmd.append("listCollections", int32_t(1));
auto collections = session.command("test", list_collections_cmd);
```

### Q: 查询中文乱码

**A:** MongoDB 默认使用 UTF-8 编码，确保：

1. 源代码文件使用 UTF-8 编码
2. 终端支持 UTF-8
3. 数据插入时使用正确的编码

```cpp
// 确保字符串是 UTF-8 编码
std::string name = u8"张三";  // C++20
MongoDocument doc;
doc.append("name", name);
```

### Q: 大结果集查询内存占用高

**A:** 优化策略：

1. 使用投影只查询需要的字段：
   ```cpp
   MongoDocument projection;
   projection.append("name", int32_t(1));
   projection.append("_id", int32_t(0));
   ```

2. 使用分页查询：
   ```cpp
   MongoDocument find_cmd;
   find_cmd.append("find", "users");
   find_cmd.append("limit", int32_t(100));
   find_cmd.append("skip", int32_t(0));
   ```

3. 调整缓冲区大小：
   ```cpp
   AsyncMongoConfig cfg;
   cfg.buffer_size = 65536;  // 增加到 64KB
   ```

### Q: 查询速度慢

**A:** 优化建议：

1. 为常用查询字段创建索引
2. 使用 explain 分析查询计划：
   ```cpp
   MongoDocument explain_cmd;
   explain_cmd.append("explain", MongoDocument().append("find", "users"));
   ```

3. 检查网络延迟
4. 使用投影减少数据传输
5. 考虑使用聚合管道优化复杂查询

## CRUD 操作相关

### Q: insertOne 返回成功但数据库中没有数据

**A:** 检查：

1. 是否连接到正确的数据库
2. 是否有写入权限
3. 检查返回的 MongoReply：
   ```cpp
   auto result = session.insertOne("test", "users", doc);
   if (result && result->ok()) {
       std::cout << "插入成功\n";
   } else {
       std::cerr << "插入失败: " << result.error().message() << '\n';
   }
   ```

### Q: updateOne 没有更新任何文档

**A:** 可能原因：

1. 过滤条件不匹配任何文档
2. 更新操作符使用错误

检查匹配数量：

```cpp
auto result = session.updateOne("test", "users", filter, update);
if (result && result->ok()) {
    // 检查 modifiedCount
    const auto* modified = result->find("nModified");
    if (modified && modified->isInt32()) {
        std::cout << "修改了 " << modified->getInt32() << " 个文档\n";
    }
}
```

### Q: deleteOne 删除了多个文档

**A:** `deleteOne` 只会删除第一个匹配的文档。如果删除了多个，可能是：

1. 使用了 `deleteMany` 而不是 `deleteOne`
2. 过滤条件匹配了多个文档，但只删除了第一个

确认使用正确的方法：

```cpp
// 删除一个
session.deleteOne("test", "users", filter);

// 删除多个（需要手动构建命令）
MongoDocument delete_cmd;
delete_cmd.append("delete", "users");
// ...
```

## 认证相关

### Q: SCRAM-SHA-256 认证失败

**A:** 检查：

1. MongoDB 版本是否支持 SCRAM-SHA-256（需要 3.0+）
2. 用户是否使用 SCRAM-SHA-256 创建
3. 认证数据库是否正确

查看用户认证机制：

```javascript
use admin
db.system.users.find({user: "admin"})
```

创建 SCRAM-SHA-256 用户：

```javascript
use admin
db.createUser({
  user: "admin",
  pwd: "password",
  roles: [{role: "root", db: "admin"}],
  mechanisms: ["SCRAM-SHA-256"]
})
```

### Q: 认证后仍然无法访问数据库

**A:** 检查用户权限：

```javascript
use admin
db.getUser("admin")
```

授予权限：

```javascript
use admin
db.grantRolesToUser("admin", [{role: "readWrite", db: "test"}])
```

### Q: 如何禁用认证进行测试

**A:** 修改 MongoDB 配置：

```yaml
# /etc/mongod.conf
security:
  authorization: disabled  # 或注释掉整个 security 段
```

重启 MongoDB：

```bash
sudo systemctl restart mongod
```

## 异步相关

### Q: 可以并发使用同一个 AsyncMongoClient 吗？

**A:** 不可以。同一个实例应串行使用。如需并发，为每个协程创建独立客户端：

```cpp
// 错误
AsyncMongoClient client(scheduler);
scheduler->spawn(query1(client));
scheduler->spawn(query2(client));  // 冲突！

// 正确
scheduler->spawn([](IOScheduler* sched) -> Coroutine {
    AsyncMongoClient client(sched);
    // 使用 client
    co_await client.close();
}(scheduler));
```

### Q: co_await 返回错误如何处理？

**A:** 检查 `std::expected` 的返回值：

```cpp
auto res = co_await client.command("test", cmd);
if (!res) {
    // 错误
    std::cerr << "错误: " << res.error().message() << '\n';
    co_return;
}

// 成功
const auto& reply = res.value();
```

### Q: 超时后如何重试？

**A:** 检测超时错误并重新发起请求：

```cpp
auto res = co_await client.command("test", cmd);
if (!res && res.error().type() == MONGO_ERROR_TIMEOUT) {
    std::cerr << "超时，重试中...\n";
    res = co_await client.command("test", cmd);
}
```

### Q: Pipeline 中某个命令失败如何处理？

**A:** 检查每个响应的状态：

```cpp
auto results = co_await client.pipeline("test", commands);
if (!results) {
    std::cerr << "Pipeline 失败: " << results.error().message() << '\n';
    co_return;
}

for (const auto& item : *results) {
    if (item.ok()) {
        // 成功
        const auto& reply = item.reply.value();
    } else {
        // 失败
        std::cerr << "命令 " << item.request_id << " 失败: "
                  << item.error->message() << '\n';
    }
}
```

## 同步相关

### Q: 同步客户端会阻塞吗？

**A:** 是的，所有方法都是阻塞的。适合：

- 简单脚本
- 测试代码
- 低并发场景

高并发场景建议使用异步客户端。

### Q: 同步客户端可以设置超时吗？

**A:** 只能设置连接超时和 socket 超时：

```cpp
MongoConfig cfg;
cfg.connect_timeout_ms = 5000;
cfg.socket_timeout_ms = 30000;
```

### Q: 同步客户端如何实现并发？

**A:** 使用多线程，每个线程一个客户端实例：

```cpp
std::vector<std::thread> threads;
for (int i = 0; i < 10; ++i) {
    threads.emplace_back([i]() {
        MongoClient session;
        session.connect("localhost", 27017, "test");
        // 执行操作
        session.close();
    });
}

for (auto& t : threads) {
    t.join();
}
```

## 错误处理相关

### Q: 如何区分不同类型的错误？

**A:** 通过 `MongoErrorType` 判断：

```cpp
if (!res) {
    auto& err = res.error();
    switch (err.type()) {
        case MONGO_ERROR_CONNECTION:
            std::cerr << "网络连接错误\n";
            break;
        case MONGO_ERROR_AUTH:
            std::cerr << "认证失败\n";
            break;
        case MONGO_ERROR_SERVER:
            std::cerr << "服务器错误: " << err.serverCode() << '\n';
            break;
        case MONGO_ERROR_TIMEOUT:
            std::cerr << "超时\n";
            break;
        default:
            std::cerr << "其他错误\n";
            break;
    }
}
```

### Q: 如何获取详细的错误信息？

**A:** 使用 `message()` 和 `serverCode()`：

```cpp
std::cerr << "错误类型: " << static_cast<int>(err.type()) << '\n';
std::cerr << "错误消息: " << err.message() << '\n';
if (err.type() == MONGO_ERROR_SERVER) {
    std::cerr << "服务器错误码: " << err.serverCode() << '\n';
}
```

### Q: 服务器返回的错误码在哪里查？

**A:** 参考 MongoDB 官方文档：
https://www.mongodb.com/docs/manual/reference/error-codes/

常见错误码：
- 11000: 重复键错误
- 13: 权限不足
- 26: 命名空间不存在

## 性能相关

### Q: 如何提升查询性能？

**A:** 优化策略：

1. 创建合适的索引
2. 使用投影减少数据传输
3. 使用 Pipeline 批量发送命令
4. 调整缓冲区大小
5. 使用聚合管道优化复杂查询
6. 考虑使用 MongoDB 的分片功能

### Q: 连接建立很慢怎么办？

**A:** 可能原因：

1. DNS 解析慢：使用 IP 地址而非域名
2. 网络延迟高：检查网络连接
3. MongoDB 服务器负载高：优化服务器配置
4. 认证过程慢：检查认证配置

### Q: 内存占用过高怎么办？

**A:** 优化建议：

1. 减小 `buffer_size`（默认 16KB）
2. 使用分页查询
3. 使用投影只查询需要的字段
4. 及时关闭不用的连接
5. 检查是否有内存泄漏

### Q: Pipeline 性能如何优化？

**A:** 优化建议：

1. 合理设置 `pipeline_reserve_per_command`
2. 避免发送过多命令（建议 < 100）
3. 使用 `ping` 快路径（自动优化）
4. 调整 `buffer_size` 适应大响应

## BSON 相关

### Q: 如何处理 ObjectId？

**A:** ObjectId 会被解码为 12 字节的 Binary：

```cpp
const auto* oid = doc.find("_id");
if (oid && oid->isBinary()) {
    const auto& binary = oid->getBinary();
    // binary 是 std::vector<uint8_t>，长度为 12
}
```

### Q: 如何处理日期时间？

**A:** MongoDB 的日期时间会被解码为 int64（毫秒时间戳）：

```cpp
const auto* date = doc.find("created_at");
if (date && date->isInt64()) {
    int64_t timestamp_ms = date->getInt64();
    // 转换为 time_t
    time_t timestamp_s = timestamp_ms / 1000;
}
```

### Q: 如何构建复杂的嵌套文档？

**A:** 逐层构建：

```cpp
MongoDocument inner;
inner.append("city", "Beijing");
inner.append("country", "China");

MongoDocument doc;
doc.append("name", "Alice");
doc.append("address", std::move(inner));
```

### Q: 如何遍历文档的所有字段？

**A:** 使用 `fields()` 方法：

```cpp
for (const auto& [key, value] : doc.fields()) {
    std::cout << key << ": ";
    if (value.isString()) {
        std::cout << value.getString();
    }
    std::cout << '\n';
}
```

## 兼容性相关

### Q: 支持哪些 MongoDB 版本？

**A:** 支持 MongoDB 4.0+，推荐使用 5.0+。理论上也支持 3.x，但未充分测试。

### Q: 支持副本集吗？

**A:** 当前版本不支持副本集自动故障转移，需要手动指定连接地址。计划在未来版本中添加。

### Q: 支持分片集群吗？

**A:** 支持连接到 mongos 路由器，但不支持分片感知。

### Q: 支持 TLS/SSL 连接吗？

**A:** 当前版本暂不支持，计划在未来版本中添加。

## 调试相关

### Q: 如何启用调试日志？

**A:** 设置 spdlog 日志级别：

```cpp
#include <spdlog/spdlog.h>

int main() {
    spdlog::set_level(spdlog::level::debug);
    // ...
}
```

异步客户端可以自定义 logger：

```cpp
auto logger = spdlog::stdout_color_mt("mongo_client");
logger->set_level(spdlog::level::debug);
client.setLogger(logger);
```

### Q: 如何查看发送的命令？

**A:** 启用 debug 日志或手动打印：

```cpp
MongoDocument cmd;
cmd.append("ping", int32_t(1));
std::cout << "发送命令: ping\n";
auto res = co_await client.command("test", std::move(cmd));
```

### Q: 如何分析性能瓶颈？

**A:** 使用计时器：

```cpp
auto start = std::chrono::steady_clock::now();
auto res = co_await client.command("test", cmd);
auto end = std::chrono::steady_clock::now();
auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
std::cout << "命令耗时: " << ms.count() << " ms\n";
```

或使用 MongoDB 的 profiler：

```javascript
db.setProfilingLevel(2)  // 记录所有操作
db.system.profile.find().sort({ts: -1}).limit(10)
```

## 其他

### Q: 如何贡献代码？

**A:** 欢迎提交 PR 到 GitHub 仓库：

1. Fork 仓库
2. 创建特性分支
3. 提交代码并编写测试
4. 发起 Pull Request

### Q: 如何报告 Bug？

**A:** 在 GitHub Issues 中提交，包含：

- 复现步骤
- 预期行为和实际行为
- 环境信息（OS、编译器、MongoDB 版本）
- 相关日志和错误信息

### Q: 有商业支持吗？

**A:** 当前为开源项目，暂无商业支持。可通过 GitHub Issues 获取社区支持。

### Q: 与 MongoDB C++ Driver 相比有什么优势？

**A:**

- 现代 C++ 接口（C++23）
- 基于协程的异步支持
- 类型安全的错误处理（`std::expected`）
- 更轻量的依赖
- 与 galay 生态系统集成

### Q: 生产环境可以使用吗？

**A:** 项目处于活跃开发中，建议：

- 充分测试后再用于生产
- 关注 GitHub 更新和 Bug 修复
- 做好错误处理和监控
- 准备降级方案

### Q: 性能测试结果如何？

**A:** 参考 [性能测试文档](04-性能测试.md)，在相同环境下：

- 同步客户端：~3000 QPS（100 并发）
- 异步客户端：~2800 QPS（100 并发）
- 异步 Pipeline：可显著提升吞吐

实际性能取决于网络延迟、服务器配置、查询复杂度等因素。
