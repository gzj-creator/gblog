# 架构设计

## 整体分层

Galay-MySQL 采用分层实现：

```text
Application
  ├─ Async API (AsyncMysqlClient / MysqlConnectionPool)
  └─ Sync API  (MysqlClient)
        ↓
Protocol (MysqlProtocol / MysqlAuth / Connection)
        ↓
Base (MysqlConfig / MysqlError / MysqlValue)
        ↓
Galay-Kernel (Runtime / IOScheduler / TcpSocket / CustomAwaitable)
```

## 模块职责

### Base

- `MysqlConfig`：连接配置
- `MysqlError`：统一错误模型
- `MysqlValue`：字段、行、结果集数据结构

### Protocol

- `MysqlParser`：MySQL 包解析
- `MysqlEncoder`：MySQL 包编码
- `MysqlAuth`：认证算法（`mysql_native_password`、`caching_sha2_password`）
- `Connection`：同步阻塞连接封装

### Async

- `AsyncMysqlClient`：异步客户端
- `MysqlConnectionPool`：连接池
- `AsyncMysqlConfig`：异步超时与缓冲参数

### Sync

- `MysqlClient`：同步阻塞接口

## 异步链式 Awaitable

异步路径基于 `galay::kernel::CustomAwaitable`，通过组合 `Connect` / `Send` / `Readv` 子 Awaitable 构成协议链。

### Connect 流程

`MysqlConnectAwaitable` 链路：

```text
CONNECT -> READV(Handshake) -> SEND(Auth Response) -> READV(Auth Result)
```

只有当认证结果完整解析后才返回完成态。

### Query 流程

`MysqlQueryAwaitable` 链路：

```text
SEND(COM_QUERY) -> READV(ResultSet Stream)
```

内部状态机：

1. `ReceivingHeader`
2. `ReceivingColumns`
3. `ReceivingColumnEof`
4. `ReceivingRows`

### Prepare / Execute

- `MysqlPrepareAwaitable`：`SEND(COM_STMT_PREPARE) -> READV(prepare metadata)`
- `MysqlStmtExecuteAwaitable`：`SEND(COM_STMT_EXECUTE) -> READV(result set)`

## Await 返回语义

异步接口返回值统一是 `std::expected<std::optional<T>, MysqlError>`：

- `!expected`：出错，`expected.error()` 为错误详情
- `expected && !expected->has_value()`：流程未完成，需要继续 `co_await`
- `expected && expected->has_value()`：流程完成，`expected->value()` 为结果

该语义用于 `connect/query/prepare/stmtExecute/acquire`。

## 连接池设计

`MysqlConnectionPool::acquire()` 优先级：

1. 取空闲连接
2. 无空闲且未达上限时创建新连接并完成握手
3. 池满时挂起等待 `release()` 唤醒

`release()` 会优先唤醒等待协程，否则放回空闲队列。

## 关键约束

- 同一个 `AsyncMysqlClient` 实例应串行执行请求，不建议并发复用同一个实例发起多条异步命令。
- 连接池返回的是 `AsyncMysqlClient*`，需要显式 `release()` 归还。
- 生产环境建议设置 `AsyncMysqlConfig` 超时参数，避免无限等待。

## 错误模型

全部接口使用 `std::expected`，错误分类由 `MysqlErrorType` 提供（连接、认证、协议、发送、接收、服务端错误等）。

相较异常，错误路径更可控，便于高并发场景下统一日志与重试策略。
