# 02-架构设计

## 整体分层

Galay-MySQL 采用分层实现：

```text
Application
  ├─ Async API (AsyncMysqlClient / MysqlConnectionPool)
  └─ Sync API  (MysqlClient)
        ↓
Protocol (MysqlProtocol / MysqlAuth / Connection)
        ↓
Base (MysqlConfig / MysqlError / MysqlValue)
        ↓
Galay-Kernel (Runtime / IOScheduler / TcpSocket / CustomAwaitable)
```

## 模块职责

### Base

- `MysqlConfig`：连接配置
- `MysqlError`：统一错误模型
- `MysqlValue`：字段、行、结果集数据结构

### Protocol

- `MysqlParser`：MySQL 包解析
- `MysqlEncoder`：MySQL 包编码
- `MysqlAuth`：认证算法（`mysql_native_password`、`caching_sha2_password`）
- `Connection`：同步阻塞连接封装

### Async

- `AsyncMysqlClient`：异步客户端
- `MysqlConnectionPool`：连接池
- `AsyncMysqlConfig`：异步超时与缓冲参数

### Sync

- `MysqlClient`：同步阻塞接口

## 异步链式 Awaitable

异步路径基于 `galay::kernel::CustomAwaitable`，通过组合 `Connect` / `Send` / `Readv` 子 Awaitable 构成协议链。

### Connect 流程

`MysqlConnectAwaitable` 链路：

```text
CONNECT -> READV(Handshake) -> SEND(Auth Response) -> READV(Auth Result)
```

只有当认证结果完整解析后才返回完成态。

### Query 流程

`MysqlQueryAwaitable` 链路：

```text
SEND(COM_QUERY) -> READV(ResultSet Stream)
```

内部状态机：

1. `ReceivingHeader`
2. `ReceivingColumns`
3. `ReceivingColumnEof`
4. `ReceivingRows`

### Prepare / Execute

- `MysqlPrepareAwaitable`：`SEND(COM_STMT_PREPARE) -> READV(prepare metadata)`
- `MysqlStmtExecuteAwaitable`：`SEND(COM_STMT_EXECUTE) -> READV(result set)`

## Await 返回语义

异步接口返回值统一是 `std::expected<std::optional<T>, MysqlError>`：

- `!expected`：出错，`expected.error()` 为错误详情
- `expected && !expected->has_value()`：流程未完成，需要继续 `co_await`
- `expected && expected->has_value()`：流程完成，`expected->value()` 为结果

该语义用于 `connect/query/prepare/stmtExecute/acquire`。

## 连接池设计

`MysqlConnectionPool::acquire()` 优先级：

1. 取空闲连接
2. 无空闲且未达上限时创建新连接并完成握手
3. 池满时挂起等待 `release()` 唤醒

`release()` 会优先唤醒等待协程，否则放回空闲队列。

## 关键约束

- 同一个 `AsyncMysqlClient` 实例应串行执行请求，不建议并发复用同一个实例发起多条异步命令。
- 连接池返回的是 `AsyncMysqlClient*`，需要显式 `release()` 归还。
- 生产环境建议设置 `AsyncMysqlConfig` 超时参数，避免无限等待。

## 错误模型

全部接口使用 `std::expected`，错误分类由 `MysqlErrorType` 提供（连接、认证、协议、发送、接收、服务端错误等）。

相较异常，错误路径更可控，便于高并发场景下统一日志与重试策略。

## 内存管理

### RingBuffer 复用

异步客户端使用 `RingBuffer` 作为接收缓冲区，避免频繁分配。缓冲区大小由 `AsyncMysqlConfig::buffer_size` 控制（默认 16KB）。

### 结果集预留

通过 `AsyncMysqlConfig::result_row_reserve_hint` 可预留行容器空间，减少大结果集的内存重分配。

### 零拷贝参数

`stmtExecute` 的 `string_view` + `span` 版本允许上层直接传递视图，避免参数字符串的额外拷贝。

## 协议细节

### 认证流程

支持两种认证插件：

1. `mysql_native_password`：SHA1 哈希
2. `caching_sha2_password`：SHA256 哈希 + 快速路径/完整认证

握手包解析后根据服务端能力标志选择认证方式。

### 包序列号

MySQL 协议要求每个包携带序列号，连接建立后从 0 开始递增。每次新命令重置为 0。

### EOF vs OK

MySQL 5.7+ 支持 `CLIENT_DEPRECATE_EOF`，用 OK 包替代 EOF 包。协议层自动处理两种模式。

## 并发模型

### 异步路径

基于 `galay::kernel::IOScheduler` 的协程调度，单个客户端实例串行执行命令，多个客户端实例可并发运行在不同协程中。

### 连接池并发

连接池内部使用队列管理空闲连接和等待协程，通过 `acquire/release` 实现安全的并发访问。

### 同步路径

使用阻塞 socket，适合单线程或简单场景，不涉及协程调度。

## 性能考量

### 批量操作

使用事务包裹多个 INSERT/UPDATE 可显著提升吞吐：

```cpp
co_await client.beginTransaction();
for (auto& item : items) {
    co_await client.query("INSERT INTO ...");
}
co_await client.commit();
```

### 预处理语句

对于重复执行的查询，预处理语句可减少 SQL 解析开销：

```cpp
auto prep = co_await client.prepare("SELECT * FROM users WHERE id = ?");
for (auto id : ids) {
    co_await client.stmtExecute(prep->statement_id, {std::to_string(id)});
}
```

### 连接池大小

- `min_connections`：预热连接数，避免冷启动延迟
- `max_connections`：峰值并发数，需根据数据库服务器配置和负载调整

## 线程安全

- `AsyncMysqlClient`：非线程安全，应在单个协程中使用
- `MysqlClient`：非线程安全，应在单个线程中使用
- `MysqlConnectionPool`：内部线程安全，可从多个协程并发调用 `acquire/release`
