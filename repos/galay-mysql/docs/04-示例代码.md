# 04-示例代码

以下示例默认给出模块化导入版本：支持模块时使用 `import galay.mysql;`，否则按需包含对应头文件。

仓库中的可直接运行示例在 `examples/`：

- include 版本：`examples/include/E1-AsyncQuery.cc`
- include 版本：`examples/include/E2-SyncQuery.cc`
- include 版本：`examples/include/E3-AsyncPool.cc`
- include 版本：`examples/include/E4-SyncPreparedTx.cc`
- import 版本：`examples/import/E1-AsyncQuery.cc`
- import 版本：`examples/import/E2-SyncQuery.cc`
- import 版本：`examples/import/E3-AsyncPool.cc`
- import 版本：`examples/import/E4-SyncPreparedTx.cc`

## 异步查询（Runtime + IOScheduler）

```cpp
#include <atomic>
#include <chrono>
#include <expected>
#include <iostream>
#include <optional>
#include <thread>
#include <galay-kernel/kernel/Runtime.h>

#if defined(__cpp_modules) && __cpp_modules >= 201907L
import galay.mysql;
#else
#include "galay-mysql/async/AsyncMysqlClient.h"
#endif

using namespace galay::kernel;
using namespace galay::mysql;

struct State {
    std::atomic<bool> done{false};
};

Coroutine asyncQuery(IOScheduler* scheduler, State* state) {
    AsyncMysqlClient client(scheduler);

    auto& conn_aw = client.connect("127.0.0.1", 3306, "root", "password", "test");
    std::expected<std::optional<bool>, MysqlError> conn;
    do {
        conn = co_await conn_aw;
        if (!conn) {
            std::cerr << "connect failed: " << conn.error().message() << '\n';
            state->done.store(true, std::memory_order_release);
            co_return;
        }
    } while (!conn->has_value());

    auto& query_aw = client.query("SELECT id, name FROM users LIMIT 10");
    std::expected<std::optional<MysqlResultSet>, MysqlError> res;
    do {
        res = co_await query_aw;
        if (!res) {
            std::cerr << "query failed: " << res.error().message() << '\n';
            co_await client.close();
            state->done.store(true, std::memory_order_release);
            co_return;
        }
    } while (!res->has_value());

    const MysqlResultSet& rs = res->value();
    for (size_t i = 0; i < rs.rowCount(); ++i) {
        const auto& row = rs.row(i);
        std::cout << row.getString(0) << " " << row.getString(1) << '\n';
    }

    co_await client.close();
    state->done.store(true, std::memory_order_release);
}

int main() {
    Runtime runtime;
    runtime.start();

    auto* scheduler = runtime.getNextIOScheduler();
    if (!scheduler) return 1;

    State state;
    scheduler->spawn(asyncQuery(scheduler, &state));

    using namespace std::chrono_literals;
    while (!state.done.load(std::memory_order_acquire)) {
        std::this_thread::sleep_for(50ms);
    }

    runtime.stop();
    return 0;
}
```

## 异步预处理语句（`span` + `string_view` 参数层）

```cpp
#include <array>
#include <optional>
#include <string_view>

// 前置：已获得 stmt_id
std::array<std::optional<std::string_view>, 2> params = {
    std::string_view("Alice"),
    std::string_view("25"),
};

auto& exec_aw = client.stmtExecute(
    stmt_id,
    std::span<const std::optional<std::string_view>>(params)
);

std::expected<std::optional<MysqlResultSet>, MysqlError> exec_res;
do {
    exec_res = co_await exec_aw;
    if (!exec_res) {
        std::cerr << "execute failed: " << exec_res.error().message() << '\n';
        co_return;
    }
} while (!exec_res->has_value());

std::cout << "affected rows: " << exec_res->value().affectedRows() << '\n';
```

## 异步连接池

```cpp
MysqlConfig cfg;
cfg.host = "127.0.0.1";
cfg.port = 3306;
cfg.username = "root";
cfg.password = "password";
cfg.database = "test";

MysqlConnectionPool pool(
    scheduler,
    cfg,
    AsyncMysqlConfig::withTimeout(std::chrono::milliseconds(3000),
                                  std::chrono::milliseconds(5000)),
    2,
    16
);

auto& acq_aw = pool.acquire();
std::expected<std::optional<AsyncMysqlClient*>, MysqlError> acq;
do {
    acq = co_await acq_aw;
    if (!acq) {
        std::cerr << "acquire failed: " << acq.error().message() << '\n';
        co_return;
    }
} while (!acq->has_value());

AsyncMysqlClient* client = acq->value();

auto& query_aw = client->query("SELECT 1");
std::expected<std::optional<MysqlResultSet>, MysqlError> res;
do {
    res = co_await query_aw;
    if (!res) {
        std::cerr << "query failed: " << res.error().message() << '\n';
        pool.release(client);
        co_return;
    }
} while (!res->has_value());

pool.release(client);
```

## 同步事务与预处理语句

```cpp
#include <iostream>

#if defined(__cpp_modules) && __cpp_modules >= 201907L
import galay.mysql;
#else
#include "galay-mysql/sync/MysqlClient.h"
#endif

using namespace galay::mysql;

int main() {
    MysqlClient session;

    MysqlConfig cfg;
    cfg.host = "127.0.0.1";
    cfg.port = 3306;
    cfg.username = "root";
    cfg.password = "password";
    cfg.database = "test";

    auto conn = session.connect(cfg);
    if (!conn) return 1;

    auto begin = session.beginTransaction();
    if (!begin) return 1;

    auto prep = session.prepare("INSERT INTO users(name, age) VALUES(?, ?)");
    if (!prep) return 1;

    std::vector<std::optional<std::string>> params = {"Bob", "30"};
    auto exec = session.stmtExecute(prep->statement_id, params);
    if (!exec) {
        session.rollback();
        return 1;
    }

    session.stmtClose(prep->statement_id);
    session.commit();
    session.close();
    return 0;
}
```

## 超时配置

```cpp
AsyncMysqlConfig async_cfg = AsyncMysqlConfig::withTimeout(
    std::chrono::milliseconds(2000),
    std::chrono::milliseconds(5000)
);

AsyncMysqlClient client(scheduler, async_cfg);
```

## 错误处理最佳实践

### 异步错误处理

```cpp
Coroutine handleQuery(IOScheduler* scheduler) {
    AsyncMysqlClient client(scheduler);

    auto& conn_aw = client.connect("127.0.0.1", 3306, "root", "password", "test");
    std::expected<std::optional<bool>, MysqlError> conn;
    do {
        conn = co_await conn_aw;
        if (!conn) {
            auto& err = conn.error();
            switch (err.type()) {
                case MYSQL_ERROR_CONNECTION:
                    std::cerr << "网络连接失败: " << err.message() << '\n';
                    break;
                case MYSQL_ERROR_AUTH:
                    std::cerr << "认证失败: " << err.message() << '\n';
                    break;
                case MYSQL_ERROR_TIMEOUT:
                    std::cerr << "连接超时: " << err.message() << '\n';
                    break;
                default:
                    std::cerr << "未知错误: " << err.message() << '\n';
            }
            co_return;
        }
    } while (!conn->has_value());

    // 查询错误处理
    auto& query_aw = client.query("SELECT * FROM users");
    std::expected<std::optional<MysqlResultSet>, MysqlError> res;
    do {
        res = co_await query_aw;
        if (!res) {
            auto& err = res.error();
            if (err.type() == MYSQL_ERROR_SERVER) {
                std::cerr << "SQL错误 [" << err.serverErrno() << "]: "
                          << err.message() << '\n';
            } else {
                std::cerr << "查询失败: " << err.message() << '\n';
            }
            co_await client.close();
            co_return;
        }
    } while (!res->has_value());

    co_await client.close();
}
```

### 同步错误处理

```cpp
void handleQuerySync() {
    MysqlClient session;

    auto conn = session.connect("127.0.0.1", 3306, "root", "password", "test");
    if (!conn) {
        std::cerr << "连接失败: " << conn.error().message() << '\n';
        return;
    }

    auto res = session.query("SELECT * FROM users");
    if (!res) {
        auto& err = res.error();
        if (err.type() == MYSQL_ERROR_SERVER) {
            std::cerr << "SQL错误 [" << err.serverErrno() << "]: "
                      << err.message() << '\n';
        } else {
            std::cerr << "查询失败: " << err.message() << '\n';
        }
        session.close();
        return;
    }

    session.close();
}
```

## 连接池 RAII 封装

```cpp
class PooledConnection {
public:
    PooledConnection(MysqlConnectionPool& pool, AsyncMysqlClient* client)
        : m_pool(pool), m_client(client) {}

    ~PooledConnection() {
        if (m_client) {
            m_pool.release(m_client);
        }
    }

    PooledConnection(const PooledConnection&) = delete;
    PooledConnection& operator=(const PooledConnection&) = delete;

    PooledConnection(PooledConnection&& other) noexcept
        : m_pool(other.m_pool), m_client(other.m_client) {
        other.m_client = nullptr;
    }

    AsyncMysqlClient* operator->() { return m_client; }
    AsyncMysqlClient& operator*() { return *m_client; }

private:
    MysqlConnectionPool& m_pool;
    AsyncMysqlClient* m_client;
};

Coroutine usePool(IOScheduler* scheduler, MysqlConnectionPool& pool) {
    auto& acq_aw = pool.acquire();
    std::expected<std::optional<AsyncMysqlClient*>, MysqlError> acq;
    do {
        acq = co_await acq_aw;
        if (!acq) {
            std::cerr << "获取连接失败: " << acq.error().message() << '\n';
            co_return;
        }
    } while (!acq->has_value());

    PooledConnection conn(pool, acq->value());

    auto& query_aw = conn->query("SELECT 1");
    // ... 使用连接

    // 析构时自动归还
}
```

## 批量插入优化

```cpp
Coroutine batchInsert(IOScheduler* scheduler, AsyncMysqlClient& client,
                      const std::vector<std::pair<std::string, int>>& users) {
    // 开启事务
    auto& begin_aw = client.beginTransaction();
    std::expected<std::optional<MysqlResultSet>, MysqlError> begin_res;
    do {
        begin_res = co_await begin_aw;
        if (!begin_res) {
            std::cerr << "开启事务失败: " << begin_res.error().message() << '\n';
            co_return;
        }
    } while (!begin_res->has_value());

    // 预处理语句
    auto& prep_aw = client.prepare("INSERT INTO users(name, age) VALUES(?, ?)");
    std::expected<std::optional<MysqlPrepareAwaitable::PrepareResult>, MysqlError> prep_res;
    do {
        prep_res = co_await prep_aw;
        if (!prep_res) {
            std::cerr << "预处理失败: " << prep_res.error().message() << '\n';
            co_await client.rollback();
            co_return;
        }
    } while (!prep_res->has_value());

    uint32_t stmt_id = prep_res->value().statement_id;

    // 批量执行
    for (const auto& [name, age] : users) {
        std::array<std::optional<std::string_view>, 2> params = {
            std::string_view(name),
            std::to_string(age)
        };

        auto& exec_aw = client.stmtExecute(stmt_id, std::span(params));
        std::expected<std::optional<MysqlResultSet>, MysqlError> exec_res;
        do {
            exec_res = co_await exec_aw;
            if (!exec_res) {
                std::cerr << "执行失败: " << exec_res.error().message() << '\n';
                co_await client.rollback();
                co_return;
            }
        } while (!exec_res->has_value());
    }

    // 提交事务
    auto& commit_aw = client.commit();
    std::expected<std::optional<MysqlResultSet>, MysqlError> commit_res;
    do {
        commit_res = co_await commit_aw;
        if (!commit_res) {
            std::cerr << "提交失败: " << commit_res.error().message() << '\n';
            co_await client.rollback();
            co_return;
        }
    } while (!commit_res->has_value());

    std::cout << "批量插入 " << users.size() << " 条记录成功\n";
}
```

## 结果集遍历

```cpp
void processResultSet(const MysqlResultSet& rs) {
    if (!rs.hasResultSet()) {
        std::cout << "影响行数: " << rs.affectedRows() << '\n';
        std::cout << "最后插入ID: " << rs.lastInsertId() << '\n';
        return;
    }

    // 打印列名
    for (size_t i = 0; i < rs.fieldCount(); ++i) {
        const auto& field = rs.field(i);
        std::cout << field.name();
        if (i < rs.fieldCount() - 1) std::cout << "\t";
    }
    std::cout << '\n';

    // 打印数据
    for (size_t i = 0; i < rs.rowCount(); ++i) {
        const auto& row = rs.row(i);
        for (size_t j = 0; j < row.size(); ++j) {
            if (row.isNull(j)) {
                std::cout << "NULL";
            } else {
                std::cout << row.getString(j);
            }
            if (j < row.size() - 1) std::cout << "\t";
        }
        std::cout << '\n';
    }
}
```

## 测试程序运行

```bash
GALAY_MYSQL_HOST=127.0.0.1 \
GALAY_MYSQL_PORT=3306 \
GALAY_MYSQL_USER=root \
GALAY_MYSQL_PASSWORD=password \
GALAY_MYSQL_DB=test \
./build/test/T3-AsyncMysqlClient

GALAY_MYSQL_HOST=127.0.0.1 \
GALAY_MYSQL_PORT=3306 \
GALAY_MYSQL_USER=root \
GALAY_MYSQL_PASSWORD=password \
GALAY_MYSQL_DB=test \
./build/test/T7-PreparedStatement
```
