# 示例代码

以下示例默认给出模块化导入版本：支持模块时使用 `import galay.mysql;`，否则按需包含对应头文件。

仓库中的可直接运行示例在 `example/`：

- include 版本：`example/include/E1-AsyncQuery.cc`
- include 版本：`example/include/E2-SyncQuery.cc`
- include 版本：`example/include/E3-AsyncPool.cc`
- include 版本：`example/include/E4-SyncPreparedTx.cc`
- import 版本：`example/import/E1-AsyncQuery.cc`
- import 版本：`example/import/E2-SyncQuery.cc`
- import 版本：`example/import/E3-AsyncPool.cc`
- import 版本：`example/import/E4-SyncPreparedTx.cc`

## 异步查询（Runtime + IOScheduler）

```cpp
#include <atomic>
#include <chrono>
#include <expected>
#include <iostream>
#include <optional>
#include <thread>
#include <galay-kernel/kernel/Runtime.h>

#if defined(__cpp_modules) && __cpp_modules >= 201907L
import galay.mysql;
#else
#include "galay-mysql/async/AsyncMysqlClient.h"
#endif

using namespace galay::kernel;
using namespace galay::mysql;

struct State {
    std::atomic<bool> done{false};
};

Coroutine asyncQuery(IOScheduler* scheduler, State* state) {
    AsyncMysqlClient client(scheduler);

    auto& conn_aw = client.connect("127.0.0.1", 3306, "root", "password", "test");
    std::expected<std::optional<bool>, MysqlError> conn;
    do {
        conn = co_await conn_aw;
        if (!conn) {
            std::cerr << "connect failed: " << conn.error().message() << '\n';
            state->done.store(true, std::memory_order_release);
            co_return;
        }
    } while (!conn->has_value());

    auto& query_aw = client.query("SELECT id, name FROM users LIMIT 10");
    std::expected<std::optional<MysqlResultSet>, MysqlError> res;
    do {
        res = co_await query_aw;
        if (!res) {
            std::cerr << "query failed: " << res.error().message() << '\n';
            co_await client.close();
            state->done.store(true, std::memory_order_release);
            co_return;
        }
    } while (!res->has_value());

    const MysqlResultSet& rs = res->value();
    for (size_t i = 0; i < rs.rowCount(); ++i) {
        const auto& row = rs.row(i);
        std::cout << row.getString(0) << " " << row.getString(1) << '\n';
    }

    co_await client.close();
    state->done.store(true, std::memory_order_release);
}

int main() {
    Runtime runtime;
    runtime.start();

    auto* scheduler = runtime.getNextIOScheduler();
    if (!scheduler) return 1;

    State state;
    scheduler->spawn(asyncQuery(scheduler, &state));

    using namespace std::chrono_literals;
    while (!state.done.load(std::memory_order_acquire)) {
        std::this_thread::sleep_for(50ms);
    }

    runtime.stop();
    return 0;
}
```

## 异步预处理语句（`span` + `string_view` 参数层）

```cpp
#include <array>
#include <optional>
#include <string_view>

// 前置：已获得 stmt_id
std::array<std::optional<std::string_view>, 2> params = {
    std::string_view("Alice"),
    std::string_view("25"),
};

auto& exec_aw = client.stmtExecute(
    stmt_id,
    std::span<const std::optional<std::string_view>>(params)
);

std::expected<std::optional<MysqlResultSet>, MysqlError> exec_res;
do {
    exec_res = co_await exec_aw;
    if (!exec_res) {
        std::cerr << "execute failed: " << exec_res.error().message() << '\n';
        co_return;
    }
} while (!exec_res->has_value());

std::cout << "affected rows: " << exec_res->value().affectedRows() << '\n';
```

## 异步连接池

```cpp
MysqlConfig cfg;
cfg.host = "127.0.0.1";
cfg.port = 3306;
cfg.username = "root";
cfg.password = "password";
cfg.database = "test";

MysqlConnectionPool pool(
    scheduler,
    cfg,
    AsyncMysqlConfig::withTimeout(std::chrono::milliseconds(3000),
                                  std::chrono::milliseconds(5000)),
    2,
    16
);

auto& acq_aw = pool.acquire();
std::expected<std::optional<AsyncMysqlClient*>, MysqlError> acq;
do {
    acq = co_await acq_aw;
    if (!acq) {
        std::cerr << "acquire failed: " << acq.error().message() << '\n';
        co_return;
    }
} while (!acq->has_value());

AsyncMysqlClient* client = acq->value();

auto& query_aw = client->query("SELECT 1");
std::expected<std::optional<MysqlResultSet>, MysqlError> res;
do {
    res = co_await query_aw;
    if (!res) {
        std::cerr << "query failed: " << res.error().message() << '\n';
        pool.release(client);
        co_return;
    }
} while (!res->has_value());

pool.release(client);
```

## 同步事务与预处理语句

```cpp
#include <iostream>

#if defined(__cpp_modules) && __cpp_modules >= 201907L
import galay.mysql;
#else
#include "galay-mysql/sync/MysqlClient.h"
#endif

using namespace galay::mysql;

int main() {
    MysqlClient session;

    MysqlConfig cfg;
    cfg.host = "127.0.0.1";
    cfg.port = 3306;
    cfg.username = "root";
    cfg.password = "password";
    cfg.database = "test";

    auto conn = session.connect(cfg);
    if (!conn) return 1;

    auto begin = session.beginTransaction();
    if (!begin) return 1;

    auto prep = session.prepare("INSERT INTO users(name, age) VALUES(?, ?)");
    if (!prep) return 1;

    std::vector<std::optional<std::string>> params = {"Bob", "30"};
    auto exec = session.stmtExecute(prep->statement_id, params);
    if (!exec) {
        session.rollback();
        return 1;
    }

    session.stmtClose(prep->statement_id);
    session.commit();
    session.close();
    return 0;
}
```

## 超时配置

```cpp
AsyncMysqlConfig async_cfg = AsyncMysqlConfig::withTimeout(
    std::chrono::milliseconds(2000),
    std::chrono::milliseconds(5000)
);

AsyncMysqlClient client(scheduler, async_cfg);
```

## 测试程序运行

```bash
GALAY_MYSQL_HOST=127.0.0.1 \
GALAY_MYSQL_PORT=3306 \
GALAY_MYSQL_USER=root \
GALAY_MYSQL_PASSWORD=password \
GALAY_MYSQL_DB=test \
./build/test/T3-AsyncMysqlClient

GALAY_MYSQL_HOST=127.0.0.1 \
GALAY_MYSQL_PORT=3306 \
GALAY_MYSQL_USER=root \
GALAY_MYSQL_PASSWORD=password \
GALAY_MYSQL_DB=test \
./build/test/T7-PreparedStatement
```
