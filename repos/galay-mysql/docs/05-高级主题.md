# 05-高级主题

## 性能优化

### 1. 连接池配置

连接池的大小直接影响并发性能：

```cpp
// 低并发场景（< 10 QPS）
MysqlConnectionPool pool(scheduler, config, async_config, 2, 5);

// 中等并发场景（10-100 QPS）
MysqlConnectionPool pool(scheduler, config, async_config, 5, 20);

// 高并发场景（> 100 QPS）
MysqlConnectionPool pool(scheduler, config, async_config, 10, 50);
```

**原则**：
- `min_connections` 应覆盖平均并发数
- `max_connections` 应覆盖峰值并发数
- 不要超过 MySQL 服务器的 `max_connections` 配置

### 2. 结果集预留

对于已知大小的结果集，预留空间可减少内存重分配：

```cpp
AsyncMysqlConfig cfg = AsyncMysqlConfig::noTimeout();
cfg.result_row_reserve_hint = 1000;  // 预期返回 1000 行
AsyncMysqlClient client(scheduler, cfg);
```

### 3. 零拷贝参数传递

使用 `string_view` + `span` 避免参数拷贝：

```cpp
// 低效：每次都拷贝字符串
std::vector<std::optional<std::string>> params = {"Alice", "25"};
co_await client.stmtExecute(stmt_id, params);

// 高效：零拷贝视图
std::array<std::optional<std::string_view>, 2> params = {
    std::string_view("Alice"),
    std::string_view("25")
};
co_await client.stmtExecute(stmt_id, std::span(params));
```

### 4. 批量操作

使用事务包裹批量写入：

```cpp
// 低效：每次自动提交
for (auto& item : items) {
    co_await client.query("INSERT INTO ...");
}

// 高效：批量提交
co_await client.beginTransaction();
for (auto& item : items) {
    co_await client.query("INSERT INTO ...");
}
co_await client.commit();
```

### 5. 预处理语句复用

对于重复执行的查询，预处理语句可减少解析开销：

```cpp
// 低效：每次解析 SQL
for (auto id : ids) {
    co_await client.query("SELECT * FROM users WHERE id = " + std::to_string(id));
}

// 高效：预处理一次，执行多次
auto prep = co_await client.prepare("SELECT * FROM users WHERE id = ?");
uint32_t stmt_id = prep->value().statement_id;
for (auto id : ids) {
    co_await client.stmtExecute(stmt_id, {std::to_string(id)});
}
```

## 超时策略

### 连接超时

通过 `MysqlConfig::connect_timeout_ms` 设置：

```cpp
MysqlConfig cfg;
cfg.connect_timeout_ms = 5000;  // 5 秒连接超时
```

### 发送/接收超时

通过 `AsyncMysqlConfig` 设置：

```cpp
// 仅接收超时（常用于长查询）
AsyncMysqlConfig cfg = AsyncMysqlConfig::withRecvTimeout(
    std::chrono::seconds(30)
);

// 发送和接收超时
AsyncMysqlConfig cfg = AsyncMysqlConfig::withTimeout(
    std::chrono::seconds(5),   // 发送超时
    std::chrono::seconds(30)   // 接收超时
);

// 无超时（不推荐生产环境）
AsyncMysqlConfig cfg = AsyncMysqlConfig::noTimeout();
```

### 超时处理

```cpp
auto& query_aw = client.query("SELECT * FROM large_table");
std::expected<std::optional<MysqlResultSet>, MysqlError> res;
do {
    res = co_await query_aw;
    if (!res) {
        if (res.error().type() == MYSQL_ERROR_TIMEOUT) {
            std::cerr << "查询超时，考虑优化 SQL 或增加超时时间\n";
        }
        co_return;
    }
} while (!res->has_value());
```

## 事务管理

### 基本事务

```cpp
co_await client.beginTransaction();
try {
    co_await client.query("UPDATE accounts SET balance = balance - 100 WHERE id = 1");
    co_await client.query("UPDATE accounts SET balance = balance + 100 WHERE id = 2");
    co_await client.commit();
} catch (...) {
    co_await client.rollback();
    throw;
}
```

### 事务隔离级别

通过 SQL 命令设置：

```cpp
// 设置为 READ COMMITTED
co_await client.query("SET TRANSACTION ISOLATION LEVEL READ COMMITTED");
co_await client.beginTransaction();
// ... 执行事务操作
co_await client.commit();
```

### 保存点

```cpp
co_await client.beginTransaction();
co_await client.query("INSERT INTO users ...");
co_await client.query("SAVEPOINT sp1");
co_await client.query("INSERT INTO logs ...");
// 回滚到保存点
co_await client.query("ROLLBACK TO SAVEPOINT sp1");
co_await client.commit();
```

## 字段类型处理

### 数值类型

```cpp
const auto& row = rs.row(0);

// 整数
int64_t id = row.getInt64(0);
uint64_t unsigned_id = row.getUint64(1);

// 浮点数
double price = row.getDouble(2);
```

### 字符串类型

```cpp
std::string name = row.getString(0);
std::string description = row.getString(1, "默认值");
```

### NULL 处理

```cpp
if (row.isNull(0)) {
    std::cout << "字段为 NULL\n";
} else {
    std::cout << "字段值: " << row.getString(0) << '\n';
}

// 或使用 optional
const auto& opt_val = row[0];
if (opt_val.has_value()) {
    std::cout << "字段值: " << *opt_val << '\n';
}
```

### 日期时间类型

MySQL 返回的日期时间是字符串格式：

```cpp
std::string datetime = row.getString(0);  // "2024-01-15 10:30:00"
std::string date = row.getString(1);      // "2024-01-15"
std::string time = row.getString(2);      // "10:30:00"

// 需要自行解析或使用第三方库（如 date.h）
```

### BLOB/BINARY 类型

```cpp
std::string blob_data = row.getString(0);
// blob_data 包含原始二进制数据
size_t size = blob_data.size();
const uint8_t* data = reinterpret_cast<const uint8_t*>(blob_data.data());
```

## 字段元数据

### 获取字段信息

```cpp
const MysqlResultSet& rs = /* ... */;

for (size_t i = 0; i < rs.fieldCount(); ++i) {
    const auto& field = rs.field(i);

    std::cout << "列名: " << field.name() << '\n';
    std::cout << "类型: " << static_cast<int>(field.type()) << '\n';
    std::cout << "长度: " << field.columnLength() << '\n';
    std::cout << "小数位: " << static_cast<int>(field.decimals()) << '\n';

    if (field.isNotNull()) std::cout << "NOT NULL\n";
    if (field.isPrimaryKey()) std::cout << "PRIMARY KEY\n";
    if (field.isAutoIncrement()) std::cout << "AUTO_INCREMENT\n";
    if (field.isUnsigned()) std::cout << "UNSIGNED\n";
}
```

### 按列名访问

```cpp
int name_idx = rs.findField("name");
if (name_idx >= 0) {
    std::string name = rs.row(0).getString(name_idx);
}
```

## 连接状态管理

### 检查连接状态

```cpp
// 异步客户端
if (client.isClosed()) {
    std::cerr << "连接已关闭\n";
}

// 同步客户端
if (!session.isConnected()) {
    std::cerr << "连接已断开\n";
}
```

### Ping 保活

```cpp
// 定期 ping 保持连接活跃
co_await client.ping();
```

### 切换数据库

```cpp
co_await client.useDatabase("another_db");
```

## 错误恢复策略

### 连接重试

```cpp
Coroutine connectWithRetry(IOScheduler* scheduler, AsyncMysqlClient& client,
                           const MysqlConfig& config, int max_retries = 3) {
    for (int i = 0; i < max_retries; ++i) {
        auto& conn_aw = client.connect(config);
        std::expected<std::optional<bool>, MysqlError> res;
        do {
            res = co_await conn_aw;
            if (!res) {
                if (i < max_retries - 1) {
                    std::cerr << "连接失败，" << (i + 1) << " 秒后重试...\n";
                    co_await galay::kernel::sleep(std::chrono::seconds(i + 1));
                    break;
                } else {
                    std::cerr << "连接失败，已达最大重试次数\n";
                    co_return;
                }
            }
        } while (!res->has_value());

        if (res && res->has_value()) {
            std::cout << "连接成功\n";
            co_return;
        }
    }
}
```

### 死锁重试

```cpp
Coroutine executeWithDeadlockRetry(AsyncMysqlClient& client,
                                   const std::string& sql,
                                   int max_retries = 3) {
    for (int i = 0; i < max_retries; ++i) {
        auto& query_aw = client.query(sql);
        std::expected<std::optional<MysqlResultSet>, MysqlError> res;
        do {
            res = co_await query_aw;
            if (!res) {
                auto& err = res.error();
                // MySQL 死锁错误码：1213
                if (err.type() == MYSQL_ERROR_SERVER && err.serverErrno() == 1213) {
                    if (i < max_retries - 1) {
                        std::cerr << "检测到死锁，重试中...\n";
                        break;
                    }
                }
                co_return;
            }
        } while (!res->has_value());

        if (res && res->has_value()) {
            co_return;
        }
    }
}
```

## 安全性

### SQL 注入防护

**永远使用预处理语句**处理用户输入：

```cpp
// 危险：SQL 注入风险
std::string user_input = /* 来自用户 */;
co_await client.query("SELECT * FROM users WHERE name = '" + user_input + "'");

// 安全：使用预处理语句
auto prep = co_await client.prepare("SELECT * FROM users WHERE name = ?");
co_await client.stmtExecute(prep->value().statement_id, {user_input});
```

### 密码安全

不要在代码中硬编码密码：

```cpp
// 从环境变量读取
const char* password = std::getenv("MYSQL_PASSWORD");
if (!password) {
    std::cerr << "未设置 MYSQL_PASSWORD 环境变量\n";
    return;
}

MysqlConfig cfg;
cfg.password = password;
```

### SSL/TLS 连接

当前版本暂不支持 SSL/TLS，计划在未来版本中添加。

## 调试技巧

### 启用日志

```cpp
// 客户端内部使用 spdlog，可通过日志级别控制输出
// 在创建客户端前设置全局日志级别
spdlog::set_level(spdlog::level::debug);
```

### 打印 SQL 语句

```cpp
std::string sql = "SELECT * FROM users WHERE id = ?";
std::cout << "执行 SQL: " << sql << '\n';
auto& prep_aw = client.prepare(sql);
// ...
```

### 性能分析

```cpp
auto start = std::chrono::steady_clock::now();

// 执行查询
auto& query_aw = client.query("SELECT * FROM large_table");
// ... co_await

auto end = std::chrono::steady_clock::now();
auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
std::cout << "查询耗时: " << duration.count() << " ms\n";
```

## 常见陷阱

### 1. 忘记归还连接池连接

```cpp
// 错误：忘记 release
auto client = co_await pool.acquire();
co_await client->query("...");
// 连接泄漏！

// 正确：使用 RAII 或手动 release
auto client = co_await pool.acquire();
co_await client->query("...");
pool.release(client);
```

### 2. 并发使用同一个客户端

```cpp
// 错误：并发使用同一个客户端实例
AsyncMysqlClient client(scheduler);
scheduler->spawn(query1(client));  // 协程 1
scheduler->spawn(query2(client));  // 协程 2 - 冲突！

// 正确：使用连接池或为每个协程创建独立客户端
```

### 3. 忘记检查 has_value()

```cpp
// 错误：直接访问 value()
auto res = co_await client.query("...");
if (res) {
    const auto& rs = res->value();  // 可能崩溃！
}

// 正确：检查 has_value()
auto res = co_await client.query("...");
if (res && res->has_value()) {
    const auto& rs = res->value();
}
```

### 4. 超时设置过短

```cpp
// 错误：超时过短导致正常查询失败
AsyncMysqlConfig cfg = AsyncMysqlConfig::withRecvTimeout(
    std::chrono::milliseconds(100)  // 太短！
);

// 正确：根据实际查询时间设置合理超时
AsyncMysqlConfig cfg = AsyncMysqlConfig::withRecvTimeout(
    std::chrono::seconds(30)
);
```

### 5. 忘记关闭预处理语句（同步客户端）

```cpp
// 同步客户端需要手动关闭预处理语句
auto prep = session.prepare("...");
if (prep) {
    session.stmtExecute(prep->statement_id, params);
    session.stmtClose(prep->statement_id);  // 不要忘记！
}
```

## 与其他库集成

### 与 JSON 库集成

```cpp
#include <nlohmann/json.hpp>

nlohmann::json resultSetToJson(const MysqlResultSet& rs) {
    nlohmann::json result = nlohmann::json::array();

    for (size_t i = 0; i < rs.rowCount(); ++i) {
        nlohmann::json row_obj;
        const auto& row = rs.row(i);

        for (size_t j = 0; j < rs.fieldCount(); ++j) {
            const auto& field = rs.field(j);
            if (row.isNull(j)) {
                row_obj[field.name()] = nullptr;
            } else {
                row_obj[field.name()] = row.getString(j);
            }
        }

        result.push_back(row_obj);
    }

    return result;
}
```

### 与 HTTP 服务器集成

```cpp
// 使用 galay-http
#include <galay-http/server/HttpServer.h>

Coroutine handleRequest(HttpRequest& req, HttpResponse& resp,
                        MysqlConnectionPool& pool) {
    auto client = co_await pool.acquire();

    auto& query_aw = client->query("SELECT * FROM users");
    auto res = co_await query_aw;

    if (res && res->has_value()) {
        nlohmann::json json = resultSetToJson(res->value());
        resp.setBody(json.dump());
        resp.setHeader("Content-Type", "application/json");
    } else {
        resp.setStatus(500);
        resp.setBody("Database error");
    }

    pool.release(client);
}
```

## 迁移指南

### 从 libmysqlclient 迁移

```cpp
// libmysqlclient
MYSQL* conn = mysql_init(NULL);
mysql_real_connect(conn, "host", "user", "pass", "db", 3306, NULL, 0);
MYSQL_RES* result = mysql_query(conn, "SELECT * FROM users");
// ...
mysql_free_result(result);
mysql_close(conn);

// galay-mysql 同步版本
MysqlClient session;
session.connect("host", 3306, "user", "pass", "db");
auto result = session.query("SELECT * FROM users");
// ...
session.close();
```

### 从 MySQL Connector/C++ 迁移

```cpp
// MySQL Connector/C++
sql::Driver* driver = get_driver_instance();
sql::Connection* con = driver->connect("tcp://host:3306", "user", "pass");
con->setSchema("db");
sql::Statement* stmt = con->createStatement();
sql::ResultSet* res = stmt->executeQuery("SELECT * FROM users");
// ...
delete res;
delete stmt;
delete con;

// galay-mysql 同步版本
MysqlClient session;
session.connect("host", 3306, "user", "pass", "db");
auto res = session.query("SELECT * FROM users");
// ...
session.close();
```
