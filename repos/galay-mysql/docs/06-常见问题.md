# 06-常见问题

## 编译相关

### Q: 编译时找不到 galay-kernel 头文件

**A:** 确保 CMake 能找到依赖库，使用 `CMAKE_PREFIX_PATH` 指定：

```bash
cmake -S . -B build \
  -DCMAKE_PREFIX_PATH="/path/to/galay-kernel;/path/to/galay-utils"
```

或者设置环境变量：

```bash
export CMAKE_PREFIX_PATH="/path/to/galay-kernel:/path/to/galay-utils"
cmake -S . -B build
```

### Q: 链接时出现 undefined reference 错误

**A:** 检查链接库是否完整：

```cmake
target_link_libraries(your_target PRIVATE
    galay-mysql
    galay-kernel
    OpenSSL::SSL
    OpenSSL::Crypto
    spdlog::spdlog
)
```

### Q: import 编译失败

**A:** import 编译有严格的工具链要求：

- Linux 系统
- CMake >= 3.28
- Ninja 或 Visual Studio 生成器
- GCC >= 14

不满足条件时会自动降级到 include 路径。检查工具链版本：

```bash
cmake --version
g++ --version
ninja --version
```

### Q: 编译时出现 C++23 特性不支持

**A:** 确保编译器支持 C++23：

```bash
# GCC
g++ --version  # 需要 >= 13

# Clang
clang++ --version  # 需要 >= 16
```

在 CMakeLists.txt 中显式指定：

```cmake
set(CMAKE_CXX_STANDARD 23)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
```

## 连接相关

### Q: 连接失败：Connection refused

**A:** 检查以下几点：

1. MySQL 服务是否运行：
   ```bash
   systemctl status mysql
   # 或
   ps aux | grep mysqld
   ```

2. 端口是否正确（默认 3306）：
   ```bash
   netstat -tlnp | grep 3306
   ```

3. 防火墙是否允许连接：
   ```bash
   sudo ufw allow 3306
   ```

4. MySQL 是否允许远程连接（检查 bind-address）：
   ```bash
   # /etc/mysql/mysql.conf.d/mysqld.cnf
   bind-address = 0.0.0.0  # 允许所有 IP
   ```

### Q: 连接失败：Access denied for user

**A:** 检查用户权限：

```sql
-- 查看用户权限
SHOW GRANTS FOR 'username'@'host';

-- 创建用户并授权
CREATE USER 'username'@'%' IDENTIFIED BY 'password';
GRANT ALL PRIVILEGES ON database.* TO 'username'@'%';
FLUSH PRIVILEGES;
```

### Q: 连接超时

**A:** 调整超时参数：

```cpp
MysqlConfig cfg;
cfg.connect_timeout_ms = 10000;  // 增加到 10 秒

// 异步客户端还可以设置发送/接收超时
AsyncMysqlConfig async_cfg = AsyncMysqlConfig::withTimeout(
    std::chrono::seconds(5),
    std::chrono::seconds(30)
);
```

### Q: 连接一段时间后断开

**A:** MySQL 有 `wait_timeout` 和 `interactive_timeout` 配置，默认 8 小时。解决方案：

1. 使用连接池自动管理连接生命周期
2. 定期 ping 保活：
   ```cpp
   co_await client.ping();
   ```
3. 调整 MySQL 服务器配置：
   ```sql
   SET GLOBAL wait_timeout = 28800;
   SET GLOBAL interactive_timeout = 28800;
   ```

## 查询相关

### Q: 查询返回空结果集

**A:** 检查以下几点：

1. SQL 语句是否正确
2. 数据库中是否有数据
3. 是否选择了正确的数据库：
   ```cpp
   co_await client.useDatabase("correct_db");
   ```

### Q: 查询中文乱码

**A:** 设置正确的字符集：

```cpp
MysqlConfig cfg;
cfg.charset = "utf8mb4";  // 推荐使用 utf8mb4
```

或在连接后执行：

```cpp
co_await client.query("SET NAMES utf8mb4");
```

### Q: 大结果集查询内存占用高

**A:** 优化策略：

1. 使用 LIMIT 分页查询
2. 预留结果集空间：
   ```cpp
   AsyncMysqlConfig cfg;
   cfg.result_row_reserve_hint = 10000;
   ```
3. 考虑使用游标（需要服务端支持）

### Q: 查询速度慢

**A:** 优化建议：

1. 检查是否有索引：
   ```sql
   EXPLAIN SELECT * FROM users WHERE name = 'Alice';
   ```

2. 使用预处理语句减少解析开销
3. 批量操作使用事务
4. 检查网络延迟
5. 调整超时参数避免误判

## 预处理语句相关

### Q: 预处理语句参数类型如何指定？

**A:** 通过 `param_types` 参数指定：

```cpp
std::vector<uint8_t> param_types = {
    static_cast<uint8_t>(MysqlFieldType::LONG),      // 整数
    static_cast<uint8_t>(MysqlFieldType::VAR_STRING) // 字符串
};

co_await client.stmtExecute(stmt_id, params, param_types);
```

如果不指定，默认按字符串处理。

### Q: 预处理语句可以复用吗？

**A:** 可以。预处理一次，执行多次：

```cpp
auto prep = co_await client.prepare("INSERT INTO users(name) VALUES(?)");
uint32_t stmt_id = prep->value().statement_id;

for (const auto& name : names) {
    co_await client.stmtExecute(stmt_id, {name});
}
```

同步客户端需要手动关闭：

```cpp
session.stmtClose(stmt_id);
```

### Q: 预处理语句支持多少个参数？

**A:** 理论上无限制，但受 MySQL 服务器配置影响。通常支持数百个参数。

## 事务相关

### Q: 事务中途失败如何回滚？

**A:** 检查每个操作的返回值，失败时回滚：

```cpp
co_await client.beginTransaction();

auto res1 = co_await client.query("UPDATE ...");
if (!res1 || !res1->has_value()) {
    co_await client.rollback();
    co_return;
}

auto res2 = co_await client.query("INSERT ...");
if (!res2 || !res2->has_value()) {
    co_await client.rollback();
    co_return;
}

co_await client.commit();
```

### Q: 如何处理死锁？

**A:** 检测死锁错误码（1213）并重试：

```cpp
if (err.type() == MYSQL_ERROR_SERVER && err.serverErrno() == 1213) {
    std::cerr << "检测到死锁，重试中...\n";
    // 重试逻辑
}
```

### Q: 事务隔离级别如何设置？

**A:** 通过 SQL 命令设置：

```cpp
co_await client.query("SET TRANSACTION ISOLATION LEVEL READ COMMITTED");
co_await client.beginTransaction();
// ...
co_await client.commit();
```

## 连接池相关

### Q: 连接池大小如何设置？

**A:** 根据并发量设置：

- 低并发（< 10 QPS）：min=2, max=5
- 中等并发（10-100 QPS）：min=5, max=20
- 高并发（> 100 QPS）：min=10, max=50

不要超过 MySQL 服务器的 `max_connections`。

### Q: 连接池满了怎么办？

**A:** `acquire()` 会挂起等待，直到有连接归还。可以：

1. 增加 `max_connections`
2. 优化查询速度，加快连接归还
3. 设置超时避免无限等待

### Q: 忘记归还连接会怎样？

**A:** 连接泄漏，池会逐渐耗尽。建议使用 RAII 封装：

```cpp
class PooledConnection {
    MysqlConnectionPool& pool;
    AsyncMysqlClient* client;
public:
    PooledConnection(MysqlConnectionPool& p, AsyncMysqlClient* c)
        : pool(p), client(c) {}
    ~PooledConnection() { if (client) pool.release(client); }
    AsyncMysqlClient* operator->() { return client; }
};
```

### Q: 连接池中的连接会自动重连吗？

**A:** 当前版本不会自动重连。如果连接断开，需要手动处理：

```cpp
auto client = co_await pool.acquire();
auto res = co_await client->query("...");
if (!res && res.error().type() == MYSQL_ERROR_CONNECTION_CLOSED) {
    // 连接已断开，重新连接
    pool.release(client);
    client = co_await pool.acquire();
}
```

## 异步相关

### Q: 可以并发使用同一个 AsyncMysqlClient 吗？

**A:** 不可以。同一个实例应串行使用。如需并发，使用连接池：

```cpp
// 错误
AsyncMysqlClient client(scheduler);
scheduler->spawn(query1(client));
scheduler->spawn(query2(client));  // 冲突！

// 正确
MysqlConnectionPool pool(scheduler, config, async_config, 5, 20);
scheduler->spawn(query1(pool));
scheduler->spawn(query2(pool));
```

### Q: await_resume 返回的 optional 为什么是空的？

**A:** 表示操作未完成，需要继续 `co_await`：

```cpp
do {
    res = co_await aw;
    if (!res) {
        // 错误
        break;
    }
} while (!res->has_value());  // 未完成，继续等待

// 完成
const auto& value = res->value();
```

### Q: 超时后如何重试？

**A:** 检测超时错误并重新发起请求：

```cpp
auto& query_aw = client.query("SELECT ...");
auto res = co_await query_aw;

if (!res && res.error().type() == MYSQL_ERROR_TIMEOUT) {
    // 重新发起查询
    auto& retry_aw = client.query("SELECT ...");
    res = co_await retry_aw;
}
```

## 同步相关

### Q: 同步客户端会阻塞吗？

**A:** 是的，所有方法都是阻塞的。适合：

- 简单脚本
- 测试代码
- 低并发场景

高并发场景建议使用异步客户端。

### Q: 同步客户端可以设置超时吗？

**A:** 只能设置连接超时：

```cpp
MysqlConfig cfg;
cfg.connect_timeout_ms = 5000;
```

查询超时需要通过 MySQL 服务器配置或 SQL 语句：

```cpp
session.query("SET SESSION max_execution_time = 30000");  // 30 秒
```

## 错误处理相关

### Q: 如何区分不同类型的错误？

**A:** 通过 `MysqlErrorType` 判断：

```cpp
if (!res) {
    auto& err = res.error();
    switch (err.type()) {
        case MYSQL_ERROR_CONNECTION:
            // 网络连接错误
            break;
        case MYSQL_ERROR_AUTH:
            // 认证失败
            break;
        case MYSQL_ERROR_SERVER:
            // SQL 错误，查看 serverErrno()
            std::cerr << "SQL 错误码: " << err.serverErrno() << '\n';
            break;
        case MYSQL_ERROR_TIMEOUT:
            // 超时
            break;
        default:
            // 其他错误
            break;
    }
}
```

### Q: 如何获取详细的错误信息？

**A:** 使用 `message()` 和 `serverErrno()`：

```cpp
std::cerr << "错误类型: " << static_cast<int>(err.type()) << '\n';
std::cerr << "错误消息: " << err.message() << '\n';
if (err.type() == MYSQL_ERROR_SERVER) {
    std::cerr << "服务器错误码: " << err.serverErrno() << '\n';
}
```

## 性能相关

### Q: 如何提升查询性能？

**A:** 优化策略：

1. 使用预处理语句
2. 批量操作使用事务
3. 使用连接池避免频繁建立连接
4. 预留结果集空间
5. 使用零拷贝参数传递
6. 优化 SQL 语句和索引

### Q: 连接建立很慢怎么办？

**A:** 可能原因：

1. DNS 解析慢：使用 IP 地址而非域名
2. 网络延迟高：检查网络连接
3. MySQL 服务器负载高：优化服务器配置
4. 使用连接池预热连接

### Q: 内存占用过高怎么办？

**A:** 优化建议：

1. 减小 `buffer_size`（默认 16KB）
2. 使用 LIMIT 分页查询
3. 及时释放不用的结果集
4. 检查是否有连接泄漏

## 兼容性相关

### Q: 支持哪些 MySQL 版本？

**A:** 支持 MySQL 5.7+ 和 8.0+。理论上也支持 MariaDB，但未充分测试。

### Q: 支持 SSL/TLS 连接吗？

**A:** 当前版本暂不支持，计划在未来版本中添加。

### Q: 支持压缩协议吗？

**A:** 当前版本暂不支持。

### Q: 支持哪些认证插件？

**A:** 支持：

- `mysql_native_password`（MySQL 5.x 默认）
- `caching_sha2_password`（MySQL 8.0 默认）

不支持其他插件（如 `sha256_password`）。

## 调试相关

### Q: 如何启用调试日志？

**A:** 设置 spdlog 日志级别：

```cpp
#include <spdlog/spdlog.h>

int main() {
    spdlog::set_level(spdlog::level::debug);
    // ...
}
```

### Q: 如何查看发送的 SQL 语句？

**A:** 在调用前打印：

```cpp
std::string sql = "SELECT * FROM users";
std::cout << "执行 SQL: " << sql << '\n';
auto res = co_await client.query(sql);
```

或启用 MySQL 服务器的 general log：

```sql
SET GLOBAL general_log = 'ON';
SET GLOBAL general_log_file = '/var/log/mysql/general.log';
```

### Q: 如何分析性能瓶颈？

**A:** 使用计时器：

```cpp
auto start = std::chrono::steady_clock::now();
auto res = co_await client.query("...");
auto end = std::chrono::steady_clock::now();
auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
std::cout << "查询耗时: " << ms.count() << " ms\n";
```

## 其他

### Q: 如何贡献代码？

**A:** 欢迎提交 PR 到 GitHub 仓库：

1. Fork 仓库
2. 创建特性分支
3. 提交代码并编写测试
4. 发起 Pull Request

### Q: 如何报告 Bug？

**A:** 在 GitHub Issues 中提交，包含：

- 复现步骤
- 预期行为和实际行为
- 环境信息（OS、编译器、MySQL 版本）
- 相关日志和错误信息

### Q: 有商业支持吗？

**A:** 当前为开源项目，暂无商业支持。可通过 GitHub Issues 获取社区支持。

### Q: 与 libmysqlclient 相比有什么优势？

**A:**

- 现代 C++ 接口（C++23）
- 基于协程的异步支持
- 类型安全的错误处理（`std::expected`）
- 内置连接池
- 零拷贝参数传递
- 更好的内存管理

### Q: 生产环境可以使用吗？

**A:** 项目处于活跃开发中，建议：

- 充分测试后再用于生产
- 关注 GitHub 更新和 Bug 修复
- 做好错误处理和监控
- 准备降级方案
