# 02-使用示例

## 基础操作

```cpp
Coroutine basicExample(IOScheduler* scheduler)
{
    RedisClient client(scheduler);
    co_await client.connect("127.0.0.1", 6379);

    // String
    co_await client.set("name", "Alice");
    auto r = co_await client.get("name");
    if (r && r.value()) {
        std::cout << r.value().value()[0].toString() << std::endl;
    }

    // Hash
    co_await client.hset("user:1", "name", "Bob");
    co_await client.hset("user:1", "age", "25");
    auto all = co_await client.hgetAll("user:1");

    // List
    co_await client.lpush("queue", "task1");
    co_await client.lpush("queue", "task2");
    auto task = co_await client.rpop("queue");

    // Set
    co_await client.sadd("tags", "cpp");
    co_await client.sadd("tags", "redis");
    auto members = co_await client.smembers("tags");

    // Sorted Set
    co_await client.zadd("leaderboard", 100.0, "player1");
    co_await client.zadd("leaderboard", 200.0, "player2");
    auto top = co_await client.zrange("leaderboard", 0, -1);

    co_await client.close();
}
```

## 超时与重试

```cpp
Coroutine retryExample(IOScheduler* scheduler)
{
    RedisClient client(scheduler);
    co_await client.connect("127.0.0.1", 6379);

    const int max_retries = 3;
    for (int retry = 0; retry < max_retries; ++retry) {
        auto result = co_await client.get("key").timeout(std::chrono::seconds(5));

        if (result && result.value()) {
            // 成功
            break;
        }

        if (!result && result.error().type() == REDIS_ERROR_TYPE_TIMEOUT_ERROR) {
            std::cout << "超时，重试 " << (retry + 1) << "/" << max_retries << std::endl;
            continue;
        }

        // 其他错误，不重试
        std::cerr << "错误: " << result.error().message() << std::endl;
        break;
    }

    co_await client.close();
}
```

## Pipeline 批处理

```cpp
Coroutine pipelineExample(IOScheduler* scheduler)
{
    RedisClient client(scheduler);
    co_await client.connect("127.0.0.1", 6379);

    // 基本 Pipeline
    std::vector<std::vector<std::string>> commands = {
        {"SET", "user:1:name", "Alice"},
        {"SET", "user:1:age", "25"},
        {"GET", "user:1:name"},
        {"GET", "user:1:age"}
    };

    auto result = co_await client.pipeline(commands).timeout(std::chrono::seconds(10));
    if (result && result.value()) {
        auto& values = result.value().value();
        for (size_t i = 0; i < values.size(); ++i) {
            if (values[i].isString()) {
                std::cout << "Response " << i << ": " << values[i].toString() << std::endl;
            }
        }
    }

    // 分批处理大量数据
    const int total = 10000;
    const int batch_size = 100;

    for (int start = 0; start < total; start += batch_size) {
        std::vector<std::vector<std::string>> batch;
        for (int i = start; i < start + batch_size && i < total; ++i) {
            batch.push_back({"SET", "item:" + std::to_string(i), "val_" + std::to_string(i)});
        }
        co_await client.pipeline(batch).timeout(std::chrono::seconds(10));
    }

    co_await client.close();
}
```

## 并发客户端

```cpp
Coroutine worker(IOScheduler* scheduler, int id, int tasks)
{
    RedisClient client(scheduler);
    co_await client.connect("127.0.0.1", 6379);

    for (int i = 0; i < tasks; ++i) {
        std::string key = "worker:" + std::to_string(id) + ":" + std::to_string(i);
        co_await client.set(key, "value").timeout(std::chrono::seconds(5));
    }

    co_await client.close();
}

int main()
{
    Runtime runtime;
    runtime.start();

    auto* scheduler = runtime.getNextIOScheduler();

    // 启动 10 个并发客户端
    for (int i = 0; i < 10; ++i) {
        scheduler->spawn(worker(scheduler, i, 100));
    }

    std::this_thread::sleep_for(std::chrono::seconds(30));
    runtime.stop();
    return 0;
}
```

## Pub/Sub

```cpp
Coroutine pubsubExample(IOScheduler* scheduler)
{
    RedisClient sub(scheduler);
    RedisClient pub(scheduler);

    co_await sub.connect("127.0.0.1", 6379);
    co_await pub.connect("127.0.0.1", 6379);

    // 订阅
    co_await sub.subscribe("news");

    // 发布
    co_await pub.publish("news", "hello world");

    // 接收消息
    auto msg = co_await sub.receive();

    co_await sub.close();
    co_await pub.close();
}
```

## 连接池

```cpp
Coroutine poolExample(IOScheduler* scheduler)
{
    // 创建连接池
    auto config = ConnectionPoolConfig::create("127.0.0.1", 6379, 2, 10);
    RedisConnectionPool pool(scheduler, config);

    auto init = co_await pool.initialize().timeout(std::chrono::seconds(5));
    if (!init) {
        std::cerr << "连接池初始化失败" << std::endl;
        co_return;
    }

    // 获取连接
    auto conn_result = co_await pool.acquire().timeout(std::chrono::seconds(2));
    if (!conn_result) {
        std::cerr << "获取连接失败" << std::endl;
        co_return;
    }

    // RAII 风格：离开作用域自动归还
    {
        ScopedConnection scoped(pool, conn_result.value());
        co_await scoped->set("key", "value");
        auto r = co_await scoped->get("key");
    }

    // 查看统计
    auto stats = pool.getStats();
    std::cout << "总连接: " << stats.total_connections << std::endl;
    std::cout << "可用: " << stats.available_connections << std::endl;
    std::cout << "活跃: " << stats.active_connections << std::endl;

    pool.shutdown();
}
```

## 主从读写分离

```cpp
Coroutine masterSlaveExample(IOScheduler* scheduler)
{
    RedisMasterSlaveClient ms(scheduler);

    RedisNodeAddress master{"127.0.0.1", 6379};
    RedisNodeAddress replica{"127.0.0.1", 6380};

    co_await ms.connectMaster(master);
    co_await ms.addReplica(replica);

    // 写操作走主库
    co_await ms.executeWrite("SET", {"key", "value"});

    // 读操作走从库（轮询）
    auto r = co_await ms.executeRead("GET", {"key"});

    // 自动模式：主库不可用时触发重试
    auto w = co_await ms.executeWriteAuto("SET", {"k", "v"}).timeout(std::chrono::seconds(5));
    auto rd = co_await ms.executeReadAuto("GET", {"k"}).timeout(std::chrono::seconds(5));
}
```

## Sentinel 自动故障转移

```cpp
Coroutine sentinelExample(IOScheduler* scheduler)
{
    RedisMasterSlaveClient ms(scheduler);
    ms.setSentinelMasterName("mymaster");

    RedisNodeAddress sentinel{"127.0.0.1", 26379};
    co_await ms.addSentinel(sentinel);

    // 从 Sentinel 自动发现主从拓扑
    co_await ms.refreshFromSentinel().timeout(std::chrono::seconds(5));

    // 自动写入：主库不可用时触发 Sentinel 刷新并重试
    auto w = co_await ms.executeWriteAuto("SET", {"k", "v"}).timeout(std::chrono::seconds(5));
    auto r = co_await ms.executeReadAuto("GET", {"k"}).timeout(std::chrono::seconds(5));
}
```

## Cluster 集群

```cpp
Coroutine clusterExample(IOScheduler* scheduler)
{
    RedisClusterClient cluster(scheduler);

    RedisClusterNodeAddress n1;
    n1.host = "127.0.0.1"; n1.port = 7000;
    n1.slot_start = 0; n1.slot_end = 8191;

    RedisClusterNodeAddress n2;
    n2.host = "127.0.0.1"; n2.port = 7001;
    n2.slot_start = 8192; n2.slot_end = 16383;

    co_await cluster.addNode(n1);
    co_await cluster.addNode(n2);

    // 按 key 自动路由到对应 slot 的节点
    co_await cluster.executeByKey("{u100}:name", "SET", {"{u100}:name", "alice"});
    auto v = co_await cluster.executeByKey("{u100}:name", "GET", {"{u100}:name"});

    // 自动模式：遇到 MOVED/ASK 自动重定向，并刷新 slots
    cluster.setAutoRefreshInterval(std::chrono::seconds(5));

    auto r = co_await cluster.executeByKeyAuto("{u300}:name", "SET", {"{u300}:name", "bob"})
                             .timeout(std::chrono::seconds(5));
}
```

## 实战：会话管理

```cpp
class SessionManager
{
public:
    SessionManager(IOScheduler* scheduler) : m_client(scheduler) {}

    Coroutine init(const std::string& host, int port)
    {
        co_await m_client.connect(host, port);
    }

    Coroutine createSession(const std::string& user_id, const std::string& token)
    {
        co_await m_client.setex("session:" + user_id, 3600, token)
                         .timeout(std::chrono::seconds(5));
    }

    Coroutine validateSession(const std::string& user_id)
    {
        auto r = co_await m_client.get("session:" + user_id)
                                  .timeout(std::chrono::seconds(2));
        if (r && r.value()) {
            auto& vals = r.value().value();
            if (!vals.empty() && vals[0].isString()) {
                co_return std::optional<std::string>(vals[0].toString());
            }
        }
        co_return std::optional<std::string>();
    }

    Coroutine deleteSession(const std::string& user_id)
    {
        co_await m_client.del("session:" + user_id).timeout(std::chrono::seconds(2));
    }

private:
    RedisClient m_client;
};
```

## 实战：排行榜

```cpp
class Leaderboard
{
public:
    Leaderboard(IOScheduler* scheduler) : m_client(scheduler) {}

    Coroutine init(const std::string& host, int port)
    {
        co_await m_client.connect(host, port);
    }

    Coroutine updateScore(const std::string& board, const std::string& player, double score)
    {
        co_await m_client.zadd(board, score, player).timeout(std::chrono::seconds(2));
    }

    Coroutine getTopPlayers(const std::string& board, int count)
    {
        auto r = co_await m_client.zrange(board, 0, count - 1)
                                  .timeout(std::chrono::seconds(5));
        std::vector<std::string> players;
        if (r && r.value()) {
            for (const auto& v : r.value().value()) {
                if (v.isString()) players.push_back(v.toString());
            }
        }
        co_return players;
    }

private:
    RedisClient m_client;
};
```
