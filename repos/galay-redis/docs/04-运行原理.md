# 运行原理

## 整体架构

```text
用户协程
  │
  ├── RedisClient / RedisConnectionPool / RedisTopologyClient
  │     │
  │     ├── Awaitable (状态机)
  │     │     ├── await_ready()    → 是否可以立即完成
  │     │     ├── await_suspend()  → 挂起协程，发起异步 IO
  │     │     └── await_resume()   → 恢复协程，返回结果
  │     │
  │     ├── RespEncoder           → 命令编码为 RESP 协议
  │     ├── RespParser            → 解析 RESP 响应
  │     └── RingBuffer            → 收发缓冲区
  │
  ├── galay-kernel (IO 调度器)
  │     ├── IOScheduler           → 事件循环
  │     ├── SendAwaitable         → 异步发送
  │     └── ReadvAwaitable        → 异步接收
  │
  └── 操作系统 (epoll/kqueue)
```

## 协程状态机

每个 Awaitable（RedisClientAwaitable、RedisPipelineAwaitable、RedisConnectAwaitable）内部都是一个状态机：

### RedisClientAwaitable 状态流转

```text
Invalid ──→ Sending ──→ Receiving ──→ Invalid
   │            │            │
   └────────────┴────────────┘
         (错误/超时时直接回到 Invalid)
```

1. `Invalid`：初始/完成状态，Awaitable 可被复用
2. `Sending`：正在发送命令到 Redis
3. `Receiving`：正在接收 Redis 响应

### 执行流程

```cpp
// 用户代码
auto result = co_await client.get("key").timeout(std::chrono::seconds(5));
```

内部流程：

1. `client.get("key")` — 创建 RedisClientAwaitable，编码 `*2\r\n$3\r\nGET\r\n$3\r\nkey\r\n`
2. `.timeout(5s)` — 通过 TimeoutSupport 注册定时器
3. `co_await` 触发 `await_ready()` — 返回 false（需要异步操作）
4. `await_suspend(handle)` — 状态设为 Sending，发起异步发送
5. 内核完成发送 → 状态转为 Receiving → 发起异步接收
6. 内核完成接收 → RespParser 解析响应 → 恢复协程
7. `await_resume()` — 返回 `std::expected<std::optional<std::vector<RedisValue>>, RedisError>`

### RedisConnectAwaitable 状态流转

```text
Invalid ──→ Connecting ──→ Authenticating ──→ SelectingDB ──→ Done
```

连接过程分为多个阶段：TCP 连接 → AUTH 认证（可选）→ SELECT 数据库（可选）。

## 超时机制

超时通过 galay-kernel 的 `TimeoutSupport` 模板实现：

```cpp
class RedisClientAwaitable : public TimeoutSupport<RedisClientAwaitable>
{
public:
    // TimeoutSupport 需要访问此成员来设置超时错误
    std::expected<std::optional<std::vector<RedisValue>>, IOError> m_result;
};
```

工作原理：

1. 调用 `.timeout(duration)` 时，TimeoutSupport 向 IOScheduler 注册一个定时器
2. 如果操作在定时器触发前完成，定时器被取消，正常返回结果
3. 如果定时器先触发，TimeoutSupport 将 `m_result` 设为超时错误（`IOError(kTimeout)`）
4. `await_resume()` 检查 `m_result`，发现超时错误后将 `IOError` 转换为 `RedisError(TIMEOUT_ERROR)`，调用 `reset()` 清理资源

超时检查在 `await_resume()` 的最开头：

```cpp
std::expected<...> RedisClientAwaitable::await_resume()
{
    // 1. 超时检查（由 TimeoutSupport 设置）
    if (!m_result.has_value()) {
        auto& io_error = m_result.error();
        RedisErrorType type;
        if (io_error.code() == kTimeout) {
            type = REDIS_ERROR_TYPE_TIMEOUT_ERROR;
        } else if (io_error.code() == kDisconnectError) {
            type = REDIS_ERROR_TYPE_CONNECTION_CLOSED;
        } else {
            type = REDIS_ERROR_TYPE_RECV_ERROR;
        }
        reset();
        return std::unexpected(RedisError(type, io_error.message()));
    }

    // 2. 正常的发送/接收逻辑...
}
```

正常路径的超时检查开销仅为 1 次条件判断（< 0.1%）。

## RESP 协议编解码

### 编码

RespEncoder 将命令编码为 RESP 格式：

```text
命令: GET mykey
编码: *2\r\n$3\r\nGET\r\n$5\r\nmykey\r\n

命令: SET name Alice
编码: *3\r\n$3\r\nSET\r\n$4\r\nname\r\n$5\r\nAlice\r\n
```

Pipeline 将多条命令的编码拼接后一次性发送，减少网络往返。

### 解码

RespParser 解析 Redis 响应，支持 RESP2 和 RESP3 的所有类型：

| 前缀 | 类型 | 示例 |
|------|------|------|
| `+` | Simple String | `+OK\r\n` |
| `-` | Error | `-ERR unknown command\r\n` |
| `:` | Integer | `:1000\r\n` |
| `$` | Bulk String | `$5\r\nhello\r\n` |
| `*` | Array | `*2\r\n$3\r\nfoo\r\n$3\r\nbar\r\n` |
| `,` | Double (RESP3) | `,3.14\r\n` |
| `#` | Boolean (RESP3) | `#t\r\n` |
| `%` | Map (RESP3) | `%2\r\n...` |

## 连接池原理

### 连接生命周期

```text
创建 ──→ 空闲（池中等待） ──→ 活跃（被获取使用） ──→ 归还（回到空闲）
  │                                                      │
  └──── 销毁 ←── 不健康/超时/缩容 ←──────────────────────┘
```

### 获取连接流程

1. 检查空闲连接队列，有则直接返回
2. 如果当前连接数 < max_connections，创建新连接
3. 如果已达上限，等待其他协程归还连接（受 acquire_timeout 限制）
4. 如果启用了 validate_on_acquire，获取后先 PING 验证

### 健康检查

定期对空闲连接发送 PING 命令，移除无响应的连接。通过 `triggerHealthCheck()` 手动触发或配置自动间隔。

## 拓扑路由原理

### 主从读写分离

- 写操作始终发往 master 节点
- 读操作在 replica 节点间轮询（Round-Robin）
- Auto 模式下，操作失败时自动重试，如果配置了 Sentinel 则刷新拓扑后重试

### Cluster Slot 路由

1. 计算 key 的 CRC16 哈希值，对 16384 取模得到 slot
2. 查找 slot 对应的节点，发送命令
3. 如果收到 MOVED 响应，更新 slot 映射并重定向到正确节点
4. 如果收到 ASK 响应，向目标节点发送 ASKING + 原命令
5. 可配置定时刷新 CLUSTER SLOTS 以保持映射最新

### Hash Tag

Cluster 模式下，key 中 `{...}` 内的部分用于计算 slot，确保相关 key 落在同一节点：

```cpp
// {u100}:name 和 {u100}:age 的 slot 相同，都基于 "u100" 计算
cluster.executeByKey("{u100}:name", "SET", {"{u100}:name", "alice"});
cluster.executeByKey("{u100}:age", "SET", {"{u100}:age", "25"});
```

## 资源管理

### Awaitable 复用

每个 RedisClient 内部持有 `std::optional<RedisClientAwaitable>` 等成员。调用命令方法时：

- 如果 Awaitable 不存在或处于 Invalid 状态，创建新的（`emplace`）
- 操作完成后，`reset()` 将状态重置为 Invalid，清理内部资源

### reset() 方法

```cpp
void RedisClientAwaitable::reset() noexcept
{
    m_state = State::Invalid;
    m_send_awaitable.reset();
    m_recv_awaitable.reset();
    m_values.clear();
    m_sent = 0;
    m_result = std::nullopt;
}
```

无论操作成功、失败还是超时，`reset()` 都会被调用，确保不会泄漏资源。

### 移动语义

RedisClient 支持移动构造和移动赋值，但不支持拷贝。移动时所有 Awaitable 必须处于 Invalid 状态，不要在操作进行中移动 RedisClient。
