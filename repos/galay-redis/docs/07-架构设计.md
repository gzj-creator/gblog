# 07-架构设计

## 整体分层

galay-redis 采用分层实现：

```text
Application
  ├─ Async API (RedisClient / RedisConnectionPool / RedisTopologyClient)
  └─ Sync API  (RedisSession)
        ↓
Protocol (RespEncoder / RespParser)
        ↓
Base (RedisValue / RedisError / RedisConfig)
        ↓
Galay-Kernel (Runtime / IOScheduler / TcpSocket / CustomAwaitable)
```

## 模块职责

### Base

- `RedisValue`：封装 RESP2/RESP3 响应值
- `RedisError`：统一错误模型
- `RedisConfig`：连接配置
- `RedisLog`：日志工具

### Protocol

- `RespEncoder`：将命令编码为 RESP 协议格式
- `RespParser`：解析 Redis 响应
- `Connection`：同步阻塞连接封装

### Async

- `RedisClient`：异步客户端
- `RedisConnectionPool`：连接池
- `RedisTopologyClient`：拓扑客户端（主从/集群）
- `AsyncRedisConfig`：异步配置参数

### Sync

- `RedisSession`：同步阻塞接口

## 异步链式 Awaitable

异步路径基于 `galay::kernel::CustomAwaitable`，通过组合 `Send` / `Recv` 子 Awaitable 构成协议链。

### Connect 流程

`RedisConnectAwaitable` 链路：

```text
CONNECT -> AUTH (可选) -> SELECT (可选) -> Done
```

状态机：

```text
Invalid -> Connecting -> Authenticating -> SelectingDB -> Done
```

### Command 流程

`RedisClientAwaitable` 链路：

```text
SEND(Command) -> RECV(Response) -> Done
```

状态机：

```text
Invalid -> Running (SEND -> RECV) -> Invalid
```

内部流程：

1. `await_ready()`：返回 false（需要异步操作）
2. `await_suspend()`：状态设为 Running，发起异步发送
3. 内核完成发送 → 发起异步接收
4. 内核完成接收 → RespParser 解析响应 → 恢复协程
5. `await_resume()`：返回结果或错误

### Pipeline 流程

`RedisPipelineAwaitable` 链路：

```text
SEND(All Commands) -> RECV(All Responses) -> Done
```

Pipeline 将多条命令的编码拼接后一次性发送，然后依次接收所有响应，减少网络往返。

## Await 返回语义

异步接口返回值统一是 `std::expected<std::optional<std::vector<RedisValue>>, RedisError>`：

- `!expected`：出错，`expected.error()` 为错误详情
- `expected && !expected->has_value()`：流程未完成，需要继续 `co_await`
- `expected && expected->has_value()`：流程完成，`expected->value()` 为结果

该语义用于 `connect/command/pipeline/acquire`。

## 超时机制

超时通过 galay-kernel 的 `TimeoutSupport` 模板实现：

```cpp
class RedisClientAwaitable : public TimeoutSupport<RedisClientAwaitable>
{
public:
    std::expected<std::optional<std::vector<RedisValue>>, IOError> m_result;
};
```

工作原理：

1. 调用 `.timeout(duration)` 时，TimeoutSupport 向 IOScheduler 注册一个定时器
2. 如果操作在定时器触发前完成，定时器被取消，正常返回结果
3. 如果定时器先触发，TimeoutSupport 将 `m_result` 设为超时错误（`IOError(kTimeout)`）
4. `await_resume()` 检查 `m_result`，发现超时错误后将 `IOError` 转换为 `RedisError(TIMEOUT_ERROR)`，调用 `reset()` 清理资源

超时检查在 `await_resume()` 的最开头：

```cpp
std::expected<...> RedisClientAwaitable::await_resume()
{
    // 1. 超时检查（由 TimeoutSupport 设置）
    if (!m_result.has_value()) {
        auto& io_error = m_result.error();
        RedisErrorType type;
        if (io_error.code() == kTimeout) {
            type = REDIS_ERROR_TYPE_TIMEOUT_ERROR;
        } else if (io_error.code() == kDisconnectError) {
            type = REDIS_ERROR_TYPE_CONNECTION_CLOSED;
        } else {
            type = REDIS_ERROR_TYPE_RECV_ERROR;
        }
        reset();
        return std::unexpected(RedisError(type, io_error.message()));
    }

    // 2. 正常的发送/接收逻辑...
}
```

正常路径的超时检查开销仅为 1 次条件判断（< 0.1%）。

## RESP 协议编解码

### 编码

RespEncoder 将命令编码为 RESP 格式：

```text
命令: GET mykey
编码: *2\r\n$3\r\nGET\r\n$5\r\nmykey\r\n

命令: SET name Alice
编码: *3\r\n$3\r\nSET\r\n$4\r\nname\r\n$5\r\nAlice\r\n
```

Pipeline 将多条命令的编码拼接后一次性发送，减少网络往返。

### 解码

RespParser 解析 Redis 响应，支持 RESP2 和 RESP3 的所有类型：

| 前缀 | 类型 | 示例 |
|------|------|------|
| `+` | Simple String | `+OK\r\n` |
| `-` | Error | `-ERR unknown command\r\n` |
| `:` | Integer | `:1000\r\n` |
| `$` | Bulk String | `$5\r\nhello\r\n` |
| `*` | Array | `*2\r\n$3\r\nfoo\r\n$3\r\nbar\r\n` |
| `,` | Double (RESP3) | `,3.14\r\n` |
| `#` | Boolean (RESP3) | `#t\r\n` |
| `%` | Map (RESP3) | `%2\r\n...` |
| `~` | Set (RESP3) | `~2\r\n...` |
| `>` | Push (RESP3) | `>3\r\n...` |

## 连接池设计

### 连接生命周期

```text
创建 -> 空闲（池中等待） -> 活跃（被获取使用） -> 归还（回到空闲）
  │                                                      │
  └──── 销毁 ← 不健康/超时/缩容 ←──────────────────────┘
```

### 获取连接流程

1. 检查空闲连接队列，有则直接返回
2. 如果当前连接数 < max_connections，创建新连接并完成握手
3. 如果已达上限，等待其他协程归还连接（受 acquire_timeout 限制）
4. 如果启用了 validate_on_acquire，获取后先 PING 验证

### 健康检查

定期对空闲连接发送 PING 命令，移除无响应的连接。通过 `triggerHealthCheck()` 手动触发或配置自动间隔。

### 连接池并发

连接池内部使用队列管理空闲连接和等待协程，通过 `acquire/release` 实现安全的并发访问。

## 拓扑路由原理

### 主从读写分离

- 写操作始终发往 master 节点
- 读操作在 replica 节点间轮询（Round-Robin）
- Auto 模式下，操作失败时自动重试，如果配置了 Sentinel 则刷新拓扑后重试

### Sentinel 故障转移

1. 配置 Sentinel 节点和 master 名称
2. 调用 `refreshFromSentinel()` 从 Sentinel 获取当前主从拓扑
3. Sentinel 返回 master 地址和 replica 列表
4. 更新内部拓扑映射
5. Auto 模式下，主库不可用时自动触发 Sentinel 刷新并重试

### Cluster Slot 路由

1. 计算 key 的 CRC16 哈希值，对 16384 取模得到 slot
2. 查找 slot 对应的节点，发送命令
3. 如果收到 MOVED 响应，更新 slot 映射并重定向到正确节点
4. 如果收到 ASK 响应，向目标节点发送 ASKING + 原命令
5. 可配置定时刷新 CLUSTER SLOTS 以保持映射最新

### Hash Tag

Cluster 模式下，key 中 `{...}` 内的部分用于计算 slot，确保相关 key 落在同一节点：

```cpp
// {u100}:name 和 {u100}:age 的 slot 相同，都基于 "u100" 计算
cluster.executeByKey("{u100}:name", "SET", {"{u100}:name", "alice"});
cluster.executeByKey("{u100}:age", "SET", {"{u100}:age", "25"});
```

## 资源管理

### Awaitable 复用

每个 RedisClient 内部持有 `std::optional<RedisClientAwaitable>` 等成员。调用命令方法时：

- 如果 Awaitable 不存在或处于 Invalid 状态，创建新的（`emplace`）
- 操作完成后，`reset()` 将状态重置为 Invalid，清理内部资源

### reset() 方法

```cpp
void RedisClientAwaitable::reset() noexcept
{
    m_state = State::Invalid;
    m_send_awaitable.rebind(this);
    m_recv_awaitable.rebind(this);
    m_values.clear();
    m_parse_buffer.clear();
    m_internal_error.reset();
    m_result = std::nullopt;
}
```

无论操作成功、失败还是超时，`reset()` 都会被调用，确保不会泄漏资源。

### 移动语义

RedisClient 支持移动构造和移动赋值，但不支持拷贝。移动时所有 Awaitable 必须处于 Invalid 状态，不要在操作进行中移动 RedisClient。

## 内存管理

### RingBuffer 复用

异步客户端使用 `RingBuffer` 作为接收缓冲区，避免频繁分配。缓冲区大小可配置（默认 16KB）。

### 零拷贝解析

RespParser 直接在 RingBuffer 上解析，避免额外的内存拷贝。解析完成后，数据被移动到 RedisValue 中。

### 缓存机制

RedisValue 内部缓存 `toArray()` 和 `toMap()` 的转换结果，避免重复转换：

```cpp
class RedisValue {
private:
    mutable std::vector<RedisValue> m_cached_array;
    mutable std::map<std::string, RedisValue> m_cached_map;
    mutable bool m_array_cached = false;
    mutable bool m_map_cached = false;
};
```

## 并发模型

### 异步路径

基于 `galay::kernel::IOScheduler` 的协程调度，单个客户端实例串行执行命令，多个客户端实例可并发运行在不同协程中。

### 连接池并发

连接池内部使用队列管理空闲连接和等待协程，通过 `acquire/release` 实现安全的并发访问。

### 同步路径

使用阻塞 socket，适合单线程或简单场景，不涉及协程调度。

## 性能考量

### Pipeline 批处理

Pipeline 将多条命令一次性发送，减少网络往返：

```cpp
std::vector<std::vector<std::string>> commands = {
    {"SET", "k1", "v1"},
    {"SET", "k2", "v2"},
    {"GET", "k1"},
    {"GET", "k2"}
};
auto result = co_await client.pipeline(commands);
```

### 连接池大小

- `min_connections`：预热连接数，避免冷启动延迟
- `max_connections`：峰值并发数，需根据 Redis 服务器配置和负载调整

### 超时设置

合理设置超时参数，避免无限等待：

```cpp
// 短超时用于快速失败
auto r = co_await client.get("key").timeout(std::chrono::seconds(1));

// 长超时用于慢查询
auto r = co_await client.keys("*").timeout(std::chrono::seconds(30));
```

## 线程安全

- `RedisClient`：非线程安全，应在单个协程中使用
- `RedisSession`：非线程安全，应在单个线程中使用
- `RedisConnectionPool`：内部线程安全，可从多个协程并发调用 `acquire/release`

## 错误模型

全部接口使用 `std::expected`，错误分类由 `RedisErrorType` 提供（连接、超时、协议、发送、接收等）。

相较异常，错误路径更可控，便于高并发场景下统一日志与重试策略。

## 关键约束

- 同一个 `RedisClient` 实例应串行执行请求，不建议并发复用同一个实例发起多条异步命令
- 连接池返回的是 `PooledConnection*`，需要显式 `release()` 归还
- 生产环境建议设置超时参数，避免无限等待
- `RedisValue` 的 `toArray()`、`toMap()` 返回的容器生命周期不能超过 RedisValue 本身

## 协议细节

### 认证流程

支持密码认证和用户名+密码认证（Redis 6.0+）：

```cpp
// 仅密码
co_await client.connect("127.0.0.1", 6379, "", "password");

// 用户名+密码
co_await client.connect("127.0.0.1", 6379, "username", "password");
```

### 数据库选择

连接时可指定数据库索引：

```cpp
co_await client.connect("127.0.0.1", 6379, "", "", 1);  // 选择 DB 1
```

### URL 连接

支持 Redis URL 格式：

```cpp
co_await client.connect("redis://:password@127.0.0.1:6379/0");
co_await client.connect("redis://username:password@127.0.0.1:6379/1");
```

## 扩展性

### 自定义命令

通过 `execute()` 方法执行任意命令：

```cpp
auto result = co_await client.execute("CUSTOM_CMD", {"arg1", "arg2"});
```

### 协议扩展

RespParser 支持 RESP3 的所有类型，可以处理未来的协议扩展。

### 拓扑扩展

拓扑客户端设计为可扩展，可以添加新的路由策略（如一致性哈希、权重轮询等）。
