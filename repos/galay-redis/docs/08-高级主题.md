# 08-高级主题

## 性能优化

### 1. Pipeline 批处理

Pipeline 是提升性能的最有效手段，可将多条命令一次性发送，减少网络往返：

```cpp
Coroutine pipelineOptimization(IOScheduler* scheduler)
{
    RedisClient client(scheduler);
    co_await client.connect("127.0.0.1", 6379);

    // 低效：逐条发送
    for (int i = 0; i < 1000; ++i) {
        co_await client.set("key:" + std::to_string(i), "value");
    }

    // 高效：批量发送
    std::vector<std::vector<std::string>> commands;
    for (int i = 0; i < 1000; ++i) {
        commands.push_back({"SET", "key:" + std::to_string(i), "value"});
    }
    co_await client.pipeline(commands).timeout(std::chrono::seconds(10));

    co_await client.close();
}
```

**性能对比**：

- 逐条发送：~10,000 QPS
- Pipeline (batch=100)：~1,000,000 QPS

### 2. 连接池配置

连接池的大小直接影响并发性能：

```cpp
// 低并发场景（< 10 QPS）
auto config = ConnectionPoolConfig::create("127.0.0.1", 6379, 2, 5);

// 中等并发场景（10-100 QPS）
auto config = ConnectionPoolConfig::create("127.0.0.1", 6379, 5, 20);

// 高并发场景（> 100 QPS）
auto config = ConnectionPoolConfig::create("127.0.0.1", 6379, 10, 50);
```

**原则**：

- `min_connections` 应覆盖平均并发数
- `max_connections` 应覆盖峰值并发数
- 不要超过 Redis 服务器的 `maxclients` 配置

### 3. 超时设置

合理设置超时参数，避免无限等待：

```cpp
// 快速操作：短超时
auto r = co_await client.get("key").timeout(std::chrono::seconds(1));

// 慢查询：长超时
auto r = co_await client.keys("*").timeout(std::chrono::seconds(30));

// Pipeline：根据批量大小调整
auto r = co_await client.pipeline(commands).timeout(std::chrono::seconds(10));
```

### 4. 连接复用

使用连接池避免频繁建立连接的开销：

```cpp
// 低效：每次创建新连接
Coroutine worker(IOScheduler* scheduler)
{
    RedisClient client(scheduler);
    co_await client.connect("127.0.0.1", 6379);
    co_await client.set("key", "value");
    co_await client.close();
}

// 高效：使用连接池
Coroutine worker(IOScheduler* scheduler, RedisConnectionPool& pool)
{
    auto conn_result = co_await pool.acquire();
    if (conn_result && conn_result.value()) {
        ScopedConnection scoped(pool, conn_result.value());
        co_await scoped->set("key", "value");
    }
}
```

### 5. 预热连接池

在服务启动时预热连接池，避免冷启动延迟：

```cpp
RedisConnectionPool pool(scheduler, config);
co_await pool.initialize().timeout(std::chrono::seconds(5));
pool.warmup();  // 预热到最小连接数
```

## 连接池高级用法

### 动态扩缩容

```cpp
// 手动扩容
pool.expandPool(5);  // 增加 5 个连接

// 手动缩容
pool.shrinkPool(10);  // 缩减到 10 个连接
```

### 健康检查

```cpp
// 配置自动健康检查
ConnectionPoolConfig config;
config.enable_health_check = true;
config.health_check_interval = std::chrono::seconds(30);

// 手动触发健康检查
pool.triggerHealthCheck();

// 清理不健康连接
pool.cleanupUnhealthyConnections();
```

### 空闲连接清理

```cpp
// 配置空闲超时
ConnectionPoolConfig config;
config.idle_timeout = std::chrono::minutes(5);

// 手动触发清理
pool.triggerIdleCleanup();
```

### 连接验证

```cpp
// 配置连接验证
ConnectionPoolConfig config;
config.validate_on_acquire = true;   // 获取时验证（性能开销大）
config.validate_on_return = false;   // 归还时验证
```

### 统计信息

```cpp
auto stats = pool.getStats();
std::cout << "总连接: " << stats.total_connections << '\n';
std::cout << "可用: " << stats.available_connections << '\n';
std::cout << "活跃: " << stats.active_connections << '\n';
std::cout << "峰值活跃: " << stats.peak_active_connections << '\n';
std::cout << "平均获取时间: " << stats.avg_acquire_time_ms << " ms\n";
std::cout << "最大获取时间: " << stats.max_acquire_time_ms << " ms\n";
std::cout << "健康检查失败: " << stats.health_check_failures << '\n';
std::cout << "重连尝试: " << stats.reconnect_attempts << '\n';
```

## 主从读写分离

### 基本用法

```cpp
Coroutine masterSlaveExample(IOScheduler* scheduler)
{
    RedisMasterSlaveClient ms(scheduler);

    // 配置主从节点
    RedisNodeAddress master{"127.0.0.1", 6379};
    RedisNodeAddress replica1{"127.0.0.1", 6380};
    RedisNodeAddress replica2{"127.0.0.1", 6381};

    co_await ms.connectMaster(master);
    co_await ms.addReplica(replica1);
    co_await ms.addReplica(replica2);

    // 写操作走主库
    co_await ms.executeWrite("SET", {"key", "value"});

    // 读操作走从库（轮询）
    auto r1 = co_await ms.executeRead("GET", {"key"});
    auto r2 = co_await ms.executeRead("GET", {"key"});  // 可能路由到不同从库
}
```

### 自动故障转移

```cpp
Coroutine autoFailover(IOScheduler* scheduler)
{
    RedisMasterSlaveClient ms(scheduler);

    // 配置主从节点
    co_await ms.connectMaster(master);
    co_await ms.addReplica(replica);

    // 自动模式：主库不可用时触发重试
    auto w = co_await ms.executeWriteAuto("SET", {"k", "v"})
                        .timeout(std::chrono::seconds(5));

    if (!w) {
        std::cerr << "写入失败: " << w.error().message() << '\n';
    }
}
```

### Sentinel 集成

```cpp
Coroutine sentinelExample(IOScheduler* scheduler)
{
    RedisMasterSlaveClient ms(scheduler);

    // 配置 Sentinel
    ms.setSentinelMasterName("mymaster");
    RedisNodeAddress sentinel1{"127.0.0.1", 26379};
    RedisNodeAddress sentinel2{"127.0.0.1", 26380};
    co_await ms.addSentinel(sentinel1);
    co_await ms.addSentinel(sentinel2);

    // 从 Sentinel 自动发现主从拓扑
    co_await ms.refreshFromSentinel().timeout(std::chrono::seconds(5));

    // 自动写入：主库不可用时触发 Sentinel 刷新并重试
    auto w = co_await ms.executeWriteAuto("SET", {"k", "v"})
                        .timeout(std::chrono::seconds(5));
}
```

## Cluster 集群

### 基本用法

```cpp
Coroutine clusterExample(IOScheduler* scheduler)
{
    RedisClusterClient cluster(scheduler);

    // 配置集群节点
    RedisClusterNodeAddress n1;
    n1.host = "127.0.0.1";
    n1.port = 7000;
    n1.slot_start = 0;
    n1.slot_end = 8191;

    RedisClusterNodeAddress n2;
    n2.host = "127.0.0.1";
    n2.port = 7001;
    n2.slot_start = 8192;
    n2.slot_end = 16383;

    co_await cluster.addNode(n1);
    co_await cluster.addNode(n2);

    // 按 key 自动路由到对应 slot 的节点
    co_await cluster.executeByKey("user:100", "SET", {"user:100", "alice"});
    auto v = co_await cluster.executeByKey("user:100", "GET", {"user:100"});
}
```

### Hash Tag

使用 Hash Tag 确保相关 key 落在同一节点：

```cpp
// {u100}:name 和 {u100}:age 的 slot 相同，都基于 "u100" 计算
co_await cluster.executeByKey("{u100}:name", "SET", {"{u100}:name", "alice"});
co_await cluster.executeByKey("{u100}:age", "SET", {"{u100}:age", "25"});

// 可以在同一个节点上操作相关 key
co_await cluster.executeByKey("{u100}:name", "SET", {"{u100}:name", "bob"});
co_await cluster.executeByKey("{u100}:age", "SET", {"{u100}:age", "30"});
```

### 自动重定向

```cpp
Coroutine autoRedirect(IOScheduler* scheduler)
{
    RedisClusterClient cluster(scheduler);

    // 配置节点...

    // 自动模式：遇到 MOVED/ASK 自动重定向，并刷新 slots
    cluster.setAutoRefreshInterval(std::chrono::seconds(5));

    auto r = co_await cluster.executeByKeyAuto("key", "SET", {"key", "value"})
                             .timeout(std::chrono::seconds(5));

    if (!r) {
        std::cerr << "操作失败: " << r.error().message() << '\n';
    }
}
```

## 事务

### 基本事务

```cpp
Coroutine transactionExample(IOScheduler* scheduler)
{
    RedisClient client(scheduler);
    co_await client.connect("127.0.0.1", 6379);

    // 开始事务
    co_await client.execute("MULTI", {});

    // 执行命令（命令被排队，不会立即执行）
    co_await client.set("key1", "value1");
    co_await client.set("key2", "value2");
    co_await client.incr("counter");

    // 提交事务
    auto result = co_await client.execute("EXEC", {});

    if (result && result.value()) {
        auto& values = result.value().value();
        std::cout << "事务执行成功，返回 " << values.size() << " 个结果\n";
    }

    co_await client.close();
}
```

### 乐观锁（WATCH）

```cpp
Coroutine optimisticLock(IOScheduler* scheduler)
{
    RedisClient client(scheduler);
    co_await client.connect("127.0.0.1", 6379);

    // 监视 key
    co_await client.execute("WATCH", {"balance"});

    // 读取当前值
    auto r = co_await client.get("balance");
    int balance = 0;
    if (r && r.value() && !r.value().value().empty()) {
        balance = std::stoi(r.value().value()[0].toString());
    }

    // 检查余额
    if (balance < 100) {
        co_await client.execute("UNWATCH", {});
        std::cerr << "余额不足\n";
        co_return;
    }

    // 开始事务
    co_await client.execute("MULTI", {});
    co_await client.set("balance", std::to_string(balance - 100));
    auto exec_result = co_await client.execute("EXEC", {});

    if (!exec_result || !exec_result.value() || exec_result.value().value().empty()) {
        std::cerr << "事务失败（key 被修改）\n";
    } else {
        std::cout << "扣款成功\n";
    }

    co_await client.close();
}
```

### 事务回滚

```cpp
Coroutine transactionRollback(IOScheduler* scheduler)
{
    RedisClient client(scheduler);
    co_await client.connect("127.0.0.1", 6379);

    co_await client.execute("MULTI", {});
    co_await client.set("key1", "value1");
    co_await client.set("key2", "value2");

    // 放弃事务
    co_await client.execute("DISCARD", {});

    co_await client.close();
}
```

## Pub/Sub

### 发布订阅

```cpp
Coroutine pubsubExample(IOScheduler* scheduler)
{
    RedisClient sub(scheduler);
    RedisClient pub(scheduler);

    co_await sub.connect("127.0.0.1", 6379);
    co_await pub.connect("127.0.0.1", 6379);

    // 订阅频道
    co_await sub.subscribe("news");
    co_await sub.subscribe("updates");

    // 发布消息
    co_await pub.publish("news", "hello world");
    co_await pub.publish("updates", "new version released");

    // 接收消息
    for (int i = 0; i < 2; ++i) {
        auto msg = co_await sub.receive().timeout(std::chrono::seconds(5));
        if (msg && msg.value()) {
            auto& values = msg.value().value();
            if (values.size() >= 3) {
                std::cout << "频道: " << values[1].toString() << '\n';
                std::cout << "消息: " << values[2].toString() << '\n';
            }
        }
    }

    // 取消订阅
    co_await sub.unsubscribe("news");
    co_await sub.unsubscribe("updates");

    co_await sub.close();
    co_await pub.close();
}
```

### 模式订阅

```cpp
Coroutine patternSubscribe(IOScheduler* scheduler)
{
    RedisClient sub(scheduler);
    co_await sub.connect("127.0.0.1", 6379);

    // 订阅模式
    co_await sub.psubscribe("news.*");
    co_await sub.psubscribe("updates.*");

    // 接收消息
    while (true) {
        auto msg = co_await sub.receive().timeout(std::chrono::seconds(30));
        if (!msg) break;

        if (msg.value()) {
            auto& values = msg.value().value();
            if (values.size() >= 4) {
                std::cout << "模式: " << values[1].toString() << '\n';
                std::cout << "频道: " << values[2].toString() << '\n';
                std::cout << "消息: " << values[3].toString() << '\n';
            }
        }
    }

    co_await sub.close();
}
```

## 错误处理与重试

### 超时重试

```cpp
Coroutine retryOnTimeout(IOScheduler* scheduler)
{
    RedisClient client(scheduler);
    co_await client.connect("127.0.0.1", 6379);

    const int max_retries = 3;
    for (int retry = 0; retry < max_retries; ++retry) {
        auto result = co_await client.get("key").timeout(std::chrono::seconds(5));

        if (result && result.value()) {
            // 成功
            break;
        }

        if (!result && result.error().type() == REDIS_ERROR_TYPE_TIMEOUT_ERROR) {
            std::cout << "超时，重试 " << (retry + 1) << "/" << max_retries << '\n';
            continue;
        }

        // 其他错误，不重试
        std::cerr << "错误: " << result.error().message() << '\n';
        break;
    }

    co_await client.close();
}
```

### 连接重试

```cpp
Coroutine connectWithRetry(IOScheduler* scheduler, int max_retries = 3)
{
    RedisClient client(scheduler);

    for (int i = 0; i < max_retries; ++i) {
        auto conn = co_await client.connect("127.0.0.1", 6379)
                                   .timeout(std::chrono::seconds(3));

        if (conn && conn.value()) {
            std::cout << "连接成功\n";
            co_return;
        }

        if (i < max_retries - 1) {
            std::cerr << "连接失败，" << (i + 1) << " 秒后重试...\n";
            co_await galay::kernel::sleep(std::chrono::seconds(i + 1));
        }
    }

    std::cerr << "连接失败，已达最大重试次数\n";
}
```

### 指数退避

```cpp
Coroutine exponentialBackoff(IOScheduler* scheduler)
{
    RedisClient client(scheduler);
    co_await client.connect("127.0.0.1", 6379);

    int retry = 0;
    int max_retries = 5;
    int base_delay_ms = 100;

    while (retry < max_retries) {
        auto result = co_await client.get("key").timeout(std::chrono::seconds(5));

        if (result && result.value()) {
            break;
        }

        if (!result && result.error().type() == REDIS_ERROR_TYPE_TIMEOUT_ERROR) {
            int delay_ms = base_delay_ms * (1 << retry);  // 100, 200, 400, 800, 1600
            std::cout << "超时，等待 " << delay_ms << " ms 后重试\n";
            co_await galay::kernel::sleep(std::chrono::milliseconds(delay_ms));
            ++retry;
            continue;
        }

        break;
    }

    co_await client.close();
}
```

## 实战场景

### 分布式锁

```cpp
class RedisLock
{
public:
    RedisLock(RedisClient& client, const std::string& key, int ttl_seconds = 10)
        : m_client(client), m_key(key), m_ttl(ttl_seconds)
    {
    }

    Coroutine acquire()
    {
        // 使用 SET NX EX 实现锁
        auto r = co_await m_client.execute("SET", {m_key, "locked", "NX", "EX", std::to_string(m_ttl)})
                                  .timeout(std::chrono::seconds(5));

        if (r && r.value() && !r.value().value().empty()) {
            if (r.value().value()[0].isStatus() &&
                r.value().value()[0].toStatus() == "OK") {
                m_locked = true;
                co_return true;
            }
        }

        co_return false;
    }

    Coroutine release()
    {
        if (m_locked) {
            co_await m_client.del(m_key);
            m_locked = false;
        }
    }

private:
    RedisClient& m_client;
    std::string m_key;
    int m_ttl;
    bool m_locked = false;
};

// 使用示例
Coroutine useLock(IOScheduler* scheduler)
{
    RedisClient client(scheduler);
    co_await client.connect("127.0.0.1", 6379);

    RedisLock lock(client, "my_lock", 10);

    if (co_await lock.acquire()) {
        std::cout << "获取锁成功\n";

        // 执行临界区操作
        co_await client.incr("counter");

        co_await lock.release();
        std::cout << "释放锁\n";
    } else {
        std::cout << "获取锁失败\n";
    }

    co_await client.close();
}
```

### 限流器

```cpp
class RateLimiter
{
public:
    RateLimiter(RedisClient& client, const std::string& key, int max_requests, int window_seconds)
        : m_client(client), m_key(key), m_max_requests(max_requests), m_window(window_seconds)
    {
    }

    Coroutine allowRequest()
    {
        auto now = std::chrono::system_clock::now().time_since_epoch().count();
        std::string member = std::to_string(now);

        // 添加当前请求
        co_await m_client.zadd(m_key, static_cast<double>(now), member);

        // 移除过期请求
        auto cutoff = now - m_window * 1000000000LL;
        co_await m_client.execute("ZREMRANGEBYSCORE", {m_key, "-inf", std::to_string(cutoff)});

        // 统计窗口内请求数
        auto r = co_await m_client.execute("ZCARD", {m_key}).timeout(std::chrono::seconds(1));

        if (r && r.value() && !r.value().value().empty()) {
            int64_t count = r.value().value()[0].toInteger();
            co_return count <= m_max_requests;
        }

        co_return false;
    }

private:
    RedisClient& m_client;
    std::string m_key;
    int m_max_requests;
    int m_window;
};

// 使用示例
Coroutine useRateLimiter(IOScheduler* scheduler)
{
    RedisClient client(scheduler);
    co_await client.connect("127.0.0.1", 6379);

    RateLimiter limiter(client, "api:rate_limit", 100, 60);  // 每分钟 100 次

    if (co_await limiter.allowRequest()) {
        std::cout << "请求通过\n";
        // 处理请求
    } else {
        std::cout << "请求被限流\n";
    }

    co_await client.close();
}
```

### 缓存管理

```cpp
class CacheManager
{
public:
    CacheManager(RedisClient& client) : m_client(client) {}

    Coroutine get(const std::string& key)
    {
        auto r = co_await m_client.get(key).timeout(std::chrono::seconds(2));

        if (r && r.value() && !r.value().value().empty()) {
            co_return std::optional<std::string>(r.value().value()[0].toString());
        }

        co_return std::optional<std::string>();
    }

    Coroutine set(const std::string& key, const std::string& value, int ttl_seconds = 3600)
    {
        co_await m_client.setex(key, ttl_seconds, value).timeout(std::chrono::seconds(2));
    }

    Coroutine getOrLoad(const std::string& key,
                       std::function<Coroutine(std::string&)> loader,
                       int ttl_seconds = 3600)
    {
        // 先从缓存读取
        auto cached = co_await get(key);
        if (cached.has_value()) {
            co_return cached.value();
        }

        // 缓存未命中，加载数据
        std::string value;
        co_await loader(value);

        // 写入缓存
        co_await set(key, value, ttl_seconds);

        co_return value;
    }

private:
    RedisClient& m_client;
};
```

## 监控与调试

### 性能监控

```cpp
class PerformanceMonitor
{
public:
    void recordRequest(const std::string& cmd, std::chrono::milliseconds duration)
    {
        m_total_requests++;
        m_total_duration += duration;

        if (duration > m_max_duration) {
            m_max_duration = duration;
        }

        m_cmd_stats[cmd].count++;
        m_cmd_stats[cmd].total_duration += duration;
    }

    void printStats()
    {
        std::cout << "总请求数: " << m_total_requests << '\n';
        std::cout << "平均耗时: " << (m_total_duration.count() / m_total_requests) << " ms\n";
        std::cout << "最大耗时: " << m_max_duration.count() << " ms\n";

        std::cout << "\n命令统计:\n";
        for (const auto& [cmd, stats] : m_cmd_stats) {
            std::cout << cmd << ": "
                      << stats.count << " 次, "
                      << "平均 " << (stats.total_duration.count() / stats.count) << " ms\n";
        }
    }

private:
    struct CmdStats {
        size_t count = 0;
        std::chrono::milliseconds total_duration{0};
    };

    size_t m_total_requests = 0;
    std::chrono::milliseconds m_total_duration{0};
    std::chrono::milliseconds m_max_duration{0};
    std::map<std::string, CmdStats> m_cmd_stats;
};
```

### 日志记录

```cpp
Coroutine loggedOperation(IOScheduler* scheduler)
{
    RedisClient client(scheduler);

    auto start = std::chrono::steady_clock::now();

    auto conn = co_await client.connect("127.0.0.1", 6379);

    auto end = std::chrono::steady_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);

    if (conn && conn.value()) {
        spdlog::info("连接成功，耗时 {} ms", duration.count());
    } else {
        spdlog::error("连接失败: {}", conn.error().message());
    }

    co_await client.close();
}
```
