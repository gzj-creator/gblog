# 09-常见问题

## 编译相关

### Q: 编译时找不到 galay-kernel 头文件

**A:** 确保 CMake 能找到依赖库，使用 `CMAKE_PREFIX_PATH` 指定：

```bash
cmake -S . -B build \
  -DCMAKE_PREFIX_PATH="/path/to/galay-kernel;/path/to/galay-utils"
```

或者设置环境变量：

```bash
export CMAKE_PREFIX_PATH="/path/to/galay-kernel:/path/to/galay-utils"
cmake -S . -B build
```

### Q: 链接时出现 undefined reference 错误

**A:** 检查链接库是否完整：

```cmake
target_link_libraries(your_target PRIVATE
    galay-redis
    galay-kernel
    galay-utils
    OpenSSL::SSL
    OpenSSL::Crypto
    spdlog::spdlog
)
```

### Q: 编译时出现 C++20 特性不支持

**A:** 确保编译器支持 C++20：

```bash
# GCC
g++ --version  # 需要 >= 11

# Clang
clang++ --version  # 需要 >= 14
```

在 CMakeLists.txt 中显式指定：

```cmake
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
```

## 连接相关

### Q: 连接失败：Connection refused

**A:** 检查以下几点：

1. Redis 服务是否运行：
   ```bash
   redis-cli ping
   # 或
   ps aux | grep redis-server
   ```

2. 端口是否正确（默认 6379）：
   ```bash
   netstat -tlnp | grep 6379
   ```

3. 防火墙是否允许连接：
   ```bash
   sudo ufw allow 6379
   ```

4. Redis 是否允许远程连接（检查 bind）：
   ```bash
   # /etc/redis/redis.conf
   bind 0.0.0.0  # 允许所有 IP
   ```

### Q: 连接失败：Authentication failed

**A:** 检查密码配置：

```cpp
// 确保密码正确
co_await client.connect("127.0.0.1", 6379, "", "correct_password");
```

在 Redis 配置文件中检查：

```bash
# /etc/redis/redis.conf
requirepass your_password
```

### Q: 连接超时

**A:** 调整超时参数：

```cpp
// 增加连接超时
auto conn = co_await client.connect("127.0.0.1", 6379)
                           .timeout(std::chrono::seconds(10));
```

或检查网络连接：

```bash
telnet 127.0.0.1 6379
```

### Q: 连接一段时间后断开

**A:** Redis 有 `timeout` 配置，默认 0（永不超时）。如果设置了超时，解决方案：

1. 使用连接池自动管理连接生命周期
2. 定期 ping 保活：
   ```cpp
   co_await client.ping();
   ```
3. 调整 Redis 服务器配置：
   ```bash
   # /etc/redis/redis.conf
   timeout 0  # 永不超时
   ```

## 查询相关

### Q: 查询返回空结果

**A:** 检查以下几点：

1. key 是否存在：
   ```cpp
   auto r = co_await client.exists("key");
   ```

2. 是否选择了正确的数据库：
   ```cpp
   co_await client.select(0);  // 选择 DB 0
   ```

3. 检查 key 的类型：
   ```cpp
   auto r = co_await client.execute("TYPE", {"key"});
   ```

### Q: 如何判断 key 不存在？

**A:** 检查返回值：

```cpp
auto result = co_await client.get("key");
if (result && result.value()) {
    auto& values = result.value().value();
    if (values.empty() || values[0].isNull()) {
        std::cout << "key 不存在\n";
    } else {
        std::cout << "值: " << values[0].toString() << '\n';
    }
}
```

### Q: 大结果集查询内存占用高

**A:** 优化策略：

1. 使用 SCAN 代替 KEYS：
   ```cpp
   int cursor = 0;
   do {
       auto r = co_await client.execute("SCAN", {std::to_string(cursor), "MATCH", "pattern:*", "COUNT", "100"});
       // 处理结果
       if (r && r.value() && !r.value().value().empty()) {
           cursor = std::stoi(r.value().value()[0].toString());
       }
   } while (cursor != 0);
   ```

2. 使用 HSCAN/SSCAN/ZSCAN 遍历大集合

3. 分批处理数据

### Q: 查询速度慢

**A:** 优化建议：

1. 使用 Pipeline 批量查询
2. 避免使用 KEYS 命令（使用 SCAN）
3. 检查 Redis 服务器负载
4. 检查网络延迟
5. 使用连接池减少连接开销

## Pipeline 相关

### Q: Pipeline 如何使用？

**A:** 将多个命令组织成二维数组：

```cpp
std::vector<std::vector<std::string>> commands = {
    {"SET", "k1", "v1"},
    {"SET", "k2", "v2"},
    {"GET", "k1"},
    {"GET", "k2"}
};
auto result = co_await client.pipeline(commands).timeout(std::chrono::seconds(10));
```

### Q: Pipeline 最多可以发送多少条命令？

**A:** 理论上无限制，但受以下因素影响：

- Redis 服务器的 `client-output-buffer-limit` 配置
- 网络带宽
- 内存限制

建议每批不超过 1000 条命令。

### Q: Pipeline 中某条命令失败会怎样？

**A:** Pipeline 中的命令独立执行，一条失败不影响其他命令。返回的结果数组中，失败的命令对应位置会是 Error 类型：

```cpp
auto result = co_await client.pipeline(commands);
if (result && result.value()) {
    auto& values = result.value().value();
    for (size_t i = 0; i < values.size(); ++i) {
        if (values[i].isError()) {
            std::cerr << "命令 " << i << " 失败: " << values[i].toError() << '\n';
        }
    }
}
```

## 事务相关

### Q: 事务中途失败如何回滚？

**A:** 使用 DISCARD 放弃事务：

```cpp
co_await client.execute("MULTI", {});

auto r1 = co_await client.set("key1", "value1");
if (!r1) {
    co_await client.execute("DISCARD", {});
    co_return;
}

auto r2 = co_await client.set("key2", "value2");
if (!r2) {
    co_await client.execute("DISCARD", {});
    co_return;
}

co_await client.execute("EXEC", {});
```

### Q: 如何实现乐观锁？

**A:** 使用 WATCH 命令：

```cpp
co_await client.execute("WATCH", {"balance"});

auto r = co_await client.get("balance");
int balance = std::stoi(r.value().value()[0].toString());

if (balance < 100) {
    co_await client.execute("UNWATCH", {});
    std::cerr << "余额不足\n";
    co_return;
}

co_await client.execute("MULTI", {});
co_await client.set("balance", std::to_string(balance - 100));
auto exec_result = co_await client.execute("EXEC", {});

if (!exec_result || !exec_result.value() || exec_result.value().value().empty()) {
    std::cerr << "事务失败（key 被修改）\n";
}
```

### Q: 事务中可以使用 Pipeline 吗？

**A:** 不建议。事务和 Pipeline 是不同的机制：

- 事务：保证原子性，使用 MULTI/EXEC
- Pipeline：批量发送命令，减少网络往返

如果需要批量原子操作，使用事务；如果需要高性能批量操作，使用 Pipeline。

## 连接池相关

### Q: 连接池大小如何设置？

**A:** 根据并发量设置：

- 低并发（< 10 QPS）：min=2, max=5
- 中等并发（10-100 QPS）：min=5, max=20
- 高并发（> 100 QPS）：min=10, max=50

不要超过 Redis 服务器的 `maxclients` 配置。

### Q: 连接池满了怎么办？

**A:** `acquire()` 会挂起等待，直到有连接归还。可以：

1. 增加 `max_connections`
2. 优化查询速度，加快连接归还
3. 设置超时避免无限等待：
   ```cpp
   auto conn = co_await pool.acquire().timeout(std::chrono::seconds(2));
   ```

### Q: 忘记归还连接会怎样？

**A:** 连接泄漏，池会逐渐耗尽。建议使用 RAII 封装：

```cpp
auto conn_result = co_await pool.acquire();
if (conn_result && conn_result.value()) {
    auto conn = conn_result.value();
    ScopedConnection scoped(pool, conn);
    co_await scoped->set("key", "value");
    // 离开作用域自动归还
}
```

### Q: 连接池中的连接会自动重连吗？

**A:** 如果启用了 `enable_auto_reconnect`，连接池会尝试重连。可以配置：

```cpp
ConnectionPoolConfig config;
config.enable_auto_reconnect = true;
config.max_reconnect_attempts = 3;
```

## 异步相关

### Q: 可以并发使用同一个 RedisClient 吗？

**A:** 不可以。同一个实例应串行使用。如需并发，使用连接池：

```cpp
// 错误
RedisClient client(scheduler);
scheduler->spawn(query1(client));
scheduler->spawn(query2(client));  // 冲突！

// 正确
RedisConnectionPool pool(scheduler, config);
scheduler->spawn(query1(pool));
scheduler->spawn(query2(pool));
```

### Q: await_resume 返回的 optional 为什么是空的？

**A:** 表示操作未完成，需要继续 `co_await`。但在实际使用中，galay-redis 的 Awaitable 会自动处理这种情况，用户通常不需要手动循环。

### Q: 超时后如何重试？

**A:** 检测超时错误并重新发起请求：

```cpp
auto result = co_await client.get("key").timeout(std::chrono::seconds(5));

if (!result && result.error().type() == REDIS_ERROR_TYPE_TIMEOUT_ERROR) {
    // 重试
    result = co_await client.get("key").timeout(std::chrono::seconds(5));
}
```

## Pub/Sub 相关

### Q: 订阅后如何接收消息？

**A:** 使用 `receive()` 方法：

```cpp
co_await client.subscribe("channel");

while (true) {
    auto msg = co_await client.receive().timeout(std::chrono::seconds(30));
    if (!msg) break;

    if (msg.value()) {
        auto& values = msg.value().value();
        if (values.size() >= 3) {
            std::cout << "频道: " << values[1].toString() << '\n';
            std::cout << "消息: " << values[2].toString() << '\n';
        }
    }
}
```

### Q: 订阅模式如何使用？

**A:** 使用 `psubscribe()` 订阅模式：

```cpp
co_await client.psubscribe("news.*");

auto msg = co_await client.receive();
if (msg && msg.value()) {
    auto& values = msg.value().value();
    if (values.size() >= 4) {
        std::cout << "模式: " << values[1].toString() << '\n';
        std::cout << "频道: " << values[2].toString() << '\n';
        std::cout << "消息: " << values[3].toString() << '\n';
    }
}
```

### Q: 可以在同一个客户端上同时发布和订阅吗？

**A:** 不建议。订阅模式下，客户端进入特殊状态，只能执行订阅相关命令。建议使用两个独立的客户端：

```cpp
RedisClient sub(scheduler);  // 用于订阅
RedisClient pub(scheduler);  // 用于发布
```

## 错误处理相关

### Q: 如何区分不同类型的错误？

**A:** 通过 `RedisErrorType` 判断：

```cpp
if (!result) {
    auto& err = result.error();
    switch (err.type()) {
        case REDIS_ERROR_TYPE_CONNECTION_ERROR:
            // 网络连接错误
            break;
        case REDIS_ERROR_TYPE_AUTH_ERROR:
            // 认证失败
            break;
        case REDIS_ERROR_TYPE_TIMEOUT_ERROR:
            // 超时
            break;
        case REDIS_ERROR_TYPE_PARSE_ERROR:
            // 协议解析错误
            break;
        default:
            // 其他错误
            break;
    }
}
```

### Q: 如何获取详细的错误信息？

**A:** 使用 `message()` 方法：

```cpp
std::cerr << "错误类型: " << static_cast<int>(err.type()) << '\n';
std::cerr << "错误消息: " << err.message() << '\n';
```

## 性能相关

### Q: 如何提升查询性能？

**A:** 优化策略：

1. 使用 Pipeline 批量查询
2. 使用连接池避免频繁建立连接
3. 合理设置超时参数
4. 避免使用 KEYS 命令
5. 使用 Hash Tag 确保相关 key 在同一节点（Cluster 模式）

### Q: 连接建立很慢怎么办？

**A:** 可能原因：

1. DNS 解析慢：使用 IP 地址而非域名
2. 网络延迟高：检查网络连接
3. Redis 服务器负载高：优化服务器配置
4. 使用连接池预热连接：
   ```cpp
   pool.warmup();
   ```

### Q: 内存占用过高怎么办？

**A:** 优化建议：

1. 使用 SCAN 代替 KEYS
2. 分批处理大结果集
3. 及时释放不用的连接
4. 检查是否有连接泄漏

## 主从/集群相关

### Q: 主从读写分离如何配置？

**A:** 使用 `RedisMasterSlaveClient`：

```cpp
RedisMasterSlaveClient ms(scheduler);

RedisNodeAddress master{"127.0.0.1", 6379};
RedisNodeAddress replica{"127.0.0.1", 6380};

co_await ms.connectMaster(master);
co_await ms.addReplica(replica);

// 写操作走主库
co_await ms.executeWrite("SET", {"key", "value"});

// 读操作走从库
auto r = co_await ms.executeRead("GET", {"key"});
```

### Q: Sentinel 如何使用？

**A:** 配置 Sentinel 节点和 master 名称：

```cpp
RedisMasterSlaveClient ms(scheduler);
ms.setSentinelMasterName("mymaster");

RedisNodeAddress sentinel{"127.0.0.1", 26379};
co_await ms.addSentinel(sentinel);

// 从 Sentinel 自动发现主从拓扑
co_await ms.refreshFromSentinel();
```

### Q: Cluster 模式如何使用？

**A:** 使用 `RedisClusterClient`：

```cpp
RedisClusterClient cluster(scheduler);

RedisClusterNodeAddress n1;
n1.host = "127.0.0.1";
n1.port = 7000;
n1.slot_start = 0;
n1.slot_end = 8191;

co_await cluster.addNode(n1);

// 按 key 自动路由
co_await cluster.executeByKey("key", "SET", {"key", "value"});
```

### Q: Hash Tag 如何使用？

**A:** 在 key 中使用 `{...}` 包裹需要哈希的部分：

```cpp
// {u100}:name 和 {u100}:age 的 slot 相同
co_await cluster.executeByKey("{u100}:name", "SET", {"{u100}:name", "alice"});
co_await cluster.executeByKey("{u100}:age", "SET", {"{u100}:age", "25"});
```

## 兼容性相关

### Q: 支持哪些 Redis 版本？

**A:** 支持 Redis 2.6+ 的所有版本。RESP3 特性需要 Redis 6.0+。

### Q: 支持 Redis Cluster 吗？

**A:** 支持。使用 `RedisClusterClient` 实现 Cluster 路由。

### Q: 支持 Sentinel 吗？

**A:** 支持。使用 `RedisMasterSlaveClient` 配合 Sentinel 实现自动故障转移。

### Q: 支持 SSL/TLS 连接吗？

**A:** 当前版本暂不支持，计划在未来版本中添加。

## 调试相关

### Q: 如何启用调试日志？

**A:** 设置 spdlog 日志级别：

```cpp
#include <spdlog/spdlog.h>

int main() {
    spdlog::set_level(spdlog::level::debug);
    // ...
}
```

### Q: 如何查看发送的命令？

**A:** 在调用前打印：

```cpp
std::string cmd = "GET";
std::vector<std::string> args = {"key"};
std::cout << "执行命令: " << cmd;
for (const auto& arg : args) {
    std::cout << " " << arg;
}
std::cout << '\n';

auto result = co_await client.execute(cmd, args);
```

或启用 Redis 服务器的 monitor 命令：

```bash
redis-cli monitor
```

### Q: 如何分析性能瓶颈？

**A:** 使用计时器：

```cpp
auto start = std::chrono::steady_clock::now();
auto result = co_await client.get("key");
auto end = std::chrono::steady_clock::now();
auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
std::cout << "查询耗时: " << ms.count() << " ms\n";
```

## 其他

### Q: 如何贡献代码？

**A:** 欢迎提交 PR 到 GitHub 仓库：

1. Fork 仓库
2. 创建特性分支
3. 提交代码并编写测试
4. 发起 Pull Request

### Q: 如何报告 Bug？

**A:** 在 GitHub Issues 中提交，包含：

- 复现步骤
- 预期行为和实际行为
- 环境信息（OS、编译器、Redis 版本）
- 相关日志和错误信息

### Q: 有商业支持吗？

**A:** 当前为开源项目，暂无商业支持。可通过 GitHub Issues 获取社区支持。

### Q: 与 hiredis 相比有什么优势？

**A:**

- 现代 C++ 接口（C++20）
- 基于协程的异步支持
- 类型安全的错误处理（`std::expected`）
- 内置连接池
- 主从读写分离和 Cluster 支持
- 统一的超时控制
- 更好的内存管理

### Q: 生产环境可以使用吗？

**A:** 项目处于活跃开发中，建议：

- 充分测试后再用于生产
- 关注 GitHub 更新和 Bug 修复
- 做好错误处理和监控
- 准备降级方案

### Q: 如何从 hiredis 迁移？

**A:** galay-redis 提供了更高层的抽象，迁移步骤：

1. 将 hiredis 的同步调用改为协程
2. 使用 `std::expected` 替代错误码检查
3. 使用连接池替代手动连接管理
4. 使用 Pipeline 替代批量命令

示例：

```cpp
// hiredis
redisContext* c = redisConnect("127.0.0.1", 6379);
redisReply* reply = (redisReply*)redisCommand(c, "GET key");
if (reply->type == REDIS_REPLY_STRING) {
    printf("%s\n", reply->str);
}
freeReplyObject(reply);
redisFree(c);

// galay-redis
RedisClient client(scheduler);
co_await client.connect("127.0.0.1", 6379);
auto result = co_await client.get("key");
if (result && result.value() && !result.value().value().empty()) {
    std::cout << result.value().value()[0].toString() << '\n';
}
co_await client.close();
```
