# Galay-RPC 架构设计

## 概述

Galay-RPC 是基于 C++23 协程的高性能异步 RPC 框架，构建于 galay-kernel 异步运行时之上。采用 header-only 设计，提供二进制协议、服务注册/发现、双向流等功能。

---

## 整体架构

```text
┌─────────────────────────────────────────────────────────┐
│                      应用层                              │
│              (EchoService, CalcService, ...)             │
├─────────────────────────────────────────────────────────┤
│                      内核层 (kernel/)                    │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌────────────┐ │
│  │RpcServer │ │RpcClient │ │RpcService│ │ServiceDisc.│ │
│  └────┬─────┘ └────┬─────┘ └──────────┘ └────────────┘ │
│       │             │                                    │
│  ┌────┴─────────────┴─────┐  ┌─────────────────────┐   │
│  │       RpcConn           │  │     RpcStream       │   │
│  │  (RingBuffer + readv/   │  │  (双向流支持)        │   │
│  │   writev)               │  │                     │   │
│  └────────────┬────────────┘  └──────────┬──────────┘   │
├───────────────┼──────────────────────────┼──────────────┤
│               │      协议层 (protoc/)     │              │
│  ┌────────────┴──────────────────────────┴────────────┐ │
│  │  RpcMessage  │  RpcCodec  │  RpcError  │  RpcBase  │ │
│  └────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────┤
│                   galay-kernel 运行时                     │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌───────────┐  │
│  │ Runtime  │ │TcpSocket │ │Coroutine │ │RingBuffer │  │
│  │          │ │(kqueue/  │ │          │ │           │  │
│  │          │ │ epoll)   │ │          │ │           │  │
│  └──────────┘ └──────────┘ └──────────┘ └───────────┘  │
└─────────────────────────────────────────────────────────┘
```

---

## 模块划分

### 协议层 (protoc/)

协议层负责消息的定义、序列化/反序列化和错误处理，不依赖网络 IO。

| 文件 | 职责 |
|------|------|
| `RpcBase.h` | 基础常量定义：魔数、版本号、消息类型枚举、错误码枚举 |
| `RpcMessage.h` | 消息类定义：`RpcHeader`、`RpcRequest`、`RpcResponse` 的序列化/反序列化 |
| `RpcCodec.h` | 编解码器：提供静态方法解码完整消息，计算消息长度 |
| `RpcError.h` | 错误类：封装错误码和错误信息 |

### 内核层 (kernel/)

内核层负责网络通信、服务管理和连接处理，依赖 galay-kernel 运行时。

| 文件 | 职责 |
|------|------|
| `RpcConn.h` | 连接封装：RingBuffer + readv/writev 高效 IO，提供 Reader/Writer 抽象 |
| `RpcService.h` | 服务定义：`RpcService` 基类、方法注册、`RpcContext` 上下文 |
| `RpcServer.h` | 服务器：accept 循环、连接分发、请求处理、内置 Runtime |
| `RpcClient.h` | 客户端：连接管理、RPC 调用状态机、超时支持 |
| `RpcStream.h` | 双向流：流初始化、数据传输、流结束/取消 |
| `ServiceDiscovery.h` | 服务发现：Concept 约束、本地/异步注册中心、负载均衡 |

---

## 协议设计

### 消息头 (16 bytes, 固定长度)

```text
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Magic (0x47525043)                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Version    |     Type      |     Flags     |   Reserved    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Request ID                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Body Length                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

- **Magic**: `0x47525043`（"GRPC" 的十六进制），用于校验协议合法性
- **Version**: 协议版本，当前为 `0x01`
- **Type**: 消息类型（见下表）
- **Flags**: 标志位，预留扩展
- **Reserved**: 保留字段
- **Request ID**: 请求标识，用于请求-响应匹配
- **Body Length**: 消息体长度，最大 16MB

### 消息类型

| 类型 | 值 | 说明 |
|------|-----|------|
| REQUEST | 0x01 | 普通 RPC 请求 |
| RESPONSE | 0x02 | 普通 RPC 响应 |
| HEARTBEAT | 0x03 | 心跳（预留） |
| ERROR | 0x04 | 错误（预留） |
| STREAM_INIT | 0x10 | 流初始化请求 |
| STREAM_INIT_ACK | 0x11 | 流初始化确认 |
| STREAM_DATA | 0x12 | 流数据 |
| STREAM_END | 0x13 | 流结束 |
| STREAM_CANCEL | 0x14 | 流取消 |

### 请求体格式

```text
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Service Name Length (2)    |     Service Name (variable)  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Method Name Length (2)     |     Method Name (variable)   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Payload (variable)                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

- 服务名和方法名使用 2 字节长度前缀 + 变长字符串
- Payload 为剩余部分，由应用层自行解释

### 响应体格式

```text
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Error Code (2)        |       Payload (variable)      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

- Error Code 为 2 字节错误码，`0` 表示成功
- Payload 为响应数据

### 字节序

所有多字节整数字段使用**网络字节序（大端）**，通过 `htonl`/`ntohl`/`htons`/`ntohs` 转换。

---

## 数据流

### 普通 RPC 调用

```text
Client                                          Server
  │                                               │
  │  ┌─────────────────────────────────────────┐  │
  │  │ 1. 构造 RpcRequest                      │  │
  │  │ 2. 序列化 (Header + Body)               │  │
  │  │ 3. writev 发送                           │  │
  │  └─────────────────────────────────────────┘  │
  │ ──────────── REQUEST ──────────────────────>  │
  │                                               │
  │                    ┌──────────────────────────────────────┐
  │                    │ 4. readv 接收到 RingBuffer            │
  │                    │ 5. 解析 Header，等待完整 Body          │
  │                    │ 6. 解码 RpcRequest                    │
  │                    │ 7. 查找 Service -> Method              │
  │                    │ 8. 调用 Handler(RpcContext)            │
  │                    │ 9. 构造 RpcResponse                   │
  │                    │ 10. 序列化并 writev 发送               │
  │                    └──────────────────────────────────────┘
  │  <──────────── RESPONSE ──────────────────── │
  │                                               │
  │  ┌─────────────────────────────────────────┐  │
  │  │ 11. readv 接收到 RingBuffer              │  │
  │  │ 12. 解析 Header，等待完整 Body            │  │
  │  │ 13. 解码 RpcResponse                     │  │
  │  │ 14. 返回给调用者                          │  │
  │  └─────────────────────────────────────────┘  │
```

### 双向流

```text
Client                                          Server
  │                                               │
  │ ──── STREAM_INIT (service, method) ────────>  │
  │                                               │
  │ <──── STREAM_INIT_ACK ─────────────────────  │
  │                                               │
  │ ──── STREAM_DATA (payload) ────────────────>  │
  │ <──── STREAM_DATA (payload) ───────────────  │
  │ ──── STREAM_DATA (payload) ────────────────>  │
  │ <──── STREAM_DATA (payload) ───────────────  │
  │  ...                                          │
  │                                               │
  │ ──── STREAM_END ───────────────────────────>  │
  │ <──── STREAM_END ──────────────────────────  │
```

流的生命周期：
1. 客户端发送 `STREAM_INIT`，携带服务名和方法名
2. 服务端确认后返回 `STREAM_INIT_ACK`
3. 双方可以自由发送 `STREAM_DATA`
4. 任一方发送 `STREAM_END` 表示结束
5. 任一方可发送 `STREAM_CANCEL` 取消流

---

## 连接模型

### RingBuffer + readv/writev

```text
                    RingBuffer (环形缓冲区)
              ┌───────────────────────────────┐
              │     ████████░░░░░░░████████   │
              │     ^write_pos     ^read_pos  │
              └───────────────────────────────┘
                         │              │
                    getWriteIovecs  getReadIovecs
                         │              │
                    ┌────┴────┐    ┌────┴────┐
                    │  readv  │    │ 解析消息  │
                    │ (scatter│    │ (线性化   │
                    │  read)  │    │  后解码)  │
                    └─────────┘    └─────────┘
```

- **readv**: 利用 scatter read 直接读入 RingBuffer 的可写区域，避免额外拷贝
- **writev**: 利用 gather write 直接从序列化缓冲区发送，减少系统调用次数
- **RingBuffer**: 8KB 默认大小，环形结构避免频繁内存分配

### 服务器连接处理

```text
                    RpcServer
                       │
                  acceptLoop()
                       │
              ┌────────┼────────┐
              │        │        │
         IOScheduler IOScheduler IOScheduler
              │        │        │
         handleConn  handleConn handleConn
              │        │        │
           RpcConn   RpcConn   RpcConn
```

- 服务器内置 `Runtime`，自动管理 IO 调度器
- 新连接通过 `getNextIOScheduler()` 轮询分发到不同调度器
- 每个连接独立的 `RpcConn`，包含独立的 RingBuffer

---

## 客户端调用状态机

`RpcCallAwaitable` 内部维护一个状态机：

```text
         ┌──────────┐
         │ Invalid  │ (初始状态)
         └────┬─────┘
              │ 首次 co_await
              ▼
         ┌──────────┐
    ┌───>│ Sending  │ (发送请求)
    │    └────┬─────┘
    │         │ writev 未完成
    │         └──────┘
    │         │ writev 完成
    │         ▼
    │    ┌──────────┐
    │    │Receiving │ (接收响应)
    │    └────┬─────┘
    │         │ readv 未完成
    │         └──────┘
    │         │ readv 完成
    │         ▼
    │    ┌──────────┐
    └────│ Invalid  │ (重置，可复用)
         └──────────┘
```

- 每次 `co_await` 返回 `std::expected<std::optional<RpcResponse>, RpcError>`
- `std::nullopt` 表示操作未完成，需要继续 `co_await`
- 有值表示调用完成
- `unexpected` 表示发生错误
- 支持 `.timeout(std::chrono::milliseconds(...))` 设置超时

---

## 服务发现架构

### Concept 约束

```text
ServiceRegistry concept
    │
    ├── LocalServiceRegistry        (同步，非线程安全)
    │
    └── [用户自定义]                 (etcd, consul, ...)

AsyncServiceRegistry concept
    │
    └── AsyncLocalServiceRegistry   (异步，AsyncMutex 保护)
```

### 负载均衡

直接复用 galay-kernel 的负载均衡器：

```text
ServiceDiscoveryClient<Registry, Selector>
    │
    ├── RoundRobinSelector          (轮询)
    ├── RandomSelector              (随机)
    ├── WeightedRoundRobinSelector  (加权轮询)
    └── WeightedRandomSelector      (加权随机)
```

---

## 错误处理

### 错误码体系

| 错误码 | 值 | 层级 | 说明 |
|--------|-----|------|------|
| OK | 0 | - | 成功 |
| UNKNOWN_ERROR | 1 | 通用 | 未知错误 |
| SERVICE_NOT_FOUND | 2 | 服务层 | 服务未注册 |
| METHOD_NOT_FOUND | 3 | 服务层 | 方法未注册 |
| INVALID_REQUEST | 4 | 协议层 | 请求格式错误 |
| INVALID_RESPONSE | 5 | 协议层 | 响应格式错误 |
| REQUEST_TIMEOUT | 6 | 传输层 | 请求超时 |
| CONNECTION_CLOSED | 7 | 传输层 | 连接关闭 |
| SERIALIZATION_ERROR | 8 | 协议层 | 序列化失败 |
| DESERIALIZATION_ERROR | 9 | 协议层 | 反序列化失败 |
| INTERNAL_ERROR | 10 | 通用 | 内部错误 |

### 错误传播路径

```text
IO 错误 (galay-kernel IOError)
    │
    ▼
RpcError (RpcConn 层转换)
    │
    ├── 服务端: 写入 RpcResponse.errorCode
    │
    └── 客户端: 通过 std::expected 返回
```

---

## 设计决策

### 为什么使用 header-only

- galay-rpc 的核心逻辑都是模板代码（Awaitable、Concept 约束等）
- 避免链接依赖，简化集成
- 编译器可以更好地内联优化

### 为什么使用 RingBuffer + readv/writev

- 减少系统调用次数（scatter/gather IO）
- 环形缓冲区避免频繁内存分配和拷贝
- 适合流式协议的增量解析

### 为什么使用 Concept 而非虚函数

- 零运行时开销，编译期多态
- 更好的错误信息（concept 约束失败时）
- 允许同步和异步两套接口共存

### 为什么客户端调用需要循环 co_await

- galay-kernel 的 IO 操作可能部分完成（short read/write）
- 循环模式让调用者显式处理中间状态
- 与 galay-kernel 其他库（galay-http 等）保持一致的编程模型

---

## 依赖关系

```text
galay-rpc (header-only)
    │
    ├── galay-kernel    (协程运行时、TcpSocket、RingBuffer、AsyncMutex)
    │       │
    │       ├── kqueue (macOS)
    │       └── epoll (Linux)
    │
    └── spdlog          (日志)
```

## 构建要求

- CMake 3.16+
- C++23 兼容编译器（GCC 11+, Clang 14+, AppleClang 15+）
- galay-kernel 库（已安装）
- spdlog 库（已安装）
