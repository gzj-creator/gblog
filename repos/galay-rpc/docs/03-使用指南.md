# 03-使用指南

## 目录

1. [快速开始](#快速开始)
2. [服务端开发](#服务端开发)
3. [客户端开发](#客户端开发)
4. [双向流](#双向流)
5. [服务发现](#服务发现)
6. [超时控制](#超时控制)
7. [错误处理](#错误处理)
8. [最佳实践](#最佳实践)

---

## 快速开始

### 环境要求

- CMake 3.16+
- C++23 编译器（GCC 11+, Clang 14+, AppleClang 15+）
- Galay 内部依赖（统一联调推荐）：
  - [galay-kernel](https://github.com/gzj-creator/galay-kernel)（构建必需）
  - [galay-utils](https://github.com/gzj-creator/galay-utils)（推荐）
  - [galay-http](https://github.com/gzj-creator/galay-http)（推荐）
- spdlog（已安装）

### 构建

```bash
git clone https://github.com/gzj-creator/galay-kernel.git
git clone https://github.com/gzj-creator/galay-utils.git
git clone https://github.com/gzj-creator/galay-http.git
git clone https://github.com/gzj-creator/galay-rpc.git
cd galay-rpc
mkdir build && cd build
cmake .. -DCMAKE_BUILD_TYPE=Release
cmake --build . --parallel
```

仅单独构建 `galay-rpc` 时，最小内部依赖为 `galay-kernel`。

构建选项：

| 选项 | 默认值 | 说明 |
|------|--------|------|
| BUILD_TESTS | ON | 构建测试 |
| BUILD_BENCHMARKS | ON | 构建压测 |
| BUILD_EXAMPLES | ON | 构建示例 |
| BUILD_MODULE_EXAMPLES | ON | 构建 C++23 `import` 示例（需 Ninja/VS 生成器） |

> `BUILD_MODULE_EXAMPLES` 需要 CMake `>= 3.28` 且使用 `Ninja`/`Visual Studio` 生成器。  
> `Unix Makefiles` 下会自动关闭该选项。

### 集成到你的项目

galay-rpc 是 header-only 库，安装后通过 CMake 引入：

```cmake
find_package(galay-rpc REQUIRED)
target_link_libraries(your_target galay-rpc::galay-rpc)
```

### 最小示例

**服务端（5 行核心代码）：**

```cpp
#include "galay-rpc/kernel/RpcServer.h"
#include "galay-rpc/kernel/RpcService.h"

using namespace galay::rpc;
using namespace galay::kernel;

class EchoService : public RpcService {
public:
    EchoService() : RpcService("EchoService") {
        registerMethod("echo", &EchoService::echo);
    }

    Coroutine echo(RpcContext& ctx) {
        auto& req = ctx.request();
        ctx.setPayload(req.payload().data(), req.payload().size());
        co_return;
    }
};

int main() {
    RpcServerConfig config;
    config.port = 9000;

    RpcServer server(config);
    server.registerService(std::make_shared<EchoService>());
    server.start();

    while (server.isRunning()) {
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
```

**客户端：**

```cpp
#include "galay-rpc/kernel/RpcClient.h"
#include "galay-kernel/kernel/Runtime.h"

using namespace galay::rpc;
using namespace galay::kernel;

Coroutine callEcho() {
    RpcClient client;
    co_await client.connect("127.0.0.1", 9000);

    while (true) {
        auto result = co_await client.call("EchoService", "echo", "Hello");
        if (!result) break;
        if (result.value()) {
            auto& response = result.value().value();
            std::string data(response.payload().begin(), response.payload().end());
            std::cout << "Response: " << data << "\n";
            break;
        }
    }

    co_await client.close();
}

int main() {
    Runtime runtime(1, 1);
    runtime.start();

    runtime.getNextIOScheduler()->spawn(callEcho());

    std::this_thread::sleep_for(std::chrono::seconds(3));
    runtime.stop();
}
```

**模块化导入版本（C++23）：**

```cpp
import galay.rpc;
```

```bash
./build/examples/E1-EchoServerImport 9000
./build/examples/E2-EchoClientImport 127.0.0.1 9000
./build/examples/E3-StreamServerImport 9100 1 131072
./build/examples/E4-StreamClientImport 127.0.0.1 9100 200 64
```

---

## 服务端开发

### 定义服务

继承 `RpcService`，在构造函数中注册方法：

```cpp
class MyService : public RpcService {
public:
    MyService() : RpcService("MyService") {
        registerMethod("method1", &MyService::method1);
        registerMethod("method2", &MyService::method2);
    }

    Coroutine method1(RpcContext& ctx) {
        // 从请求中读取数据
        auto& payload = ctx.request().payload();
        std::string input(payload.begin(), payload.end());

        // 处理业务逻辑
        std::string output = processData(input);

        // 设置响应
        ctx.setPayload(output);
        co_return;
    }

    Coroutine method2(RpcContext& ctx) {
        // 设置错误
        ctx.setError(RpcErrorCode::INVALID_REQUEST);
        co_return;
    }
};
```

### 注册多个服务

```cpp
auto echoService = std::make_shared<EchoService>();
auto calcService = std::make_shared<CalcService>();
auto userService = std::make_shared<UserService>();

RpcServer server(config);
server.registerService(echoService);
server.registerService(calcService);
server.registerService(userService);
server.start();
```

每个服务通过 `serviceName` 区分，客户端调用时需指定服务名和方法名。

### 服务器配置

```cpp
RpcServerConfig config;
config.host = "0.0.0.0";              // 监听地址
config.port = 9000;                   // 监听端口
config.backlog = 1024;                // 监听队列（高并发场景调大）
config.io_scheduler_count = 4;        // IO 调度器数量（0=自动，推荐 CPU 核心数）
config.compute_scheduler_count = 2;   // 计算调度器数量
config.ring_buffer_size = 8192;       // 每连接 RingBuffer 大小
```

### 优雅停止

```cpp
#include <csignal>
#include <atomic>

std::atomic<bool> g_running{true};

void signalHandler(int) {
    g_running.store(false);
}

int main() {
    std::signal(SIGINT, signalHandler);
    std::signal(SIGTERM, signalHandler);

    RpcServer server(config);
    // ... 注册服务 ...
    server.start();

    while (g_running.load() && server.isRunning()) {
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }

    server.stop();  // 析构函数也会自动调用
}
```

---

## 客户端开发

### 基本调用模式

galay-rpc 的 IO 操作可能部分完成，因此需要循环 `co_await` 直到完成：

```cpp
Coroutine example(RpcClient& client) {
    while (true) {
        auto result = co_await client.call("Service", "method", "data");

        if (!result) {
            // 错误：连接关闭、超时等
            std::cerr << "Error: " << result.error().message() << "\n";
            break;
        }

        if (result.value()) {
            // 完成：拿到响应
            auto& response = result.value().value();
            if (response.isOk()) {
                // 处理成功响应
            } else {
                // 服务端返回错误码
                std::cerr << rpcErrorCodeToString(response.errorCode()) << "\n";
            }
            break;
        }

        // result.value() == std::nullopt，操作未完成，继续循环
    }
}
```

### 不同 Payload 类型

```cpp
// 字符串
co_await client.call("Service", "method", "Hello, World!");

// 原始字节
char data[8];
int32_t a = 100, b = 200;
std::memcpy(data, &a, 4);
std::memcpy(data + 4, &b, 4);
co_await client.call("Service", "add", data, 8);

// 无 payload
co_await client.call("Service", "ping");
```

### 连接重试

```cpp
Coroutine connectWithRetry(RpcClient& client, const std::string& host, uint16_t port) {
    int retries = 0;
    const int max_retries = 5;

    while (retries < max_retries) {
        auto result = co_await client.connect(host, port);
        if (result) {
            co_return;  // 连接成功
        }
        retries++;
        if (retries < max_retries) {
            // 等待后重试（注意：这里会阻塞线程，生产环境应使用定时器）
            std::this_thread::sleep_for(std::chrono::seconds(1));
        }
    }
    // 连接失败
}
```

### 客户端需要外部 Runtime

与服务端不同，客户端不内置 Runtime，需要自行创建：

```cpp
int main() {
    Runtime runtime(1, 1);  // 1 IO + 1 计算
    runtime.start();

    auto* scheduler = runtime.getNextIOScheduler();
    scheduler->spawn(myCoroutine());

    // 等待完成
    std::this_thread::sleep_for(std::chrono::seconds(10));
    runtime.stop();
}
```

---

## 双向流

### 流的生命周期

```text
客户端                          服务端
  │                               │
  │── STREAM_INIT ──────────────> │  1. 初始化
  │<── STREAM_INIT_ACK ────────── │  2. 确认
  │                               │
  │── STREAM_DATA ──────────────> │  3. 双向数据传输
  │<── STREAM_DATA ──────────────│
  │── STREAM_DATA ──────────────> │
  │  ...                          │
  │                               │
  │── STREAM_END ───────────────> │  4. 结束
  │<── STREAM_END ───────────────│
```

### 客户端使用

```cpp
Coroutine streamExample(RpcClient& client) {
    // 先建立连接
    co_await client.connect("127.0.0.1", 9000);

    // 创建流会话（不暴露 socket/ringBuffer）
    auto stream_result = client.createStream(/*stream_id=*/1, "MyService", "streamMethod");
    if (!stream_result.has_value()) co_return;
    auto stream = stream_result.value();

    // 1. 发送初始化
    while (true) {
        auto r = co_await stream.sendInit();
        if (!r || r.value()) break;
    }

    // 2. 等待确认
    StreamMessage msg;
    while (true) {
        auto r = co_await stream.read(msg);
        if (!r || r.value()) break;
    }
    // 检查 msg.messageType() == RpcMessageType::STREAM_INIT_ACK

    // 3. 发送数据
    for (int i = 0; i < 10; ++i) {
        std::string data = "Message " + std::to_string(i);
        while (true) {
            auto r = co_await stream.sendData(data);
            if (!r || r.value()) break;
        }
    }

    // 4. 接收数据
    while (true) {
        StreamMessage recv_msg;
        while (true) {
            auto r = co_await stream.read(recv_msg);
            if (!r || r.value()) break;
        }
        if (recv_msg.isEnd()) break;
        std::cout << "Received: " << recv_msg.payloadStr() << "\n";
    }

    // 5. 结束流
    while (true) {
        auto r = co_await stream.sendEnd();
        if (!r || r.value()) break;
    }
}
```

---

## 服务发现

### 同步模式（单线程环境）

```cpp
#include "galay-rpc/kernel/ServiceDiscovery.h"

using namespace galay::rpc;

LocalServiceRegistry registry;

// 注册多个实例
ServiceEndpoint ep1{.host="10.0.0.1", .port=9000,
                    .service_name="EchoService", .instance_id="inst-1", .weight=100};
ServiceEndpoint ep2{.host="10.0.0.2", .port=9000,
                    .service_name="EchoService", .instance_id="inst-2", .weight=200};

registry.registerService(ep1);
registry.registerService(ep2);

// 轮询选择
ServiceDiscoveryClient<LocalServiceRegistry, RoundRobinSelector> client(registry);
auto result = client.getServiceEndpoint("EchoService");
// 第一次返回 inst-1 或 inst-2

// 加权随机选择（inst-2 被选中概率更高）
ServiceDiscoveryClient<LocalServiceRegistry, WeightedRandomSelector> client2(registry);
```

### 异步模式（协程环境）

```cpp
Coroutine asyncDiscovery() {
    AsyncLocalServiceRegistry registry;

    ServiceEndpoint ep;
  ep.service_name = "MyService";
    ep.host = "127.0.0.1";
    ep.port = 9000;
    ep.instance_id = "inst-1";

    // 异步注册
    co_await registry.registerServiceAsync(ep).wait();
    if (!registry.lastError().isOk()) {
        // 错误处理
    }

    // 异步发现
    co_await registry.discoverServiceAsync("MyService").wait();
    auto endpoints = registry.lastEndpoints();

    // 异步注销
    co_await registry.deregisterServiceAsync(ep).wait();
}
```

### 监听服务变更

```cpp
registry.watchService("EchoService", [](const ServiceEvent& event) {
    switch (event.type) {
        case ServiceEventType::ADDED:
            std::cout << "Added: " << event.endpoint.address() << "\n";
            break;
        case ServiceEventType::REMOVED:
            std::cout << "Removed: " << event.endpoint.address() << "\n";
            break;
        case ServiceEventType::UPDATED:
            std::cout << "Updated: " << event.endpoint.address() << "\n";
            break;
    }
});
```

### 自定义注册中心

实现 `ServiceRegistry` concept 即可接入 etcd、consul 等：

```cpp
class EtcdServiceRegistry {
public:
    EtcdServiceRegistry(const std::string& etcd_url);

    std::expected<void, DiscoveryError>
        registerService(const ServiceEndpoint& endpoint);
    std::expected<void, DiscoveryError>
        deregisterService(const ServiceEndpoint& endpoint);
    std::expected<std::vector<ServiceEndpoint>, DiscoveryError>
        discoverService(const std::string& service_name);
    std::expected<void, DiscoveryError>
        watchService(const std::string& service_name, ServiceWatchCallback callback);
    void unwatchService(const std::string& service_name);
};

// 编译时验证
static_assert(ServiceRegistry<EtcdServiceRegistry>);

// 使用
EtcdServiceRegistry etcd("http://localhost:2379");
ServiceDiscoveryClient<EtcdServiceRegistry> client(etcd);
```

---

## 超时控制

客户端调用支持通过 `.timeout(std::chrono::milliseconds(ms))` 设置超时：

```cpp
// 5 秒超时
while (true) {
    auto result = co_await client.call("Service", "method", "data")
        .timeout(std::chrono::milliseconds(5000));
    if (!result) {
        if (result.error().code() == RpcErrorCode::REQUEST_TIMEOUT) {
            std::cerr << "Request timed out\n";
        }
        break;
    }
    if (result.value()) break;
}
```

超时覆盖整个调用过程（发送 + 接收）。超时后返回 `RpcErrorCode::REQUEST_TIMEOUT`。

---

## 错误处理

### 错误来源

| 层级 | 错误码 | 触发场景 |
|------|--------|----------|
| 传输层 | CONNECTION_CLOSED | 对端关闭连接、网络断开 |
| 传输层 | REQUEST_TIMEOUT | 调用超时 |
| 协议层 | INVALID_REQUEST | 消息格式错误、魔数不匹配 |
| 协议层 | INVALID_RESPONSE | 响应格式错误 |
| 协议层 | SERIALIZATION_ERROR | 序列化失败 |
| 协议层 | DESERIALIZATION_ERROR | 反序列化失败 |
| 服务层 | SERVICE_NOT_FOUND | 请求的服务未注册 |
| 服务层 | METHOD_NOT_FOUND | 请求的方法未注册 |
| 通用 | INTERNAL_ERROR | 内部错误 |

### 客户端错误处理

```cpp
while (true) {
    auto result = co_await client.call("Service", "method", "data");

    if (!result) {
        // 传输层/协议层错误
        auto& error = result.error();
        switch (error.code()) {
            case RpcErrorCode::CONNECTION_CLOSED:
                // 需要重连
                break;
            case RpcErrorCode::REQUEST_TIMEOUT:
                // 可以重试
                break;
            default:
                std::cerr << error.toString() << "\n";
                break;
        }
        break;
    }

    if (result.value()) {
        auto& response = result.value().value();
        if (response.isOk()) {
            // 成功
        } else {
            // 服务层错误（SERVICE_NOT_FOUND, METHOD_NOT_FOUND 等）
            std::cerr << rpcErrorCodeToString(response.errorCode()) << "\n";
        }
        break;
    }
}
```

### 服务端错误处理

```cpp
Coroutine myMethod(RpcContext& ctx) {
    auto& payload = ctx.request().payload();

    if (payload.size() < 4) {
        ctx.setError(RpcErrorCode::INVALID_REQUEST);
        co_return;
    }

    // 正常处理...
    ctx.setPayload(result);
    co_return;
}
```

---

## 最佳实践

### 1. IO 调度器数量

- 服务端：设置为 CPU 核心数，或设为 0 让 Runtime 自动决定
- 客户端：1-2 个通常足够，除非有大量并发连接

### 2. RingBuffer 大小

- 默认 8KB 适合大多数场景
- 如果 payload 经常超过 4KB，考虑增大到 16KB 或 32KB
- 过大会浪费内存（每连接一个 RingBuffer）

### 3. 连接数选择

根据压测数据，100 连接时 QPS 最高（183K）。连接数过多会增加调度开销和延迟：

| 连接数 | QPS | P50 延迟 |
|--------|-----|----------|
| 50 | 170K | 223 us |
| 100 | 183K | 453 us |
| 200 | 170K | 973 us |

### 4. 循环 co_await 模式

所有 IO 操作都需要循环等待完成，这是 galay 系列库的统一编程模型：

```cpp
// 标准模式
while (true) {
    auto result = co_await someOperation();
    if (!result) break;       // 错误
    if (result.value()) break; // 完成
    // 继续
}
```

### 5. 服务设计

- 每个服务对应一个业务领域（如 UserService、OrderService）
- 方法名使用动词（如 get、create、update、delete）
- Payload 格式由应用层自行定义（可以用 protobuf、JSON 等）

### 6. 生产环境配置

```cpp
RpcServerConfig config;
config.host = "0.0.0.0";
config.port = 9000;
config.backlog = 1024;           // 高并发
config.io_scheduler_count = 0;   // 自动
config.ring_buffer_size = 8192;  // 默认即可
```

### 7. AsyncLocalServiceRegistry 并发注意

`AsyncLocalServiceRegistry` 的异步方法返回 `Coroutine`（`Awaitable&`），同一实例的同一方法不能被多个协程并发 `co_await`。多协程场景下：

- 方案 A：每个协程使用独立的 registry 实例
- 方案 B：串行化对同一 registry 的访问
