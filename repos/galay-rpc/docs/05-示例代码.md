# 05-示例代码

以下示例默认给出模块化导入版本：支持模块时使用 `import galay.rpc;`，否则按需包含对应头文件。

仓库中的可直接运行示例在 `examples/`：

- include 版本：`examples/include/E1-EchoServer.cc`、`examples/include/E2-EchoClient.cc` 等
- import 版本：`examples/import/E1-EchoServerImport.cc`、`examples/import/E2-EchoClientImport.cc` 等

## 基础 Echo 服务（Unary 模式）

### 服务端

```cpp
#include "galay-rpc/kernel/RpcServer.h"
#include "galay-rpc/kernel/RpcService.h"
#include <csignal>
#include <atomic>

using namespace galay::rpc;
using namespace galay::kernel;

class EchoService : public RpcService {
public:
    EchoService() : RpcService("EchoService") {
        registerMethod("echo", &EchoService::echo);
    }

    Coroutine echo(RpcContext& ctx) {
        auto& req = ctx.request();
        std::string input(req.payload().begin(), req.payload().end());

        std::cout << "Received: " << input << "\n";

        // 回显相同内容
        ctx.setPayload(req.payload().data(), req.payload().size());
        co_return;
    }
};

std::atomic<bool> g_running{true};

void signalHandler(int) {
    g_running.store(false);
}

int main(int argc, char* argv[]) {
    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " <port>\n";
        return 1;
    }

    std::signal(SIGINT, signalHandler);
    std::signal(SIGTERM, signalHandler);

    RpcServerConfig config;
    config.port = std::atoi(argv[1]);
    config.io_scheduler_count = 4;

    RpcServer server(config);
    server.registerService(std::make_shared<EchoService>());
    server.start();

    std::cout << "Server listening on port " << config.port << "\n";

    while (g_running.load() && server.isRunning()) {
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }

    server.stop();
    return 0;
}
```

### 客户端

```cpp
#include "galay-rpc/kernel/RpcClient.h"
#include "galay-kernel/kernel/Runtime.h"
#include <atomic>

using namespace galay::rpc;
using namespace galay::kernel;

struct State {
    std::atomic<bool> done{false};
};

Coroutine callEcho(const std::string& host, uint16_t port, State* state) {
    RpcClient client;

    // 连接服务器
    while (true) {
        auto result = co_await client.connect(host, port);
        if (!result) {
            std::cerr << "Connect failed: " << result.error().message() << "\n";
            state->done.store(true);
            co_return;
        }
        if (result.value()) break;
    }

    std::cout << "Connected to " << host << ":" << port << "\n";

    // 发送 10 次请求
    for (int i = 0; i < 10; ++i) {
        std::string message = "Hello " + std::to_string(i);

        while (true) {
            auto result = co_await client.call("EchoService", "echo", message);

            if (!result) {
                std::cerr << "Call failed: " << result.error().message() << "\n";
                break;
            }

            if (result.value()) {
                auto& response = result.value().value();
                if (response.isOk()) {
                    std::string data(response.payload().begin(), response.payload().end());
                    std::cout << "Response: " << data << "\n";
                } else {
                    std::cerr << "Error: " << rpcErrorCodeToString(response.errorCode()) << "\n";
                }
                break;
            }
        }

        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }

    co_await client.close();
    state->done.store(true);
}

int main(int argc, char* argv[]) {
    if (argc < 3) {
        std::cerr << "Usage: " << argv[0] << " <host> <port>\n";
        return 1;
    }

    Runtime runtime(1, 1);
    runtime.start();

    State state;
    runtime.getNextIOScheduler()->spawn(
        callEcho(argv[1], std::atoi(argv[2]), &state)
    );

    while (!state.done.load()) {
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
    }

    runtime.stop();
    return 0;
}
```

## 计算服务（多方法）

```cpp
class CalcService : public RpcService {
public:
    CalcService() : RpcService("CalcService") {
        registerMethod("add", &CalcService::add);
        registerMethod("multiply", &CalcService::multiply);
    }

    Coroutine add(RpcContext& ctx) {
        auto& payload = ctx.request().payload();
        if (payload.size() < 8) {
            ctx.setError(RpcErrorCode::INVALID_REQUEST);
            co_return;
        }

        int32_t a, b;
        std::memcpy(&a, payload.data(), 4);
        std::memcpy(&b, payload.data() + 4, 4);

        int32_t result = a + b;
        ctx.setPayload(&result, sizeof(result));
        co_return;
    }

    Coroutine multiply(RpcContext& ctx) {
        auto& payload = ctx.request().payload();
        if (payload.size() < 8) {
            ctx.setError(RpcErrorCode::INVALID_REQUEST);
            co_return;
        }

        int32_t a, b;
        std::memcpy(&a, payload.data(), 4);
        std::memcpy(&b, payload.data() + 4, 4);

        int32_t result = a * b;
        ctx.setPayload(&result, sizeof(result));
        co_return;
    }
};

// 客户端调用
Coroutine callCalc(RpcClient& client) {
    // 准备参数
    char data[8];
    int32_t a = 100, b = 200;
    std::memcpy(data, &a, 4);
    std::memcpy(data + 4, &b, 4);

    // 调用 add
    while (true) {
        auto result = co_await client.call("CalcService", "add", data, 8);
        if (!result) break;
        if (result.value()) {
            auto& response = result.value().value();
            if (response.isOk()) {
                int32_t sum;
                std::memcpy(&sum, response.payload().data(), 4);
                std::cout << a << " + " << b << " = " << sum << "\n";
            }
            break;
        }
    }
}
```

## 双向流示例

### 服务端流处理

```cpp
class StreamService : public RpcService {
public:
    StreamService() : RpcService("StreamService") {
        registerStreamMethod("bidirectional", &StreamService::bidirectional);
    }

    Coroutine bidirectional(RpcStream& stream) {
        // 接收并回显数据
        while (true) {
            StreamMessage msg;
            while (true) {
                auto r = co_await stream.read(msg);
                if (!r || r.value()) break;
            }

            if (msg.messageType() == RpcMessageType::STREAM_END) {
                // 客户端结束流
                break;
            }

            if (msg.messageType() == RpcMessageType::STREAM_DATA) {
                std::string data = msg.payloadStr();
                std::cout << "Received: " << data << "\n";

                // 回显数据
                while (true) {
                    auto r = co_await stream.sendData(data);
                    if (!r || r.value()) break;
                }
            }
        }

        // 发送结束
        while (true) {
            auto r = co_await stream.sendEnd();
            if (!r || r.value()) break;
        }

        co_return;
    }
};
```

### 客户端流调用

```cpp
Coroutine callStream(RpcClient& client) {
    // 先建立连接
    co_await client.connect("127.0.0.1", 9000);

    // 创建流会话（不暴露底层 socket/ringBuffer）
    auto stream_result = client.createStream(1, "StreamService", "bidirectional");
    if (!stream_result.has_value()) {
        co_return;
    }
    auto stream = stream_result.value();

    // 1. 发送初始化
    while (true) {
        auto r = co_await stream.sendInit();
        if (!r || r.value()) break;
    }

    // 2. 等待确认
    StreamMessage msg;
    while (true) {
        auto r = co_await stream.read(msg);
        if (!r || r.value()) break;
    }

    if (msg.messageType() != RpcMessageType::STREAM_INIT_ACK) {
        std::cerr << "Stream init failed\n";
        co_return;
    }

    // 3. 发送数据
    for (int i = 0; i < 5; ++i) {
        std::string data = "Message " + std::to_string(i);
        while (true) {
            auto r = co_await stream.sendData(data);
            if (!r || r.value()) break;
        }
    }

    // 4. 接收响应
    for (int i = 0; i < 5; ++i) {
        StreamMessage recv_msg;
        while (true) {
            auto r = co_await stream.read(recv_msg);
            if (!r || r.value()) break;
        }
        std::cout << "Echo: " << recv_msg.payloadStr() << "\n";
    }

    // 5. 结束流
    while (true) {
        auto r = co_await stream.sendEnd();
        if (!r || r.value()) break;
    }

    // 等待服务端结束确认
    while (true) {
        auto r = co_await stream.read(msg);
        if (!r || r.value()) break;
    }

    co_await client.close();
}
```

## 服务发现示例

### 本地注册中心

```cpp
#include "galay-rpc/kernel/ServiceDiscovery.h"

using namespace galay::rpc;

// 创建本地注册中心
LocalServiceRegistry registry;

// 注册多个服务实例
ServiceEndpoint ep1{
    .host = "10.0.0.1",
    .port = 9000,
    .service_name = "EchoService",
    .instance_id = "echo-1",
    .weight = 100
};

ServiceEndpoint ep2{
    .host = "10.0.0.2",
    .port = 9000,
    .service_name = "EchoService",
    .instance_id = "echo-2",
    .weight = 200
};

registry.registerService(ep1);
registry.registerService(ep2);

// 使用轮询选择器
ServiceDiscoveryClient<LocalServiceRegistry, RoundRobinSelector> client(registry);

auto result = client.getServiceEndpoint("EchoService");
if (result) {
    auto& endpoint = result.value();
    std::cout << "Selected: " << endpoint.address() << "\n";
}

// 使用加权随机选择器
ServiceDiscoveryClient<LocalServiceRegistry, WeightedRandomSelector> client2(registry);
```

### 监听服务变更

```cpp
registry.watchService("EchoService", [](const ServiceEvent& event) {
    switch (event.type) {
        case ServiceEventType::ADDED:
            std::cout << "Service added: " << event.endpoint.address() << "\n";
            break;
        case ServiceEventType::REMOVED:
            std::cout << "Service removed: " << event.endpoint.address() << "\n";
            break;
        case ServiceEventType::UPDATED:
            std::cout << "Service updated: " << event.endpoint.address() << "\n";
            break;
    }
});

// 注册新实例会触发回调
ServiceEndpoint ep3{
    .host = "10.0.0.3",
    .port = 9000,
    .service_name = "EchoService",
    .instance_id = "echo-3",
    .weight = 150
};
registry.registerService(ep3);
```

### 异步注册中心

```cpp
Coroutine useAsyncRegistry() {
    AsyncLocalServiceRegistry registry;

    ServiceEndpoint ep{
        .host = "127.0.0.1",
        .port = 9000,
        .service_name = "MyService",
        .instance_id = "inst-1",
        .weight = 100
    };

    // 异步注册
    co_await registry.registerServiceAsync(ep).wait();
    if (!registry.lastError().isOk()) {
        std::cerr << "Register failed\n";
        co_return;
    }

    // 异步发现
    co_await registry.discoverServiceAsync("MyService").wait();
    auto endpoints = registry.lastEndpoints();

    for (const auto& e : endpoints) {
        std::cout << "Found: " << e.address() << "\n";
    }

    // 异步注销
    co_await registry.deregisterServiceAsync(ep).wait();
}
```

## 超时控制示例

```cpp
Coroutine callWithTimeout(RpcClient& client) {
    co_await client.connect("127.0.0.1", 9000);

    // 设置 5 秒超时
    while (true) {
        auto result = co_await client.call("Service", "method", "data")
            .timeout(std::chrono::milliseconds(5000));

        if (!result) {
            if (result.error().code() == RpcErrorCode::REQUEST_TIMEOUT) {
                std::cerr << "Request timed out\n";
            } else {
                std::cerr << "Error: " << result.error().message() << "\n";
            }
            break;
        }

        if (result.value()) {
            auto& response = result.value().value();
            // 处理响应
            break;
        }
    }

    co_await client.close();
}
```

## 错误处理最佳实践

```cpp
Coroutine robustCall(RpcClient& client) {
    // 连接重试
    int retries = 0;
    const int max_retries = 3;

    while (retries < max_retries) {
        auto result = co_await client.connect("127.0.0.1", 9000);
        if (result) break;

        retries++;
        if (retries < max_retries) {
            std::cerr << "Connect failed, retrying...\n";
            std::this_thread::sleep_for(std::chrono::seconds(1));
        }
    }

    if (retries >= max_retries) {
        std::cerr << "Failed to connect after " << max_retries << " attempts\n";
        co_return;
    }

    // RPC 调用错误处理
    while (true) {
        auto result = co_await client.call("Service", "method", "data");

        if (!result) {
            auto& error = result.error();
            switch (error.code()) {
                case RpcErrorCode::CONNECTION_CLOSED:
                    std::cerr << "Connection closed, need reconnect\n";
                    break;
                case RpcErrorCode::REQUEST_TIMEOUT:
                    std::cerr << "Request timeout, can retry\n";
                    break;
                case RpcErrorCode::SERVICE_NOT_FOUND:
                    std::cerr << "Service not found\n";
                    break;
                case RpcErrorCode::METHOD_NOT_FOUND:
                    std::cerr << "Method not found\n";
                    break;
                default:
                    std::cerr << "Error: " << error.message() << "\n";
                    break;
            }
            break;
        }

        if (result.value()) {
            auto& response = result.value().value();
            if (response.isOk()) {
                // 成功处理
                std::cout << "Success\n";
            } else {
                std::cerr << "Server error: "
                          << rpcErrorCodeToString(response.errorCode()) << "\n";
            }
            break;
        }
    }

    co_await client.close();
}
```

## 多服务注册示例

```cpp
int main() {
    RpcServerConfig config;
    config.port = 9000;
    config.io_scheduler_count = 4;

    RpcServer server(config);

    // 注册多个服务
    server.registerService(std::make_shared<EchoService>());
    server.registerService(std::make_shared<CalcService>());
    server.registerService(std::make_shared<StreamService>());

    server.start();

    std::cout << "Server started with 3 services\n";

    while (server.isRunning()) {
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }

    return 0;
}
```

## 测试程序运行

```bash
# 协议测试
./build/test/T1-RpcProtocolTest

# 服务端测试（终端 1）
./build/test/T2-RpcServerTest 9750

# 客户端测试（终端 2）
./build/test/T3-RpcClientTest 127.0.0.1 9750

# Echo 示例
./build/examples/E1-EchoServer 9000
./build/examples/E2-EchoClient 127.0.0.1 9000

# Stream 示例
./build/examples/E3-StreamServer 9100 1 131072
./build/examples/E4-StreamClient 127.0.0.1 9100 200 64
```
