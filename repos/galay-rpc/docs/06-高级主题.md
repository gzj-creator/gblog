# 06-高级主题

## 负载均衡策略

### 轮询选择器（RoundRobinSelector）

轮询选择器按顺序依次选择服务实例，适合实例性能相近的场景。

```cpp
#include "galay-rpc/kernel/ServiceDiscovery.h"

LocalServiceRegistry registry;

// 注册多个实例
ServiceEndpoint ep1{.host="10.0.0.1", .port=9000, .service_name="EchoService", .instance_id="inst-1"};
ServiceEndpoint ep2{.host="10.0.0.2", .port=9000, .service_name="EchoService", .instance_id="inst-2"};
ServiceEndpoint ep3{.host="10.0.0.3", .port=9000, .service_name="EchoService", .instance_id="inst-3"};

registry.registerService(ep1);
registry.registerService(ep2);
registry.registerService(ep3);

// 使用轮询选择器
ServiceDiscoveryClient<LocalServiceRegistry, RoundRobinSelector> client(registry);

// 第一次调用返回 inst-1
auto result1 = client.getServiceEndpoint("EchoService");

// 第二次调用返回 inst-2
auto result2 = client.getServiceEndpoint("EchoService");

// 第三次调用返回 inst-3
auto result3 = client.getServiceEndpoint("EchoService");

// 第四次调用返回 inst-1（循环）
auto result4 = client.getServiceEndpoint("EchoService");
```

### 加权随机选择器（WeightedRandomSelector）

加权随机选择器根据权重随机选择实例，权重越高被选中概率越大，适合实例性能不均的场景。

```cpp
// 注册不同权重的实例
ServiceEndpoint ep1{.host="10.0.0.1", .port=9000, .service_name="EchoService", .instance_id="inst-1", .weight=100};
ServiceEndpoint ep2{.host="10.0.0.2", .port=9000, .service_name="EchoService", .instance_id="inst-2", .weight=200};
ServiceEndpoint ep3{.host="10.0.0.3", .port=9000, .service_name="EchoService", .instance_id="inst-3", .weight=50};

registry.registerService(ep1);
registry.registerService(ep2);
registry.registerService(ep3);

// 使用加权随机选择器
ServiceDiscoveryClient<LocalServiceRegistry, WeightedRandomSelector> client(registry);

// inst-2 被选中概率最高（200/350 ≈ 57%）
// inst-1 被选中概率次之（100/350 ≈ 29%）
// inst-3 被选中概率最低（50/350 ≈ 14%）
auto result = client.getServiceEndpoint("EchoService");
```

### 自定义选择器

galay-rpc 使用 galay-kernel 的负载均衡器。自定义选择器需要实现相同的接口：

```cpp
// 最少连接选择器
class LeastConnectionSelector {
private:
    std::vector<ServiceEndpoint> m_endpoints;
    std::unordered_map<std::string, size_t> m_connections;

public:
    LeastConnectionSelector() = default;

    LeastConnectionSelector(const std::vector<ServiceEndpoint>& endpoints)
        : m_endpoints(endpoints) {}

    std::optional<ServiceEndpoint> select() {
        if (m_endpoints.empty()) return std::nullopt;

        // 选择连接数最少的实例
        auto it = std::min_element(m_endpoints.begin(), m_endpoints.end(),
            [this](const ServiceEndpoint& a, const ServiceEndpoint& b) {
                return m_connections[a.instance_id] < m_connections[b.instance_id];
            });

        return *it;
    }

    void onConnect(const std::string& instance_id) {
        m_connections[instance_id]++;
    }

    void onDisconnect(const std::string& instance_id) {
        if (m_connections[instance_id] > 0) {
            m_connections[instance_id]--;
        }
    }
};

// 使用自定义选择器
ServiceDiscoveryClient<LocalServiceRegistry, LeastConnectionSelector> client(registry);
```

## 服务发现集成

### 集成 etcd

```cpp
#include <etcd/Client.hpp>

class EtcdServiceRegistry {
private:
    etcd::Client m_client;
    std::string m_prefix;

public:
    EtcdServiceRegistry(const std::string& etcd_url, const std::string& prefix = "/services/")
        : m_client(etcd_url), m_prefix(prefix) {}

    std::expected<void, DiscoveryError> registerService(const ServiceEndpoint& endpoint) {
        std::string key = m_prefix + endpoint.service_name + "/" + endpoint.instance_id;

        // 手动序列化 ServiceEndpoint
        std::string value = endpoint.host + ":" + std::to_string(endpoint.port) +
                           ":" + std::to_string(endpoint.weight);

        auto response = m_client.set(key, value).get();
        if (!response.is_ok()) {
            return std::unexpected(DiscoveryError(
                DiscoveryError::INTERNAL_ERROR,
                response.error_message()
            ));
        }

        return {};
    }

    std::expected<void, DiscoveryError> deregisterService(const ServiceEndpoint& endpoint) {
        std::string key = m_prefix + endpoint.service_name + "/" + endpoint.instance_id;

        auto response = m_client.rm(key).get();
        if (!response.is_ok()) {
            return std::unexpected(DiscoveryError(
                DiscoveryError::INTERNAL_ERROR,
                response.error_message()
            ));
        }

        return {};
    }

    std::expected<std::vector<ServiceEndpoint>, DiscoveryError>
    discoverService(const std::string& service_name) {
        std::string key = m_prefix + service_name;

        auto response = m_client.ls(key).get();
        if (!response.is_ok()) {
            return std::unexpected(DiscoveryError(
                DiscoveryError::INTERNAL_ERROR,
                response.error_message()
            ));
        }

        std::vector<ServiceEndpoint> endpoints;
        for (const auto& kv : response.keys()) {
            // 手动解析 ServiceEndpoint
            ServiceEndpoint ep;
            // 解析逻辑略...
            endpoints.push_back(ep);
        }

        return endpoints;
    }

    std::expected<void, DiscoveryError>
    watchService(const std::string& service_name, ServiceWatchCallback callback) {
        std::string key = m_prefix + service_name;

        m_client.watch(key, [callback](etcd::Response response) {
            if (response.action() == "set") {
                ServiceEvent event{
                    .type = ServiceEventType::ADDED,
                    .endpoint = ServiceEndpoint::fromJson(response.value().as_string())
                };
                callback(event);
            } else if (response.action() == "delete") {
                ServiceEvent event{
                    .type = ServiceEventType::REMOVED,
                    .endpoint = ServiceEndpoint::fromJson(response.prev_value().as_string())
                };
                callback(event);
            }
        });

        return {};
    }

    void unwatchService(const std::string& service_name) {
        // etcd 客户端会自动管理 watch
    }
};

// 编译时验证
static_assert(ServiceRegistry<EtcdServiceRegistry>);

// 使用
EtcdServiceRegistry etcd("http://localhost:2379");
ServiceDiscoveryClient<EtcdServiceRegistry, RoundRobinSelector> client(etcd);
```

### 集成 Consul

```cpp
class ConsulServiceRegistry {
private:
    std::string m_consul_url;
    std::string m_datacenter;

public:
    ConsulServiceRegistry(const std::string& consul_url, const std::string& datacenter = "dc1")
        : m_consul_url(consul_url), m_datacenter(datacenter) {}

    std::expected<void, DiscoveryError> registerService(const ServiceEndpoint& endpoint) {
        // 构造 Consul 注册请求
        nlohmann::json payload = {
            {"ID", endpoint.instance_id},
            {"Name", endpoint.service_name},
            {"Address", endpoint.host},
            {"Port", endpoint.port},
            {"Meta", {{"weight", std::to_string(endpoint.weight)}}}
        };

        // 发送 HTTP PUT 请求到 /v1/agent/service/register
        // 实现略...

        return {};
    }

    std::expected<std::vector<ServiceEndpoint>, DiscoveryError>
    discoverService(const std::string& service_name) {
        // 发送 HTTP GET 请求到 /v1/health/service/{service_name}
        // 解析响应并构造 ServiceEndpoint 列表
        // 实现略...

        return endpoints;
    }

    // 其他方法实现...
};
```

## 超时与重试策略

### 请求超时

```cpp
Coroutine callWithTimeout(RpcClient& client) {
    co_await client.connect("127.0.0.1", 9000);

    // 设置 5 秒超时
    while (true) {
        auto result = co_await client.call("Service", "method", "data")
            .timeout(std::chrono::milliseconds(5000));

        if (!result) {
            if (result.error().code() == RpcErrorCode::REQUEST_TIMEOUT) {
                std::cerr << "Request timed out\n";
            }
            break;
        }

        if (result.value()) break;
    }

    co_await client.close();
}
```

### 指数退避重试

```cpp
Coroutine callWithRetry(RpcClient& client, int max_retries = 3) {
    co_await client.connect("127.0.0.1", 9000);

    int retries = 0;
    int backoff_ms = 100;

    while (retries < max_retries) {
        while (true) {
            auto result = co_await client.call("Service", "method", "data")
                .timeout(std::chrono::milliseconds(5000));

            if (!result) {
                auto& error = result.error();
                if (error.code() == RpcErrorCode::REQUEST_TIMEOUT ||
                    error.code() == RpcErrorCode::CONNECTION_CLOSED) {
                    // 可重试错误
                    retries++;
                    if (retries < max_retries) {
                        std::cerr << "Retry " << retries << " after " << backoff_ms << "ms\n";
                        std::this_thread::sleep_for(std::chrono::milliseconds(backoff_ms));
                        backoff_ms *= 2;  // 指数退避
                        break;
                    }
                }
                co_return;
            }

            if (result.value()) {
                // 成功
                co_return;
            }
        }
    }

    std::cerr << "Failed after " << max_retries << " retries\n";
    co_await client.close();
}
```

### 熔断器模式

```cpp
class CircuitBreaker {
public:
    enum class State { CLOSED, OPEN, HALF_OPEN };

private:
    State m_state = State::CLOSED;
    size_t m_failure_count = 0;
    size_t m_failure_threshold = 5;
    std::chrono::steady_clock::time_point m_open_time;
    std::chrono::milliseconds m_timeout{30000};

public:
    bool allowRequest() {
        if (m_state == State::CLOSED) {
            return true;
        }

        if (m_state == State::OPEN) {
            auto now = std::chrono::steady_clock::now();
            if (now - m_open_time >= m_timeout) {
                m_state = State::HALF_OPEN;
                return true;
            }
            return false;
        }

        // HALF_OPEN 状态允许一个请求
        return true;
    }

    void recordSuccess() {
        if (m_state == State::HALF_OPEN) {
            m_state = State::CLOSED;
            m_failure_count = 0;
        }
    }

    void recordFailure() {
        m_failure_count++;

        if (m_state == State::HALF_OPEN) {
            m_state = State::OPEN;
            m_open_time = std::chrono::steady_clock::now();
        } else if (m_failure_count >= m_failure_threshold) {
            m_state = State::OPEN;
            m_open_time = std::chrono::steady_clock::now();
        }
    }
};

Coroutine callWithCircuitBreaker(RpcClient& client, CircuitBreaker& breaker) {
    if (!breaker.allowRequest()) {
        std::cerr << "Circuit breaker is OPEN\n";
        co_return;
    }

    co_await client.connect("127.0.0.1", 9000);

    while (true) {
        auto result = co_await client.call("Service", "method", "data");

        if (!result) {
            breaker.recordFailure();
            break;
        }

        if (result.value()) {
            breaker.recordSuccess();
            break;
        }
    }

    co_await client.close();
}
```

## 流式传输优化

### 窗口化流控制

```cpp
class WindowedStreamWriter {
private:
    StreamWriter& m_writer;
    size_t m_window_size;
    size_t m_in_flight = 0;

public:
    WindowedStreamWriter(StreamWriter& writer, size_t window_size = 8)
        : m_writer(writer), m_window_size(window_size) {}

    Coroutine sendData(const std::string& data) {
        // 等待窗口有空位
        while (m_in_flight >= m_window_size) {
            co_await std::suspend_always{};
        }

        m_in_flight++;

        while (true) {
            auto r = co_await m_writer.sendData(data);
            if (!r || r.value()) {
                m_in_flight--;
                break;
            }
        }
    }
};

Coroutine streamWithWindow(RpcClient& client) {
    co_await client.connect("127.0.0.1", 9000);

    auto stream_result = client.createStream(1, "Service", "method");
    if (!stream_result.has_value()) co_return;
    auto stream = stream_result.value();
    auto& writer = stream.getWriter();

    // 初始化流
    while (true) {
        auto r = co_await stream.sendInit();
        if (!r || r.value()) break;
    }

    // 使用窗口化写入
    WindowedStreamWriter windowed_writer(writer, 8);

    for (int i = 0; i < 1000; ++i) {
        std::string data = "Frame " + std::to_string(i);
        co_await windowed_writer.sendData(data);
    }

    // 结束流
    while (true) {
        auto r = co_await writer.sendEnd();
        if (!r || r.value()) break;
    }

    co_await client.close();
}
```

### 批量数据传输

```cpp
Coroutine batchStreamTransfer(RpcClient& client, const std::vector<std::string>& data_list) {
    co_await client.connect("127.0.0.1", 9000);

    auto stream_result = client.createStream(1, "Service", "batchMethod");
    if (!stream_result.has_value()) co_return;
    auto stream = stream_result.value();
    auto& writer = stream.getWriter();
    auto& reader = stream.getReader();

    // 初始化
    while (true) {
        auto r = co_await stream.sendInit();
        if (!r || r.value()) break;
    }

    // 等待确认
    StreamMessage msg;
    while (true) {
        auto r = co_await reader.getMessage(msg);
        if (!r || r.value()) break;
    }

    // 批量发送
    const size_t batch_size = 100;
    for (size_t i = 0; i < data_list.size(); i += batch_size) {
        size_t end = std::min(i + batch_size, data_list.size());

        // 合并批次数据
        std::string batch_data;
        for (size_t j = i; j < end; ++j) {
            batch_data += data_list[j];
            if (j < end - 1) batch_data += "\n";
        }

        // 发送批次
        while (true) {
            auto r = co_await writer.sendData(batch_data);
            if (!r || r.value()) break;
        }
    }

    // 结束
    while (true) {
        auto r = co_await writer.sendEnd();
        if (!r || r.value()) break;
    }

    co_await client.close();
}
```

## 性能优化

### 连接池

虽然 galay-rpc 客户端本身不内置连接池，但可以自行实现：

```cpp
class RpcClientPool {
private:
    std::vector<std::unique_ptr<RpcClient>> m_clients;
    std::queue<RpcClient*> m_available;
    std::mutex m_mutex;
    std::condition_variable m_cv;
    size_t m_pool_size;

public:
    RpcClientPool(size_t pool_size) : m_pool_size(pool_size) {
        for (size_t i = 0; i < pool_size; ++i) {
            auto client = std::make_unique<RpcClient>();
            m_available.push(client.get());
            m_clients.push_back(std::move(client));
        }
    }

    RpcClient* acquire() {
        std::unique_lock<std::mutex> lock(m_mutex);
        m_cv.wait(lock, [this] { return !m_available.empty(); });

        RpcClient* client = m_available.front();
        m_available.pop();
        return client;
    }

    void release(RpcClient* client) {
        std::lock_guard<std::mutex> lock(m_mutex);
        m_available.push(client);
        m_cv.notify_one();
    }
};

Coroutine usePool(RpcClientPool& pool) {
    RpcClient* client = pool.acquire();

    // 使用客户端
    while (true) {
        auto result = co_await client->call("Service", "method", "data");
        if (!result || result.value()) break;
    }

    pool.release(client);
}
```

### RingBuffer 大小调优

```cpp
RpcServerConfig config;
config.ring_buffer_size = 8192;   // 默认 8KB，适合大多数场景

// 如果 payload 经常超过 4KB，考虑增大
config.ring_buffer_size = 16384;  // 16KB

// 如果 payload 很小（< 1KB），可以减小以节省内存
config.ring_buffer_size = 4096;   // 4KB
```

### IO 调度器数量

```cpp
RpcServerConfig config;

// 方案 1：自动检测（推荐）
config.io_scheduler_count = 0;  // 自动设置为 CPU 核心数

// 方案 2：手动设置
config.io_scheduler_count = 4;  // 4 个 IO 调度器

// 方案 3：根据负载调整
// 低负载：1-2 个
// 中等负载：4-8 个
// 高负载：8-16 个（不超过 CPU 核心数）
```

### 减少内存拷贝

```cpp
// 低效：多次拷贝
std::string data = "Hello";
co_await client.call("Service", "method", data);

// 高效：直接传递指针和长度
const char* data = "Hello";
size_t len = 5;
co_await client.call("Service", "method", data, len);

// 服务端零拷贝响应
Coroutine myMethod(RpcContext& ctx) {
    auto& req = ctx.request();
    // 直接使用请求的 payload，不拷贝
    ctx.setPayload(req.payload().data(), req.payload().size());
    co_return;
}
```

## 安全性

### 请求验证

```cpp
class SecureService : public RpcService {
public:
    SecureService() : RpcService("SecureService") {
        registerMethod("secureMethod", &SecureService::secureMethod);
    }

    Coroutine secureMethod(RpcContext& ctx) {
        auto& req = ctx.request();

        // 验证 payload 大小
        if (req.payload().size() > 1024 * 1024) {  // 1MB 限制
            ctx.setError(RpcErrorCode::INVALID_REQUEST);
            co_return;
        }

        // 验证 payload 格式
        if (!isValidFormat(req.payload())) {
            ctx.setError(RpcErrorCode::INVALID_REQUEST);
            co_return;
        }

        // 处理请求
        processRequest(ctx);
        co_return;
    }

private:
    bool isValidFormat(const std::vector<char>& payload) {
        // 实现格式验证逻辑
        return true;
    }

    void processRequest(RpcContext& ctx) {
        // 实现业务逻辑
    }
};
```

### 速率限制

```cpp
class RateLimiter {
private:
    size_t m_max_requests;
    std::chrono::milliseconds m_window;
    std::deque<std::chrono::steady_clock::time_point> m_requests;
    std::mutex m_mutex;

public:
    RateLimiter(size_t max_requests, std::chrono::milliseconds window)
        : m_max_requests(max_requests), m_window(window) {}

    bool allowRequest() {
        std::lock_guard<std::mutex> lock(m_mutex);

        auto now = std::chrono::steady_clock::now();

        // 移除过期请求
        while (!m_requests.empty() && now - m_requests.front() > m_window) {
            m_requests.pop_front();
        }

        // 检查是否超过限制
        if (m_requests.size() >= m_max_requests) {
            return false;
        }

        m_requests.push_back(now);
        return true;
    }
};

class RateLimitedService : public RpcService {
private:
    RateLimiter m_limiter{100, std::chrono::seconds(1)};  // 100 req/s

public:
    RateLimitedService() : RpcService("RateLimitedService") {
        registerMethod("method", &RateLimitedService::method);
    }

    Coroutine method(RpcContext& ctx) {
        if (!m_limiter.allowRequest()) {
            ctx.setError(RpcErrorCode::INTERNAL_ERROR);  // 或自定义错误码
            co_return;
        }

        // 处理请求
        processRequest(ctx);
        co_return;
    }

private:
    void processRequest(RpcContext& ctx) {
        // 实现业务逻辑
    }
};
```

## 监控与日志

### 请求日志

```cpp
class LoggingService : public RpcService {
public:
    LoggingService() : RpcService("LoggingService") {
        registerMethod("method", &LoggingService::method);
    }

    Coroutine method(RpcContext& ctx) {
        auto& req = ctx.request();
        auto start = std::chrono::steady_clock::now();

        // 记录请求
        spdlog::info("Request: service={}, method={}, size={}",
                     req.serviceName(), req.methodName(), req.payload().size());

        // 处理请求
        processRequest(ctx);

        auto end = std::chrono::steady_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);

        // 记录响应
        spdlog::info("Response: service={}, method={}, duration={}us",
                     req.serviceName(), req.methodName(), duration.count());

        co_return;
    }

private:
    void processRequest(RpcContext& ctx) {
        // 实现业务逻辑
    }
};
```

### 性能指标

```cpp
class MetricsCollector {
private:
    std::atomic<uint64_t> m_total_requests{0};
    std::atomic<uint64_t> m_failed_requests{0};
    std::atomic<uint64_t> m_total_duration_us{0};

public:
    void recordRequest(bool success, uint64_t duration_us) {
        m_total_requests.fetch_add(1);
        if (!success) {
            m_failed_requests.fetch_add(1);
        }
        m_total_duration_us.fetch_add(duration_us);
    }

    void printMetrics() {
        uint64_t total = m_total_requests.load();
        uint64_t failed = m_failed_requests.load();
        uint64_t duration = m_total_duration_us.load();

        std::cout << "Total requests: " << total << "\n";
        std::cout << "Failed requests: " << failed << "\n";
        std::cout << "Success rate: " << (100.0 * (total - failed) / total) << "%\n";
        std::cout << "Average latency: " << (duration / total) << " us\n";
    }
};

class MetricsService : public RpcService {
private:
    MetricsCollector& m_metrics;

public:
    MetricsService(MetricsCollector& metrics)
        : RpcService("MetricsService"), m_metrics(metrics) {
        registerMethod("method", &MetricsService::method);
    }

    Coroutine method(RpcContext& ctx) {
        auto start = std::chrono::steady_clock::now();
        bool success = false;

        try {
            processRequest(ctx);
            success = true;
        } catch (...) {
            ctx.setError(RpcErrorCode::INTERNAL_ERROR);
        }

        auto end = std::chrono::steady_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);

        m_metrics.recordRequest(success, duration.count());

        co_return;
    }

private:
    void processRequest(RpcContext& ctx) {
        // 实现业务逻辑
    }
};
```

## 与其他框架集成

### 与 galay-http 集成

```cpp
#include "galay-http/server/HttpServer.h"
#include "galay-rpc/kernel/RpcClient.h"

using namespace galay::http;
using namespace galay::rpc;

Coroutine handleHttpRequest(HttpRequest& req, HttpResponse& resp, RpcClient& rpc_client) {
    // 从 HTTP 请求中提取参数
    std::string service = req.getParam("service");
    std::string method = req.getParam("method");
    std::string data = req.body();

    // 调用 RPC 服务
    while (true) {
        auto result = co_await rpc_client.call(service, method, data);

        if (!result) {
            resp.setStatus(500);
            resp.setBody("RPC call failed");
            break;
        }

        if (result.value()) {
            auto& response = result.value().value();
            if (response.isOk()) {
                resp.setStatus(200);
                resp.setBody(std::string(response.payload().begin(), response.payload().end()));
            } else {
                resp.setStatus(500);
                resp.setBody("RPC error");
            }
            break;
        }
    }
}
```

### 与 JSON 序列化集成

```cpp
#include <nlohmann/json.hpp>

class JsonRpcService : public RpcService {
public:
    JsonRpcService() : RpcService("JsonRpcService") {
        registerMethod("getUserInfo", &JsonRpcService::getUserInfo);
    }

    Coroutine getUserInfo(RpcContext& ctx) {
        auto& req = ctx.request();

        // 解析 JSON 请求
        std::string json_str(req.payload().begin(), req.payload().end());
        nlohmann::json req_json = nlohmann::json::parse(json_str);

        int user_id = req_json["user_id"];

        // 查询用户信息
        nlohmann::json resp_json = {
            {"user_id", user_id},
            {"name", "Alice"},
            {"age", 25},
            {"email", "alice@example.com"}
        };

        // 序列化 JSON 响应
        std::string resp_str = resp_json.dump();
        ctx.setPayload(resp_str);

        co_return;
    }
};
```
