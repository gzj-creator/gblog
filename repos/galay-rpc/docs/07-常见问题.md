# 07-常见问题

## 编译相关

### Q: 编译时找不到 galay-kernel 头文件

**A:** 确保 CMake 能找到依赖库，使用 `CMAKE_PREFIX_PATH` 指定：

```bash
cmake -S . -B build \
  -DCMAKE_PREFIX_PATH="/path/to/galay-kernel;/path/to/galay-utils"
```

或者设置环境变量：

```bash
export CMAKE_PREFIX_PATH="/path/to/galay-kernel:/path/to/galay-utils"
cmake -S . -B build
```

### Q: 链接时出现 undefined reference 错误

**A:** 检查链接库是否完整：

```cmake
target_link_libraries(your_target PRIVATE
    galay-rpc
    galay-kernel
    spdlog::spdlog
)
```

### Q: 模块编译失败

**A:** 模块编译有严格的工具链要求：

- CMake >= 3.28
- Ninja 或 Visual Studio 生成器
- 支持 C++23 模块的编译器（GCC 11+、Clang 14+、AppleClang 15+）

不满足条件时会自动降级到 include 路径。检查工具链版本：

```bash
cmake --version
g++ --version  # 或 clang++ --version
ninja --version
```

### Q: 编译时出现 C++23 特性不支持

**A:** 确保编译器支持 C++23：

```bash
# GCC
g++ --version  # 需要 >= 11

# Clang
clang++ --version  # 需要 >= 14

# AppleClang
clang++ --version  # 需要 >= 15
```

在 CMakeLists.txt 中显式指定：

```cmake
set(CMAKE_CXX_STANDARD 23)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
```

## 连接相关

### Q: 客户端连接失败：Connection refused

**A:** 检查以下几点：

1. 服务器是否运行：
   ```bash
   ps aux | grep RpcServer
   ```

2. 端口是否正确（检查服务器监听端口）

3. 防火墙是否允许连接：
   ```bash
   # Linux
   sudo ufw allow 9000

   # macOS
   sudo pfctl -d  # 临时禁用防火墙测试
   ```

4. 服务器是否监听正确的地址：
   ```cpp
   RpcServerConfig config;
   config.host = "0.0.0.0";  // 监听所有接口
   config.port = 9000;
   ```

### Q: 连接一段时间后断开

**A:** 可能原因：

1. 网络不稳定
2. 服务器主动关闭连接
3. 防火墙超时

解决方案：

- 实现心跳机制（当前版本预留了 HEARTBEAT 消息类型）
- 客户端检测连接状态并自动重连
- 调整防火墙超时设置

### Q: 如何实现连接重试？

**A:** 使用循环重试：

```cpp
Coroutine connectWithRetry(RpcClient& client, const std::string& host, uint16_t port) {
    int retries = 0;
    const int max_retries = 5;

    while (retries < max_retries) {
        while (true) {
            auto result = co_await client.connect(host, port);
            if (!result) {
                retries++;
                if (retries < max_retries) {
                    std::cerr << "Connect failed, retry " << retries << "\n";
                    std::this_thread::sleep_for(std::chrono::seconds(1));
                    break;
                }
                co_return;
            }
            if (result.value()) {
                std::cout << "Connected successfully\n";
                co_return;
            }
        }
    }
}
```

## RPC 调用相关

### Q: 为什么需要循环 co_await？

**A:** galay-rpc 的 IO 操作可能部分完成，需要循环等待直到完成：

```cpp
// 标准模式
while (true) {
    auto result = co_await client.call("Service", "method", "data");

    if (!result) {
        // 错误：连接关闭、超时等
        break;
    }

    if (result.value()) {
        // 完成：拿到响应
        break;
    }

    // result.value() == std::nullopt，操作未完成，继续循环
}
```

### Q: 调用返回 SERVICE_NOT_FOUND 错误

**A:** 检查以下几点：

1. 服务是否已注册：
   ```cpp
   server.registerService(std::make_shared<EchoService>());
   ```

2. 服务名是否正确（区分大小写）：
   ```cpp
   // 服务端
   class EchoService : public RpcService {
   public:
       EchoService() : RpcService("EchoService") {}  // 注意大小写
   };

   // 客户端
   co_await client.call("EchoService", "echo", "data");  // 必须匹配
   ```

### Q: 调用返回 METHOD_NOT_FOUND 错误

**A:** 检查方法是否已注册：

```cpp
class MyService : public RpcService {
public:
    MyService() : RpcService("MyService") {
        registerMethod("myMethod", &MyService::myMethod);  // 必须注册
    }

    Coroutine myMethod(RpcContext& ctx) {
        // ...
    }
};
```

### Q: 如何传递复杂数据类型？

**A:** 需要自行序列化/反序列化：

```cpp
// 使用二进制序列化
struct UserInfo {
    int32_t id;
    char name[32];
    int32_t age;
};

// 客户端
UserInfo user{.id = 1, .age = 25};
strcpy(user.name, "Alice");
co_await client.call("Service", "method", &user, sizeof(user));

// 服务端
Coroutine method(RpcContext& ctx) {
    auto& payload = ctx.request().payload();
    if (payload.size() < sizeof(UserInfo)) {
        ctx.setError(RpcErrorCode::INVALID_REQUEST);
        co_return;
    }

    UserInfo user;
    std::memcpy(&user, payload.data(), sizeof(UserInfo));

    // 处理 user...
}
```

或使用 JSON/Protobuf 等序列化库。

## 流式传输相关

### Q: 流初始化失败

**A:** 检查以下几点：

1. 是否先建立了普通连接：
   ```cpp
   co_await client.connect("127.0.0.1", 9000);  // 必须先连接
   ```

2. 流 ID 是否唯一：
   ```cpp
   auto stream = client.createStream(1, "StreamService", "method");  // 每个流使用不同 ID
   ```

3. 服务端是否正确处理流初始化：
   ```cpp
   class StreamService : public RpcService {
   public:
       StreamService() : RpcService("StreamService") {
           registerStreamMethod("method", &StreamService::streamMethod);
       }

       Coroutine streamMethod(RpcStream& stream) {
           // STREAM_INIT_ACK 由 RpcStreamServer 自动发送
           // ...
           co_return;
       }
   };

   int main() {
       RpcStreamServer server({.port = 9100});
       server.registerService(std::make_shared<StreamService>());
       server.start();
       // ...
   }
   ```

### Q: 流数据传输中断

**A:** 可能原因：

1. 网络连接断开
2. 对端主动关闭流
3. 缓冲区满

检查错误码并处理：

```cpp
while (true) {
    auto r = co_await writer.sendData(data);
    if (!r) {
        std::cerr << "Send failed: " << r.error().message() << "\n";
        break;
    }
    if (r.value()) break;
}
```

### Q: 如何实现双向流？

**A:** 使用独立的读写协程：

```cpp
Coroutine streamWriter(StreamWriter& writer) {
    for (int i = 0; i < 100; ++i) {
        std::string data = "Data " + std::to_string(i);
        while (true) {
            auto r = co_await writer.sendData(data);
            if (!r || r.value()) break;
        }
    }

    while (true) {
        auto r = co_await writer.sendEnd();
        if (!r || r.value()) break;
    }
}

Coroutine streamReader(StreamReader& reader) {
    while (true) {
        StreamMessage msg;
        while (true) {
            auto r = co_await reader.getMessage(msg);
            if (!r || r.value()) break;
        }

        if (msg.isEnd()) break;
        if (msg.isData()) {
            std::cout << "Received: " << msg.payloadStr() << "\n";
        }
    }
}

Coroutine bidirectionalStream(RpcClient& client) {
    co_await client.connect("127.0.0.1", 9000);

    auto stream_result = client.createStream(1, "StreamService", "method");
    if (!stream_result.has_value()) co_return;
    auto stream = stream_result.value();
    auto& writer = stream.getWriter();
    auto& reader = stream.getReader();

    // 初始化流
    // ...

    // 同时启动读写协程
    auto* scheduler = /* 获取调度器 */;
    scheduler->spawn(streamWriter(writer));
    scheduler->spawn(streamReader(reader));
}
```

## 服务发现相关

### Q: 服务发现返回空列表

**A:** 检查以下几点：

1. 服务是否已注册：
   ```cpp
   registry.registerService(endpoint);
   ```

2. 服务名是否正确：
   ```cpp
   auto result = client.getServiceEndpoint("EchoService");  // 必须匹配注册时的名称
   ```

3. 服务是否已注销：
   ```cpp
   registry.deregisterService(endpoint);  // 注销后无法发现
   ```

### Q: 如何实现健康检查？

**A:** 当前版本需要自行实现：

```cpp
class HealthCheckRegistry : public LocalServiceRegistry {
private:
    std::thread m_health_check_thread;
    std::atomic<bool> m_running{true};

public:
    HealthCheckRegistry() {
        m_health_check_thread = std::thread([this] {
            while (m_running.load()) {
                checkHealth();
                std::this_thread::sleep_for(std::chrono::seconds(5));
            }
        });
    }

    ~HealthCheckRegistry() {
        m_running.store(false);
        if (m_health_check_thread.joinable()) {
            m_health_check_thread.join();
        }
    }

private:
    void checkHealth() {
        // 遍历所有已注册的服务进行健康检查
        // 注意：实际 API 不支持通配符查询，需要维护服务列表
        for (const auto& [service_name, endpoints] : m_services) {
            for (const auto& endpoint : endpoints) {
                if (!isHealthy(endpoint)) {
                    deregisterService(endpoint);
                }
            }
        }
    }

    bool isHealthy(const ServiceEndpoint& endpoint) {
        // 实现健康检查逻辑（如 TCP 连接测试）
        return true;
    }
};
```

### Q: 负载均衡策略如何选择？

**A:** 根据场景选择：

- **轮询（RoundRobinSelector）**：实例性能相近，需要均匀分配
- **加权随机（WeightedRandomSelector）**：实例性能不均，按权重分配
- **自定义选择器**：特殊需求（如最少连接、一致性哈希等）

## 性能相关

### Q: QPS 不如预期

**A:** 优化建议：

1. 增加 IO 调度器数量：
   ```cpp
   RpcServerConfig config;
   config.io_scheduler_count = 8;  // 根据 CPU 核心数调整
   ```

2. 增大 RingBuffer：
   ```cpp
   config.ring_buffer_size = 16384;  // 默认 8KB，可增大到 16KB
   ```

3. 减少客户端连接数（过多连接会增加调度开销）

4. 使用连接池复用连接

5. 检查网络延迟

### Q: 内存占用过高

**A:** 优化建议：

1. 减小 RingBuffer 大小：
   ```cpp
   config.ring_buffer_size = 4096;  // 如果 payload 很小
   ```

2. 限制最大连接数：
   ```cpp
   config.backlog = 512;  // 减小监听队列
   ```

3. 及时释放不用的资源

4. 检查是否有内存泄漏

### Q: 延迟过高

**A:** 可能原因：

1. 网络延迟高：检查网络连接
2. 服务端处理慢：优化业务逻辑
3. 连接数过多：减少并发连接
4. 调度器数量不足：增加 IO 调度器

查看性能测试数据：

| 连接数 | QPS | P50 延迟 | P99 延迟 |
|--------|-----|----------|----------|
| 50 | 170K | 223 us | 1,234 us |
| 100 | 183K | 453 us | 2,456 us |
| 200 | 170K | 973 us | 5,678 us |

## 错误处理相关

### Q: 如何区分不同类型的错误？

**A:** 通过 `RpcErrorCode` 判断：

```cpp
if (!result) {
    auto& error = result.error();
    switch (error.code()) {
        case RpcErrorCode::CONNECTION_CLOSED:
            // 连接关闭，需要重连
            break;
        case RpcErrorCode::REQUEST_TIMEOUT:
            // 超时，可以重试
            break;
        case RpcErrorCode::SERVICE_NOT_FOUND:
            // 服务未找到
            break;
        case RpcErrorCode::METHOD_NOT_FOUND:
            // 方法未找到
            break;
        case RpcErrorCode::INVALID_REQUEST:
            // 无效请求
            break;
        default:
            std::cerr << "Error: " << error.message() << "\n";
            break;
    }
}
```

### Q: 服务端如何返回自定义错误？

**A:** 使用 `ctx.setError()`：

```cpp
Coroutine myMethod(RpcContext& ctx) {
    auto& payload = ctx.request().payload();

    if (payload.size() < 4) {
        ctx.setError(RpcErrorCode::INVALID_REQUEST);
        co_return;
    }

    // 正常处理...
    ctx.setPayload(result);
    co_return;
}
```

客户端检查响应：

```cpp
if (result.value()) {
    auto& response = result.value().value();
    if (response.isOk()) {
        // 成功
    } else {
        std::cerr << "Server error: "
                  << rpcErrorCodeToString(response.errorCode()) << "\n";
    }
}
```

### Q: 如何处理超时？

**A:** 设置超时并检查错误码：

```cpp
while (true) {
    auto result = co_await client.call("Service", "method", "data")
        .timeout(std::chrono::milliseconds(5000));

    if (!result) {
        if (result.error().code() == RpcErrorCode::REQUEST_TIMEOUT) {
            std::cerr << "Request timed out, retrying...\n";
            // 重试逻辑
        }
        break;
    }

    if (result.value()) break;
}
```

## 调试相关

### Q: 如何启用调试日志？

**A:** 设置 spdlog 日志级别：

```cpp
#include <spdlog/spdlog.h>

int main() {
    spdlog::set_level(spdlog::level::debug);  // 或 trace

    // 启动服务器/客户端
    // ...
}
```

### Q: 如何查看发送的消息内容？

**A:** 在调用前后打印：

```cpp
std::string data = "Hello";
std::cout << "Sending: " << data << "\n";

auto result = co_await client.call("Service", "method", data);

if (result && result.value()) {
    auto& response = result.value().value();
    std::string resp_data(response.payload().begin(), response.payload().end());
    std::cout << "Received: " << resp_data << "\n";
}
```

### Q: 如何分析性能瓶颈？

**A:** 使用计时器：

```cpp
auto start = std::chrono::steady_clock::now();

// RPC 调用
while (true) {
    auto result = co_await client.call("Service", "method", "data");
    if (!result || result.value()) break;
}

auto end = std::chrono::steady_clock::now();
auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
std::cout << "Call duration: " << duration.count() << " us\n";
```

或使用性能分析工具（如 perf、Instruments）。

## 其他

### Q: 支持哪些平台？

**A:** 理论上支持所有 POSIX 兼容平台：

- Linux（推荐）
- macOS
- FreeBSD
- 其他 Unix-like 系统

Windows 支持需要 WSL 或 Cygwin。

### Q: 是否支持 SSL/TLS？

**A:** 当前版本暂不支持，计划在未来版本中添加。

### Q: 如何贡献代码？

**A:** 欢迎提交 PR 到 GitHub 仓库：

1. Fork 仓库
2. 创建特性分支
3. 提交代码并编写测试
4. 发起 Pull Request

### Q: 如何报告 Bug？

**A:** 在 GitHub Issues 中提交，包含：

- 复现步骤
- 预期行为和实际行为
- 环境信息（OS、编译器、依赖版本）
- 相关日志和错误信息

### Q: 生产环境可以使用吗？

**A:** 项目处于活跃开发中，建议：

- 充分测试后再用于生产
- 关注 GitHub 更新和 Bug 修复
- 做好错误处理和监控
- 准备降级方案

### Q: 与 gRPC 相比有什么优势？

**A:**

- 更轻量级（header-only）
- 基于 C++23 协程的原生异步支持
- 更灵活的流控制（真实流协议）
- 更简单的集成（无需 protoc 编译）
- 更好的性能（RingBuffer + readv/writev）

但 gRPC 生态更成熟，跨语言支持更好。

### Q: 如何实现跨语言调用？

**A:** 当前版本仅支持 C++。如需跨语言：

1. 定义标准的二进制协议格式
2. 在其他语言中实现相同的协议
3. 或使用 HTTP/JSON 网关转换

### Q: 支持多少并发连接？

**A:** 理论上无限制，实际受限于：

- 系统文件描述符限制（ulimit -n）
- 内存大小（每连接约 8-16KB）
- CPU 性能

建议单机不超过 10,000 连接。

### Q: 如何实现服务治理？

**A:** 可以集成：

- 服务注册与发现（etcd、Consul）
- 负载均衡（自定义选择器）
- 熔断降级（自定义拦截器）
- 限流（RateLimiter）
- 监控（MetricsCollector）
- 链路追踪（自定义 request_id 传递）
