# 01-快速开始

## 项目简介

`galay-ssl` 是基于 C++23 协程与 OpenSSL 的异步 SSL/TLS 库，核心目标是把 TLS 握手与加密收发封装为可 `co_await` 的接口，便于在 `galay-kernel` 运行时中构建高并发安全通信服务。

核心能力：

- 异步 `SslSocket`（连接、握手、收发、关闭）
- TLS 1.2 / TLS 1.3、SNI、ALPN、Session 复用
- `std::expected` 错误返回（`SslError` / `IOError`）
- 跨平台 IO 后端（kqueue / epoll / io_uring）

## 依赖

- Galay 内部依赖（构建必需 + 联调推荐）：
  - [galay-kernel](https://github.com/gzj-creator/galay-kernel)（构建必需）
  - [galay-utils](https://github.com/gzj-creator/galay-utils)（推荐）
  - [galay-http](https://github.com/gzj-creator/galay-http)（推荐）
- 第三方依赖：
  - C++23 编译器
  - CMake 3.16+
  - OpenSSL（1.1.1+）
  - spdlog（开启日志时）
  - Linux: liburing（启用 io_uring 时）

## 编译

```bash
git clone https://github.com/gzj-creator/galay-kernel.git
git clone https://github.com/gzj-creator/galay-utils.git
git clone https://github.com/gzj-creator/galay-http.git
git clone https://github.com/gzj-creator/galay-ssl.git
cd galay-ssl
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release -DENABLE_LTO=ON
cmake --build build --parallel
```

仅单独构建 `galay-ssl` 时，最小内部依赖为 `galay-kernel`。

Linux 强制 `epoll`：

```bash
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release -DENABLE_LTO=ON -DDISABLE_IOURING=ON
cmake --build build --parallel
```

## C++23 import/export

工程支持模块接口（工具链支持时）：

```cpp
import galay.ssl;
using namespace galay::ssl;
```

模块接口文件：`galay-ssl/module/galay.ssl.cppm`。  
`BUILD_MODULE_EXAMPLES` 需要 CMake `>= 3.28` 且使用 `Ninja` / `Visual Studio` 生成器，`Unix Makefiles` 下会自动关闭。

## 基本用法

下面示例演示一个最小 SSL 客户端流程：`connect -> handshake -> send -> recv -> shutdown -> close`。

```cpp
#include "galay-ssl/async/SslSocket.h"
#include "galay-ssl/ssl/SslContext.h"
#include <galay-kernel/kernel/Coroutine.h>

#ifdef USE_KQUEUE
#include <galay-kernel/kernel/KqueueScheduler.h>
using IOSchedulerType = galay::kernel::KqueueScheduler;
#elif defined(USE_EPOLL)
#include <galay-kernel/kernel/EpollScheduler.h>
using IOSchedulerType = galay::kernel::EpollScheduler;
#elif defined(USE_IOURING)
#include <galay-kernel/kernel/IOUringScheduler.h>
using IOSchedulerType = galay::kernel::IOUringScheduler;
#endif

using namespace galay::ssl;
using namespace galay::kernel;

Coroutine clientTask(SslContext* ctx)
{
    SslSocket socket(ctx);
    if (!socket.isValid()) co_return;

    socket.option().handleNonBlock();
    socket.setHostname("127.0.0.1");

    auto conn = co_await socket.connect(Host(IPType::IPV4, "127.0.0.1", 8443));
    if (!conn) {
        co_await socket.close();
        co_return;
    }

    while (!socket.isHandshakeCompleted()) {
        auto hs = co_await socket.handshake();
        if (!hs) {
            co_await socket.close();
            co_return;
        }
    }

    const char* msg = "hello";
    auto s = co_await socket.send(msg, 5);
    if (!s) {
        co_await socket.close();
        co_return;
    }

    char buf[1024];
    auto r = co_await socket.recv(buf, sizeof(buf));
    if (r && r.value().size() > 0) {
        // 处理返回数据
    }

    co_await socket.shutdown();
    co_await socket.close();
}
```

## 服务端最小流程

```cpp
Coroutine serverTask(IOScheduler* scheduler, SslContext* ctx, uint16_t port)
{
    SslSocket listener(ctx);
    listener.option().handleReuseAddr();
    listener.option().handleNonBlock();
    listener.bind(Host(IPType::IPV4, "0.0.0.0", port));
    listener.listen(1024);

    while (true) {
        Host peer;
        auto accepted = co_await listener.accept(&peer);
        if (!accepted) continue;

        scheduler->spawn([ctx, h = accepted.value()]() -> Coroutine {
            SslSocket c(ctx, h);
            c.option().handleNonBlock();

            while (!c.isHandshakeCompleted()) {
                auto hs = co_await c.handshake();
                if (!hs) {
                    co_await c.close();
                    co_return;
                }
            }

            char buf[4096];
            while (true) {
                auto r = co_await c.recv(buf, sizeof(buf));
                if (!r || r.value().size() == 0) break;
                auto b = r.value();
                auto s = co_await c.send(reinterpret_cast<const char*>(b.data()), b.size());
                if (!s) break;
            }

            co_await c.shutdown();
            co_await c.close();
        }());
    }
}
```

## 连接与证书

```cpp
// 服务端
SslContext serverCtx(SslMethod::TLS_Server);
serverCtx.loadCertificate("certs/server.crt");
serverCtx.loadPrivateKey("certs/server.key");

// 客户端（验证证书）
SslContext clientCtx(SslMethod::TLS_Client);
clientCtx.loadCACertificate("certs/ca.crt");
clientCtx.setVerifyMode(SslVerifyMode::Peer);

// 客户端（仅测试）
SslContext testCtx(SslMethod::TLS_Client);
testCtx.setVerifyMode(SslVerifyMode::None);
```

## 超时控制

`SslSocket` 中以下接口可直接使用 `.timeout()`：

- `accept()`
- `connect()`
- `recv()`
- `send()`
- `close()`

示例：

```cpp
using namespace std::chrono_literals;

auto conn = co_await socket.connect(Host(IPType::IPV4, "127.0.0.1", 8443)).timeout(3s);
auto sent = co_await socket.send(data, len).timeout(2s);
auto recv = co_await socket.recv(buf, sizeof(buf)).timeout(5s);
```

`handshake()` / `shutdown()` 当前为自定义 Awaitable，不提供 `.timeout()` 接口，建议在业务层结合调度器计时器做超时保护。

## 错误处理

- TLS 相关接口返回 `std::expected<..., SslError>`
- 纯 socket/系统调用相关接口返回 `std::expected<..., IOError>`

示例：

```cpp
auto hs = co_await socket.handshake();
if (!hs) {
    const auto& err = hs.error();
    std::cerr << "handshake failed: " << err.message() << std::endl;
    co_return;
}
```

### 常见 `SslErrorCode`

| 错误码 | 说明 |
|------|------|
| `kContextCreateFailed` | SSL 上下文创建失败 |
| `kCertificateLoadFailed` | 证书加载失败 |
| `kPrivateKeyLoadFailed` | 私钥加载失败 |
| `kPrivateKeyMismatch` | 私钥与证书不匹配 |
| `kCACertificateLoadFailed` | CA 证书加载失败 |
| `kHandshakeFailed` | TLS 握手失败 |
| `kHandshakeWantRead` / `kHandshakeWantWrite` | 需要继续握手流程 |
| `kReadFailed` / `kWriteFailed` | SSL 读写失败 |
| `kPeerClosed` | 对端关闭连接 |
| `kSNISetFailed` | SNI 设置失败 |
| `kALPNSetFailed` | ALPN 设置失败 |

## 运行测试

```bash
# 单元测试
./build/bin/T1-SslSocketTest

# 压测服务端
./build/bin/B1-SslBenchServer 8443 certs/server.crt certs/server.key

# 压测客户端
./build/bin/B1-SslBenchClient 127.0.0.1 8443 200 500 47 4
```

也可以使用脚本：

```bash
./scripts/run.sh build
./scripts/run.sh test
./scripts/run.sh bench
```
