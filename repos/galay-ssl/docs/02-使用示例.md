# 使用示例

## SSL Echo 服务端

```cpp
#include "galay-ssl/async/SslSocket.h"
#include "galay-ssl/ssl/SslContext.h"
#include <galay-kernel/kernel/Coroutine.h>

using namespace galay::ssl;
using namespace galay::kernel;

Coroutine handleClient(SslContext* ctx, GHandle handle)
{
    SslSocket client(ctx, handle);
    client.option().handleNonBlock();

    while (!client.isHandshakeCompleted()) {
        auto hs = co_await client.handshake();
        if (!hs) {
            co_await client.close();
            co_return;
        }
    }

    char buffer[4096];
    while (true) {
        auto r = co_await client.recv(buffer, sizeof(buffer));
        if (!r || r.value().size() == 0) break;

        auto b = r.value();
        auto s = co_await client.send(reinterpret_cast<const char*>(b.data()), b.size());
        if (!s) break;
    }

    co_await client.shutdown();
    co_await client.close();
}

Coroutine runServer(IOScheduler* scheduler, SslContext* ctx, uint16_t port)
{
    SslSocket listener(ctx);
    listener.option().handleReuseAddr();
    listener.option().handleNonBlock();
    listener.bind(Host(IPType::IPV4, "0.0.0.0", port));
    listener.listen(1024);

    while (true) {
        Host peer;
        auto accepted = co_await listener.accept(&peer);
        if (!accepted) continue;
        scheduler->spawn(handleClient(ctx, accepted.value()));
    }
}
```

对应模块化导入版本文件：`examples/import/E1-SslEchoServer.cc`

## SSL 客户端（不校验证书，仅测试）

```cpp
Coroutine runClient(SslContext* ctx, const std::string& host, uint16_t port)
{
    SslSocket socket(ctx);
    socket.option().handleNonBlock();
    socket.setHostname(host);

    auto conn = co_await socket.connect(Host(IPType::IPV4, host, port));
    if (!conn) {
        co_await socket.close();
        co_return;
    }

    while (!socket.isHandshakeCompleted()) {
        auto hs = co_await socket.handshake();
        if (!hs) {
            co_await socket.close();
            co_return;
        }
    }

    std::string msg = "Hello, SSL Server!";
    co_await socket.send(msg.c_str(), msg.size());

    char buf[1024];
    auto r = co_await socket.recv(buf, sizeof(buf));
    if (r && r.value().size() > 0) {
        std::cout << r.value().toStringView() << std::endl;
    }

    co_await socket.shutdown();
    co_await socket.close();
}

// 初始化上下文（测试模式）
SslContext ctx(SslMethod::TLS_Client);
ctx.setVerifyMode(SslVerifyMode::None);
```

对应模块化导入版本文件：`examples/import/E2-SslClient.cc`

## SSL 客户端（校验证书）

```cpp
SslContext ctx(SslMethod::TLS_Client);

auto ca = ctx.loadCACertificate("certs/ca.crt");
if (!ca) {
    std::cerr << ca.error().message() << std::endl;
    return;
}

ctx.setVerifyMode(SslVerifyMode::Peer);
ctx.setVerifyDepth(4);
```

## SNI + ALPN

```cpp
SslContext clientCtx(SslMethod::TLS_Client);
clientCtx.setVerifyMode(SslVerifyMode::Peer);
clientCtx.loadCACertificate("certs/ca.crt");

// ALPN（客户端和服务端都可以配置）
clientCtx.setALPNProtocols({"h2", "http/1.1"});

SslSocket socket(&clientCtx);
socket.setHostname("api.example.com");  // SNI

// 握手成功后读取协商结果
std::string proto = socket.getProtocolVersion();
std::string cipher = socket.getCipher();
std::string alpn = socket.getALPNProtocol();
```

## Session 复用

```cpp
SSL_SESSION* cached = nullptr;

// 第一次连接
{
    SslSocket c1(&ctx);
    co_await c1.connect(Host(IPType::IPV4, "127.0.0.1", 8443));
    while (!c1.isHandshakeCompleted()) {
        auto hs = co_await c1.handshake();
        if (!hs) co_return;
    }

    cached = c1.getSession();  // 调用者负责释放
    co_await c1.shutdown();
    co_await c1.close();
}

// 第二次连接尝试复用
{
    SslSocket c2(&ctx);
    if (cached) {
        c2.setSession(cached);
    }

    co_await c2.connect(Host(IPType::IPV4, "127.0.0.1", 8443));
    while (!c2.isHandshakeCompleted()) {
        auto hs = co_await c2.handshake();
        if (!hs) co_return;
    }

    bool reused = c2.isSessionReused();
    std::cout << "session reused: " << reused << std::endl;

    co_await c2.shutdown();
    co_await c2.close();
}

if (cached) {
    SSL_SESSION_free(cached);
}
```

## 超时示例

```cpp
using namespace std::chrono_literals;

auto conn = co_await socket.connect(Host(IPType::IPV4, "127.0.0.1", 8443)).timeout(3s);
if (!conn) {
    std::cerr << conn.error().message() << std::endl;
    co_return;
}

auto sent = co_await socket.send(data, len).timeout(2s);
if (!sent) {
    std::cerr << sent.error().message() << std::endl;
    co_return;
}

auto recv = co_await socket.recv(buf, sizeof(buf)).timeout(5s);
if (!recv) {
    std::cerr << recv.error().message() << std::endl;
    co_return;
}
```

## 压测示例

```bash
# 终端 1：服务端
./build/bin/B1-SslBenchServer 9443 certs/server.crt certs/server.key

# 终端 2：小包压测（47B）
./build/bin/B1-SslBenchClient 127.0.0.1 9443 200 500 47 4

# 大包压测（64KiB）
./build/bin/B1-SslBenchClient 127.0.0.1 9443 10 200 65536 1

# 启用 benchmark 侧 SSL IO 统计
GALAY_SSL_STATS=1 ./build/bin/B1-SslBenchClient 127.0.0.1 9443 50 200 47 4
```

`B1-SslBenchClient` 参数说明：

- `host`
- `port`
- `connections`
- `requests_per_conn`
- `payload_bytes`（可选，默认 47）
- `threads`（可选，默认 1）
- `connect_retries`（可选，默认 3）
