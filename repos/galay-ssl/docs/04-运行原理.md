# 运行原理

## 整体架构

```text
用户协程
  │
  ├── SslSocket
  │    ├── 握手/收发/关闭 Awaitable（状态机）
  │    └── IOController（对接 galay-kernel 调度器）
  │
  ├── SslEngine
  │    ├── SSL_do_handshake / SSL_read / SSL_write / SSL_shutdown
  │    ├── rbio（网络密文 -> SSL）
  │    └── wbio（SSL -> 网络密文）
  │
  ├── galay-kernel IOScheduler
  │    ├── kqueue（macOS）
  │    ├── epoll（Linux）
  │    └── io_uring（Linux）
  │
  └── 操作系统 Socket
```

核心思想：`SslEngine` 只做 TLS 协议处理，网络读写由 `Awaitable + IOScheduler` 驱动，二者通过 Memory BIO 交换数据。

## 握手状态机

`SslHandshakeAwaitable` 内部根据 `SslEngine::doHandshake()` 的返回值动态组织 IO 任务：

- `Success`：握手完成；若 `wbio` 仍有待发密文（例如 TLS1.3 Ticket），继续发完再返回
- `WantWrite`：从 `wbio` 取密文，注册 `SEND`
- `WantRead`：必要时先 `SEND`，然后注册 `RECV`
- `Error/ZeroReturn`：返回 `SslError`

流程示意：

```text
doHandshake()
  ├─ Success    -> done
  ├─ WantWrite  -> SEND -> doHandshake()
  ├─ WantRead   -> (可选 SEND) + RECV -> feedEncryptedInput -> doHandshake()
  └─ Error      -> fail
```

## 收发状态机

### 接收（`SslRecvAwaitable`）

1. 先尝试 `SSL_read` 直接读明文（处理缓冲区中已解密数据）
2. 若 `WantRead`，发起底层 `RECV` 获取新密文并 `feedEncryptedInput`
3. 若 `WantWrite`，从 `wbio` 取出密文先 `SEND`
4. 循环直到拿到明文、对端关闭或出现错误

### 发送（`SslSendAwaitable`）

1. 把明文喂给 `SSL_write`
2. 从 `wbio` 分块提取密文
3. 循环 `SEND` 直至所有密文发送完成
4. 返回已发送明文字节数或 `SslError`

## Memory BIO 数据流

```text
网络密文 ----recv----> rbio -> SSL_read -> 明文
明文 ----SSL_write----> wbio ----send----> 网络密文
```

这种设计避免了阻塞式 `SSL_set_fd` 路径对事件循环的耦合，更适合协程与边沿触发模型。

## 协程与调度

每个 Awaitable 都实现标准协程三件套：

- `await_ready()`：是否可立即完成
- `await_suspend()`：注册 IO 事件并挂起
- `await_resume()`：恢复时返回 `expected<...>`

`SslSocket` 的 `accept/connect/send/recv/close` 支持 `.timeout()`，由 `galay-kernel::TimeoutSupport` 包装定时器触发唤醒。

## 连接生命周期

```text
创建 Socket
  -> connect / accept
  -> handshake
  -> send / recv (多次)
  -> shutdown
  -> close
```

注意：

- `SslSocket` 析构不自动 `close`
- 服务端每个连接应创建独立 `SslSocket`
- `SslContext` 可共享，`SslSocket`/`SslEngine` 不应跨线程并发操作

## 错误传播

错误由两类 `expected` 传播：

- `IOError`：底层 socket/系统调用问题（连接失败、对端断开、超时等）
- `SslError`：TLS 协议或 OpenSSL 层问题（握手失败、读写失败、证书问题）

业务层通常按以下顺序处理：

1. 记录 `error.message()`
2. 对可恢复错误（如网络抖动）做重试
3. 对不可恢复错误关闭连接并回收资源

## 后端差异

- macOS：默认 `kqueue`
- Linux：优先 `io_uring`，找不到 `liburing` 自动回退 `epoll`
- 可通过 `-DDISABLE_IOURING=ON` 强制 `epoll`

TLS 性能瓶颈通常在加解密与内存搬运，IO 后端差异在纯 SSL Echo 场景下通常不是主导因素。
