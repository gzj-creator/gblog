# 07-架构设计

## 整体分层

Galay-SSL 采用分层实现：

```text
Application
  ├─ SslSocket (异步 SSL Socket API)
  │    ├─ Awaitable (握手/收发/关闭状态机)
  │    └─ IOController (事件控制)
        ↓
  ├─ SslEngine (SSL 状态机)
  │    ├─ SSL_do_handshake / SSL_read / SSL_write
  │    ├─ Memory BIO (rbio/wbio)
  │    └─ SslContext (SSL_CTX 配置)
        ↓
Galay-Kernel (Runtime / IOScheduler / Awaitable)
        ↓
Operating System (kqueue / epoll / io_uring)
```

## 模块职责

### SslContext

- 封装 `SSL_CTX`，管理全局 TLS 配置
- 证书、私钥、CA 证书加载
- 验证模式、密码套件、ALPN 配置
- Session 缓存策略
- 线程安全，可多连接共享

### SslEngine

- 封装单个 `SSL` 对象，对应一条 TLS 连接
- 基于 Memory BIO 的非阻塞状态机
- 握手、加解密、关闭操作
- 与网络 IO 解耦，通过 BIO 交换密文
- 不可拷贝，支持移动

### SslSocket

- 高层异步 SSL Socket API
- 组合 `IOController + SslEngine`
- 提供协程友好的 `co_await` 接口
- 支持服务端（bind/listen/accept）和客户端（connect）
- 超时控制、错误处理

### Awaitable 层

- `SslHandshakeAwaitable`：握手状态机
- `SslRecvAwaitable`：接收状态机
- `SslSendAwaitable`：发送状态机
- `SslShutdownAwaitable`：关闭状态机
- 与 `galay-kernel` 调度器集成

## Memory BIO 架构

### 设计理念

传统 OpenSSL 使用 `SSL_set_fd` 直接绑定 socket，这会导致：

1. SSL 操作阻塞整个线程
2. 难以与事件驱动模型集成
3. 无法精细控制 IO 时机

Memory BIO 方案将 SSL 状态机与网络 IO 完全解耦：

```text
应用层明文 <-> SSL 引擎 <-> Memory BIO <-> 网络密文
```

### BIO 数据流

```text
接收路径：
网络 recv() -> 密文 -> feedEncryptedInput() -> rbio -> SSL_read() -> 明文

发送路径：
明文 -> SSL_write() -> wbio -> extractEncryptedOutput() -> 密文 -> 网络 send()
```

### 优势

1. **非阻塞**：SSL 操作不会阻塞，只是标记需要更多数据
2. **解耦**：SSL 逻辑与 IO 后端（kqueue/epoll/io_uring）完全分离
3. **灵活**：可以精确控制何时读写网络，便于实现超时、流控等
4. **协程友好**：自然适配 `co_await` 语义

## 握手状态机

### 状态转换

```text
初始状态
  ↓
doHandshake()
  ├─ Success → 检查 wbio 是否有待发数据
  │              ├─ 有 → SEND → 完成
  │              └─ 无 → 完成
  ├─ WantWrite → extractEncryptedOutput() → SEND → doHandshake()
  ├─ WantRead → (可选 SEND) → RECV → feedEncryptedInput() → doHandshake()
  └─ Error/ZeroReturn → 失败
```

### 关键点

1. **多轮握手**：TLS 握手通常需要多次网络往返
2. **密文发送**：每次 `WantWrite` 都需要先发送 `wbio` 中的密文
3. **TLS 1.3 优化**：握手成功后可能还有 Session Ticket 需要发送
4. **错误处理**：任何阶段失败都应清理资源并返回错误

### 实现细节

```cpp
// 伪代码
while (!handshake_completed) {
    auto result = engine.doHandshake();

    switch (result) {
    case Success:
        if (engine.pendingEncryptedOutput() > 0) {
            co_await sendEncryptedData();
        }
        handshake_completed = true;
        break;

    case WantWrite:
        co_await sendEncryptedData();
        break;

    case WantRead:
        if (engine.pendingEncryptedOutput() > 0) {
            co_await sendEncryptedData();
        }
        co_await recvEncryptedData();
        engine.feedEncryptedInput(data);
        break;

    case Error:
        co_return SslError(...);
    }
}
```

## 收发状态机

### 接收流程

```text
1. 尝试 SSL_read() 读取已缓冲明文
   ├─ 成功 → 返回明文
   ├─ WantRead → 2
   └─ WantWrite → 3

2. RECV 网络密文
   → feedEncryptedInput()
   → 回到 1

3. SEND wbio 密文（重协商场景）
   → 回到 1
```

### 发送流程

```text
1. SSL_write() 写入明文
   → 明文进入 SSL 引擎

2. 循环提取 wbio 密文
   while (pendingEncryptedOutput() > 0) {
       extractEncryptedOutput()
       → SEND 网络密文
   }

3. 返回已发送明文字节数
```

### 边界情况

1. **对端关闭**：`SSL_read` 返回 0，应返回 `kPeerClosed`
2. **部分发送**：密文可能需要多次 `send` 才能发完
3. **重协商**：接收时可能触发 `WantWrite`，需要先发送密文
4. **缓冲区满**：应用层缓冲区不足时返回已读取的数据

## 关闭状态机

### 双向关闭

TLS 关闭握手是双向的：

```text
主动方：
  SSL_shutdown() → 发送 close_notify
  等待对端 close_notify
  SSL_shutdown() 再次调用 → 完成

被动方：
  接收 close_notify
  SSL_shutdown() → 发送 close_notify
  完成
```

### 实现策略

```cpp
// 伪代码
while (!shutdown_completed) {
    auto result = engine.shutdown();

    switch (result) {
    case Success:
        shutdown_completed = true;
        break;

    case WantWrite:
        co_await sendEncryptedData();
        break;

    case WantRead:
        if (engine.pendingEncryptedOutput() > 0) {
            co_await sendEncryptedData();
        }
        co_await recvEncryptedData();
        engine.feedEncryptedInput(data);
        break;

    case Error:
        // 关闭失败通常不致命，可以直接关闭 socket
        break;
    }
}
```

### 超时处理

关闭握手可能因对端无响应而挂起，建议：

1. 设置关闭超时（如 5 秒）
2. 超时后直接关闭 socket
3. 记录日志但不视为错误

## 协程集成

### Awaitable 三件套

每个 Awaitable 实现标准协程接口：

```cpp
class SslHandshakeAwaitable {
public:
    bool await_ready() const noexcept {
        // 检查是否可立即完成
        return false;
    }

    void await_suspend(std::coroutine_handle<> handle) {
        // 注册 IO 事件，挂起协程
        m_handle = handle;
        // 注册到 IOScheduler
    }

    std::expected<void, SslError> await_resume() {
        // 协程恢复时返回结果
        return m_result;
    }
};
```

### 调度流程

```text
1. 用户协程 co_await awaitable
2. await_suspend() 注册 IO 事件到 IOScheduler
3. 协程挂起，控制权返回调度器
4. IO 事件就绪，调度器唤醒协程
5. await_resume() 返回结果
6. 用户协程继续执行
```

### 超时支持

通过 `galay-kernel::TimeoutSupport` 包装：

```cpp
auto result = co_await socket.recv(buf, len).timeout(5s);
```

内部实现：

1. 启动定时器
2. 同时等待 IO 事件和定时器
3. 哪个先就绪就返回哪个结果
4. 取消另一个事件

## 错误模型

### 错误分类

1. **IOError**：系统调用失败、网络错误、超时
2. **SslError**：TLS 协议错误、证书问题、握手失败

### 错误传播

```text
OpenSSL 错误
  ↓
SslEngine 返回错误码
  ↓
Awaitable 封装为 SslError
  ↓
用户协程通过 expected 检查
```

### 错误恢复

1. **可重试**：`WantRead/WantWrite` 不是错误，继续状态机
2. **不可恢复**：握手失败、证书验证失败，应关闭连接
3. **超时**：可配置重试策略
4. **对端关闭**：正常结束，不是错误

## 内存管理

### 缓冲区策略

1. **接收缓冲区**：`SslSocket` 内部维护密文缓冲区
2. **发送缓冲区**：临时分配，发送完成后释放
3. **明文缓冲区**：由用户提供，零拷贝
4. **BIO 缓冲区**：OpenSSL 内部管理

### 生命周期

```text
SslContext（共享）
  ├─ SslSocket 1
  │    └─ SslEngine 1
  ├─ SslSocket 2
  │    └─ SslEngine 2
  └─ ...
```

1. `SslContext` 必须在所有 `SslSocket` 之前创建
2. `SslContext` 必须在所有 `SslSocket` 销毁后才能销毁
3. `SslSocket` 析构不会自动关闭，需显式 `close()`
4. `SslEngine` 随 `SslSocket` 一起销毁

### 资源清理

```cpp
// 正确的清理顺序
co_await socket.shutdown();  // TLS 关闭握手
co_await socket.close();     // 关闭 socket
// socket 析构，释放 SslEngine
```

## 并发模型

### 单连接串行

同一个 `SslSocket` 实例应串行使用：

```cpp
// 正确
co_await socket.send(data1, len1);
co_await socket.send(data2, len2);

// 错误：不要并发操作同一个 socket
auto t1 = socket.send(data1, len1);
auto t2 = socket.send(data2, len2);
co_await t1;
co_await t2;
```

### 多连接并发

不同 `SslSocket` 实例可以并发：

```cpp
// 服务端：每个连接一个协程
while (true) {
    auto accepted = co_await listener.accept(&peer);
    if (accepted) {
        scheduler->spawn(handleClient(ctx, accepted.value()));
    }
}
```

### 线程安全

1. **SslContext**：线程安全，可跨线程共享
2. **SslSocket**：非线程安全，应在单个协程中使用
3. **SslEngine**：非线程安全，应在单个协程中使用

## 性能考量

### 握手优化

1. **Session 复用**：客户端缓存 Session，减少握手开销
2. **TLS 1.3**：握手更快（1-RTT），优先使用
3. **连接池**：复用连接，避免频繁握手
4. **证书缓存**：服务端证书链缓存

### 数据传输优化

1. **批量发送**：合并小包，减少系统调用
2. **零拷贝**：用户缓冲区直接传递，避免内存拷贝
3. **密码套件**：选择硬件加速支持的套件（AES-NI）
4. **缓冲区大小**：根据负载调整接收缓冲区

### IO 后端选择

1. **macOS**：kqueue（唯一选择）
2. **Linux**：io_uring > epoll
3. **高并发**：io_uring 优势明显
4. **兼容性**：epoll 更稳定

### 瓶颈分析

TLS 性能瓶颈通常在：

1. **加解密**：CPU 密集，考虑硬件加速
2. **内存拷贝**：减少不必要的拷贝
3. **系统调用**：批量操作，减少调用次数
4. **握手开销**：Session 复用，连接池

## 扩展性

### 自定义验证

```cpp
ctx.setVerifyMode(SslVerifyMode::Peer,
    [](bool preverify_ok, X509_STORE_CTX* x509_ctx) -> bool {
        // 自定义验证逻辑
        return preverify_ok;
    });
```

### 自定义 ALPN 选择

服务端可以根据客户端提供的协议列表选择：

```cpp
// 在 SslContext 中配置 ALPN 回调
SSL_CTX_set_alpn_select_cb(ctx.native(), alpn_select_callback, nullptr);
```

### 自定义 SNI 处理

服务端可以根据 SNI 动态选择证书：

```cpp
// 在 SslContext 中配置 SNI 回调
SSL_CTX_set_tlsext_servername_callback(ctx.native(), sni_callback);
```

## 调试与诊断

### 日志记录

建议记录的关键事件：

1. 连接建立/关闭
2. 握手成功/失败
3. 证书验证结果
4. 协商的协议版本和密码套件
5. 错误详情（包括 OpenSSL 错误码）

### 性能监控

关键指标：

1. 握手延迟
2. 数据传输吞吐量
3. 连接数
4. 错误率
5. Session 复用率

### 常见问题排查

1. **握手失败**：检查证书、密码套件、协议版本
2. **性能差**：检查密码套件、Session 复用、连接池
3. **内存泄漏**：检查 Session、证书是否正确释放
4. **连接挂起**：检查超时设置、网络状况

## 与 galay-kernel 集成

### IOScheduler

`SslSocket` 通过 `IOController` 与 `IOScheduler` 集成：

```cpp
IOController m_controller;  // 管理 fd 和事件
```

### 事件注册

```cpp
// 注册读事件
m_controller.registerRead(callback);

// 注册写事件
m_controller.registerWrite(callback);

// 取消事件
m_controller.cancel();
```

### 协程调度

```cpp
// 挂起当前协程
co_await awaitable;

// 调度器在事件就绪时恢复协程
scheduler->resume(coroutine_handle);
```

## 未来优化方向

1. **零拷贝 IO**：利用 `io_uring` 的零拷贝特性
2. **批量握手**：并行处理多个握手
3. **硬件加速**：集成 QAT、AES-NI 等硬件加速
4. **协议扩展**：支持 QUIC、DTLS 等
5. **性能分析**：内置性能统计和分析工具
