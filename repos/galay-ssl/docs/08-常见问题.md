# 08-常见问题

## 编译与构建

### Q: 编译时找不到 OpenSSL 头文件

A: 确保已安装 OpenSSL 开发包，并通过 CMake 变量指定路径：

```bash
# macOS (Homebrew)
cmake -S . -B build -DOPENSSL_ROOT_DIR=/opt/homebrew/opt/openssl

# Linux
sudo apt-get install libssl-dev

# 手动指定路径
cmake -S . -B build \
  -DOPENSSL_INCLUDE_DIR=/path/to/openssl/include \
  -DOPENSSL_LIBRARIES=/path/to/openssl/lib
```

### Q: 链接错误：undefined reference to SSL_xxx

A: 确保链接了 OpenSSL 库：

```cmake
find_package(OpenSSL REQUIRED)
target_link_libraries(your_target PRIVATE
    galay-ssl::galay-ssl
    OpenSSL::SSL
    OpenSSL::Crypto)
```

### Q: 编译时提示需要 C++23

A: 确保使用支持 C++23 的编译器：

```bash
# GCC 13+
cmake -S . -B build -DCMAKE_CXX_COMPILER=g++-13

# Clang 16+
cmake -S . -B build -DCMAKE_CXX_COMPILER=clang++-16
```

### Q: Linux 下找不到 liburing

A: 可以选择安装 liburing 或强制使用 epoll：

```bash
# 安装 liburing
sudo apt-get install liburing-dev

# 或强制使用 epoll
cmake -S . -B build -DDISABLE_IOURING=ON
```

### Q: 模块编译失败

A: 模块编译需要特定条件：

- CMake >= 3.28
- Ninja 或 Visual Studio 生成器
- GCC >= 14 或 Clang >= 16

不满足条件时会自动降级到 include 模式。可以显式关闭：

```bash
cmake -S . -B build -DBUILD_MODULE_EXAMPLES=OFF
```

## 连接与握手

### Q: 握手失败，提示 "certificate verify failed"

A: 这是证书验证失败。检查以下几点：

1. 客户端是否加载了正确的 CA 证书：

```cpp
SslContext ctx(SslMethod::TLS_Client);
ctx.loadCACertificate("certs/ca.crt");
ctx.setVerifyMode(SslVerifyMode::Peer);
```

2. 服务端证书是否由该 CA 签发
3. 证书是否过期
4. 主机名是否匹配（SNI）

测试时可以临时禁用验证：

```cpp
ctx.setVerifyMode(SslVerifyMode::None);  // 仅用于测试！
```

### Q: 握手挂起，没有任何响应

A: 可能的原因：

1. **未设置非阻塞模式**：

```cpp
socket.option().handleNonBlock();  // 必须设置！
```

2. **握手循环条件错误**：

```cpp
// 正确的握手循环
while (!socket.isHandshakeCompleted()) {
    auto result = co_await socket.handshake();
    if (!result) {
        // 处理错误
        co_return;
    }
}
```

3. **网络问题**：检查防火墙、路由

### Q: 客户端连接成功但握手失败

A: 检查协议版本和密码套件是否匹配：

```cpp
// 服务端
SslContext serverCtx(SslMethod::TLS_Server);
serverCtx.setMinProtocolVersion(TLS1_2_VERSION);

// 客户端
SslContext clientCtx(SslMethod::TLS_Client);
clientCtx.setMinProtocolVersion(TLS1_2_VERSION);
```

查看协商失败的具体原因：

```cpp
auto result = co_await socket.handshake();
if (!result) {
    std::cerr << "Handshake failed: " << result.error().message() << '\n';
    std::cerr << "OpenSSL error: " << result.error().sslErrorString() << '\n';
}
```

### Q: 服务端握手失败，提示 "no shared cipher"

A: 客户端和服务端没有共同支持的密码套件。配置兼容的套件：

```cpp
// 服务端
serverCtx.setCiphers("ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256");
serverCtx.setCiphersuites("TLS_AES_256_GCM_SHA384:TLS_AES_128_GCM_SHA256");

// 客户端
clientCtx.setCiphers("ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256");
clientCtx.setCiphersuites("TLS_AES_256_GCM_SHA384:TLS_AES_128_GCM_SHA256");
```

## 数据传输

### Q: recv 返回 0 字节，但连接未关闭

A: 这是正常的，可能的原因：

1. **对端暂时没有数据发送**：继续等待
2. **SSL 缓冲区为空**：需要先接收密文

正确的处理方式：

```cpp
auto result = co_await socket.recv(buf, sizeof(buf));
if (!result) {
    // 错误
    co_return;
}

if (result.value().size() == 0) {
    // 对端关闭连接
    break;
}

// 处理数据
```

### Q: send 返回的字节数小于请求发送的字节数

A: 这在 SSL 中是正常的，可能需要多次调用：

```cpp
size_t total_sent = 0;
while (total_sent < data_len) {
    auto result = co_await socket.send(data + total_sent, data_len - total_sent);
    if (!result) {
        co_return;
    }
    total_sent += result.value();
}
```

或者使用循环直到全部发送：

```cpp
const char* ptr = data;
size_t remaining = data_len;

while (remaining > 0) {
    auto result = co_await socket.send(ptr, remaining);
    if (!result) {
        co_return;
    }

    size_t sent = result.value();
    ptr += sent;
    remaining -= sent;
}
```

### Q: 数据传输时出现 "SSL_ERROR_WANT_READ" 或 "SSL_ERROR_WANT_WRITE"

A: 这不是错误，是 SSL 状态机的正常状态。`SslRecvAwaitable` 和 `SslSendAwaitable` 会自动处理这些状态，用户无需关心。

如果手动使用 `SslEngine`，需要根据返回值继续状态机。

### Q: 大数据传输时性能很差

A: 优化建议：

1. **增大缓冲区**：

```cpp
char buffer[64 * 1024];  // 64KB
auto result = co_await socket.recv(buffer, sizeof(buffer));
```

2. **批量发送**：

```cpp
// 合并多个小包
std::vector<char> batch;
batch.insert(batch.end(), data1, data1 + len1);
batch.insert(batch.end(), data2, data2 + len2);
co_await socket.send(batch.data(), batch.size());
```

3. **选择高性能密码套件**：

```cpp
// 优先使用硬件加速的套件
ctx.setCiphersuites("TLS_AES_128_GCM_SHA256");
```

4. **禁用 Nagle 算法**（低延迟场景）：

```cpp
socket.option().handleNoDelay();
```

## 证书管理

### Q: 如何生成自签名证书用于测试？

A: 使用 OpenSSL 命令行工具：

```bash
# 生成 CA 私钥和证书
openssl req -x509 -newkey rsa:4096 -keyout ca.key -out ca.crt -days 365 -nodes \
  -subj "/C=CN/ST=Beijing/L=Beijing/O=Test/CN=Test CA"

# 生成服务端私钥
openssl genrsa -out server.key 2048

# 生成服务端证书签名请求
openssl req -new -key server.key -out server.csr \
  -subj "/C=CN/ST=Beijing/L=Beijing/O=Test/CN=localhost"

# 用 CA 签发服务端证书
openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial \
  -out server.crt -days 365
```

### Q: 如何加载证书链？

A: 使用 `loadCertificateChain` 方法：

```cpp
// 证书链文件格式（PEM）：
// -----BEGIN CERTIFICATE-----
// (服务端证书)
// -----END CERTIFICATE-----
// -----BEGIN CERTIFICATE-----
// (中间 CA 证书)
// -----END CERTIFICATE-----
// -----BEGIN CERTIFICATE-----
// (根 CA 证书)
// -----END CERTIFICATE-----

SslContext ctx(SslMethod::TLS_Server);
auto result = ctx.loadCertificateChain("server-chain.crt");
if (!result) {
    std::cerr << "Failed to load certificate chain: "
              << result.error().message() << '\n';
}
ctx.loadPrivateKey("server.key");
```

### Q: 如何验证证书链？

A: 客户端配置验证：

```cpp
SslContext ctx(SslMethod::TLS_Client);

// 加载信任的 CA 证书
ctx.loadCACertificate("ca.crt");

// 设置验证模式
ctx.setVerifyMode(SslVerifyMode::Peer);

// 设置验证深度（证书链最大长度）
ctx.setVerifyDepth(4);

// 连接后检查验证结果
long verify_result = socket.getVerifyResult();
if (verify_result != X509_V_OK) {
    std::cerr << "Certificate verification failed: "
              << X509_verify_cert_error_string(verify_result) << '\n';
}
```

### Q: 如何实现双向认证（mTLS）？

A: 服务端和客户端都需要配置证书：

```cpp
// 服务端
SslContext serverCtx(SslMethod::TLS_Server);
serverCtx.loadCertificate("server.crt");
serverCtx.loadPrivateKey("server.key");
serverCtx.loadCACertificate("client-ca.crt");
serverCtx.setVerifyMode(SslVerifyMode::Peer | SslVerifyMode::FailIfNoPeerCert);

// 客户端
SslContext clientCtx(SslMethod::TLS_Client);
clientCtx.loadCertificate("client.crt");
clientCtx.loadPrivateKey("client.key");
clientCtx.loadCACertificate("server-ca.crt");
clientCtx.setVerifyMode(SslVerifyMode::Peer);
```

## Session 复用

### Q: Session 复用不生效

A: 检查以下几点：

1. **服务端是否启用了 Session 缓存**：

```cpp
serverCtx.setSessionCacheMode(SSL_SESS_CACHE_SERVER);
serverCtx.setSessionTimeout(300);  // 5 分钟
```

2. **客户端是否正确设置 Session**：

```cpp
SSL_SESSION* session = first_socket.getSession();
if (session) {
    second_socket.setSession(session);
}
```

3. **Session 是否过期**：检查超时设置

4. **TLS 1.3 Session Ticket**：确保服务端支持

验证是否复用：

```cpp
if (socket.isSessionReused()) {
    std::cout << "Session reused successfully\n";
} else {
    std::cout << "Full handshake performed\n";
}
```

### Q: 如何持久化 Session？

A: 将 Session 序列化保存：

```cpp
// 保存 Session
SSL_SESSION* session = socket.getSession();
if (session) {
    unsigned char* data = nullptr;
    int len = i2d_SSL_SESSION(session, &data);
    if (len > 0) {
        // 保存 data 到文件或数据库
        std::ofstream file("session.dat", std::ios::binary);
        file.write(reinterpret_cast<char*>(data), len);
        OPENSSL_free(data);
    }
}

// 加载 Session
std::ifstream file("session.dat", std::ios::binary);
std::vector<unsigned char> data((std::istreambuf_iterator<char>(file)),
                                 std::istreambuf_iterator<char>());
const unsigned char* ptr = data.data();
SSL_SESSION* session = d2i_SSL_SESSION(nullptr, &ptr, data.size());
if (session) {
    socket.setSession(session);
    SSL_SESSION_free(session);
}
```

## 性能问题

### Q: 握手延迟很高

A: 优化建议：

1. **使用 TLS 1.3**：握手更快（1-RTT）

```cpp
ctx.setMinProtocolVersion(TLS1_3_VERSION);
```

2. **启用 Session 复用**：避免完整握手

3. **使用 ECDSA 证书**：比 RSA 更快

4. **减少证书链长度**：减少验证开销

### Q: 数据传输吞吐量低

A: 优化建议：

1. **选择硬件加速的密码套件**：

```cpp
// AES-NI 加速
ctx.setCiphersuites("TLS_AES_128_GCM_SHA256");
```

2. **增大缓冲区**：减少系统调用次数

3. **批量操作**：合并小包

4. **使用 io_uring**（Linux）：

```bash
cmake -S . -B build  # 自动检测并启用
```

### Q: CPU 使用率很高

A: 可能的原因和解决方案：

1. **加解密开销**：
   - 使用硬件加速（AES-NI）
   - 选择更快的密码套件
   - 考虑使用专用加密硬件（QAT）

2. **频繁握手**：
   - 启用 Session 复用
   - 使用连接池
   - 增加连接超时时间

3. **内存拷贝**：
   - 使用零拷贝技术
   - 减少不必要的缓冲区操作

### Q: 内存使用持续增长

A: 检查资源泄漏：

1. **Session 未释放**：

```cpp
SSL_SESSION* session = socket.getSession();
// 使用完毕后
SSL_SESSION_free(session);
```

2. **证书未释放**：

```cpp
X509* cert = socket.getPeerCertificate();
// 使用完毕后
X509_free(cert);
```

3. **Socket 未关闭**：

```cpp
co_await socket.shutdown();
co_await socket.close();
```

4. **SslContext 生命周期**：确保在所有 Socket 销毁后才销毁

## 协程与调度

### Q: 协程挂起后无法恢复

A: 可能的原因：

1. **未启动 Runtime**：

```cpp
Runtime runtime;
runtime.start();  // 必须调用！
```

2. **IOScheduler 未运行**：

```cpp
auto* scheduler = runtime.getNextIOScheduler();
if (!scheduler) {
    // 错误处理
}
```

3. **事件未注册**：检查 Awaitable 实现

### Q: 如何设置超时？

A: 使用 `.timeout()` 方法：

```cpp
using namespace std::chrono_literals;

// 连接超时
auto conn = co_await socket.connect(host).timeout(3s);

// 接收超时
auto recv = co_await socket.recv(buf, len).timeout(5s);

// 发送超时
auto send = co_await socket.send(data, len).timeout(2s);
```

注意：`handshake()` 和 `shutdown()` 当前不支持 `.timeout()`，需要在业务层实现。

### Q: 如何取消正在进行的操作？

A: 当前不支持直接取消。建议使用超时机制：

```cpp
auto result = co_await socket.recv(buf, len).timeout(5s);
if (!result) {
    // 超时或错误，关闭连接
    co_await socket.close();
}
```

## 错误处理

### Q: 如何区分不同类型的错误？

A: 检查错误码：

```cpp
auto result = co_await socket.handshake();
if (!result) {
    const auto& err = result.error();

    switch (err.code()) {
    case SslErrorCode::kHandshakeFailed:
        // 握手失败
        break;
    case SslErrorCode::kVerificationFailed:
        // 证书验证失败
        break;
    case SslErrorCode::kTimeout:
        // 超时
        break;
    default:
        // 其他错误
        break;
    }
}
```

### Q: 如何获取详细的 OpenSSL 错误信息？

A: 使用 `sslErrorString()` 方法：

```cpp
auto result = co_await socket.handshake();
if (!result) {
    const auto& err = result.error();
    std::cerr << "Error: " << err.message() << '\n';

    if (err.sslError() != 0) {
        std::cerr << "OpenSSL error: " << err.sslErrorString() << '\n';
    }
}
```

### Q: 错误后如何恢复？

A: 根据错误类型决定：

1. **可重试错误**（网络抖动、超时）：

```cpp
int retries = 3;
while (retries-- > 0) {
    auto result = co_await socket.connect(host).timeout(3s);
    if (result) break;

    co_await std::chrono::milliseconds(1000);  // 等待后重试
}
```

2. **不可恢复错误**（证书验证失败、协议错误）：

```cpp
auto result = co_await socket.handshake();
if (!result) {
    // 记录日志
    std::cerr << "Handshake failed: " << result.error().message() << '\n';

    // 清理资源
    co_await socket.close();
    co_return;
}
```

## 调试技巧

### Q: 如何启用 OpenSSL 调试日志？

A: 设置环境变量：

```bash
export SSLKEYLOGFILE=/tmp/ssl-keys.log
./your_program
```

然后可以用 Wireshark 解密 TLS 流量。

### Q: 如何查看协商的协议和密码套件？

A: 握手完成后查询：

```cpp
std::cout << "Protocol: " << socket.getProtocolVersion() << '\n';
std::cout << "Cipher: " << socket.getCipher() << '\n';
std::cout << "ALPN: " << socket.getALPNProtocol() << '\n';
```

### Q: 如何验证证书链？

A: 使用 OpenSSL 命令行：

```bash
# 验证服务端证书
openssl s_client -connect localhost:8443 -CAfile ca.crt

# 查看证书详情
openssl x509 -in server.crt -text -noout

# 验证证书链
openssl verify -CAfile ca.crt server.crt
```

### Q: 如何抓包分析 TLS 流量？

A: 使用 tcpdump 和 Wireshark：

```bash
# 抓包
sudo tcpdump -i lo0 -w ssl.pcap port 8443

# 用 Wireshark 打开 ssl.pcap
# 如果有 SSLKEYLOGFILE，可以解密流量
```

## 其他问题

### Q: 是否支持 DTLS？

A: `SslContext` 支持 DTLS 方法，但 `SslSocket` 当前仅支持 TCP。UDP 支持需要额外实现。

### Q: 是否支持 QUIC？

A: 当前不支持。QUIC 需要完全不同的实现。

### Q: 如何实现连接池？

A: 参考示例实现：

```cpp
class SslConnectionPool {
public:
    SslConnectionPool(SslContext* ctx, size_t max_size)
        : m_ctx(ctx), m_max_size(max_size) {}

    Coroutine acquire() {
        if (!m_idle.empty()) {
            auto* socket = m_idle.back();
            m_idle.pop_back();
            co_return socket;
        }

        if (m_active.size() < m_max_size) {
            auto* socket = new SslSocket(m_ctx);
            m_active.insert(socket);
            co_return socket;
        }

        // 等待可用连接
        co_await waitForRelease();
        co_return co_await acquire();
    }

    void release(SslSocket* socket) {
        m_active.erase(socket);
        m_idle.push_back(socket);
        notifyWaiters();
    }

private:
    SslContext* m_ctx;
    size_t m_max_size;
    std::unordered_set<SslSocket*> m_active;
    std::vector<SslSocket*> m_idle;
};
```

### Q: 如何处理信号（SIGPIPE）？

A: 在程序启动时忽略 SIGPIPE：

```cpp
#include <signal.h>

int main() {
    signal(SIGPIPE, SIG_IGN);

    // 其他初始化代码
}
```

### Q: 如何实现优雅关闭？

A: 完整的关闭流程：

```cpp
// 1. 停止接受新连接
co_await listener.close();

// 2. 等待现有连接处理完成
co_await waitForActiveConnections();

// 3. 关闭所有连接
for (auto& socket : active_sockets) {
    co_await socket.shutdown();
    co_await socket.close();
}

// 4. 停止 Runtime
runtime.stop();
```
