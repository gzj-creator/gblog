# 09-高级主题

## 证书管理

### 证书格式转换

不同系统和工具使用不同的证书格式，常见的转换操作：

```bash
# PEM 转 DER
openssl x509 -in cert.pem -outform DER -out cert.der

# DER 转 PEM
openssl x509 -in cert.der -inform DER -outform PEM -out cert.pem

# PKCS#12 转 PEM
openssl pkcs12 -in cert.p12 -out cert.pem -nodes

# PEM 转 PKCS#12
openssl pkcs12 -export -in cert.pem -inkey key.pem -out cert.p12
```

在代码中加载不同格式：

```cpp
// PEM 格式（默认）
ctx.loadCertificate("cert.pem", SslFileType::PEM);

// DER 格式
ctx.loadCertificate("cert.der", SslFileType::ASN1);
```

### 证书链构建

完整的证书链包括：服务端证书 → 中间 CA → 根 CA

```bash
# 创建证书链文件
cat server.crt intermediate.crt root.crt > chain.pem

# 验证证书链
openssl verify -CAfile root.crt -untrusted intermediate.crt server.crt
```

在代码中加载：

```cpp
// 方法 1：加载证书链文件
ctx.loadCertificateChain("chain.pem");
ctx.loadPrivateKey("server.key");

// 方法 2：分别加载
ctx.loadCertificate("server.crt");
// OpenSSL 会自动从 CA 证书中构建链
```

### 证书吊销列表（CRL）

检查证书是否被吊销：

```cpp
// 加载 CRL
X509_STORE* store = SSL_CTX_get_cert_store(ctx.native());
X509_LOOKUP* lookup = X509_STORE_add_lookup(store, X509_LOOKUP_file());
X509_load_crl_file(lookup, "crl.pem", X509_FILETYPE_PEM);

// 启用 CRL 检查
X509_STORE_set_flags(store, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);
```

### 在线证书状态协议（OCSP）

OCSP 是 CRL 的替代方案，实时查询证书状态：

```cpp
// 启用 OCSP Stapling（服务端）
SSL_CTX_set_tlsext_status_type(ctx.native(), TLSEXT_STATUSTYPE_ocsp);

// 设置 OCSP 响应回调
SSL_CTX_set_tlsext_status_cb(ctx.native(), ocsp_callback);
```

### 自定义证书验证

实现自定义验证逻辑：

```cpp
ctx.setVerifyMode(SslVerifyMode::Peer,
    [](bool preverify_ok, X509_STORE_CTX* x509_ctx) -> bool {
        // 获取当前验证的证书
        X509* cert = X509_STORE_CTX_get_current_cert(x509_ctx);
        int depth = X509_STORE_CTX_get_error_depth(x509_ctx);
        int err = X509_STORE_CTX_get_error(x509_ctx);

        // 自定义验证逻辑
        if (depth == 0) {
            // 验证服务端证书
            char subject[256];
            X509_NAME_oneline(X509_get_subject_name(cert), subject, sizeof(subject));
            std::cout << "Verifying: " << subject << '\n';

            // 检查特定字段
            // ...
        }

        return preverify_ok;
    });
```

### 证书固定（Certificate Pinning）

提高安全性，防止中间人攻击：

```cpp
// 方法 1：固定公钥
std::string expected_pubkey_hash = "sha256//...";

ctx.setVerifyMode(SslVerifyMode::Peer,
    [expected_pubkey_hash](bool preverify_ok, X509_STORE_CTX* x509_ctx) -> bool {
        if (!preverify_ok) return false;

        X509* cert = X509_STORE_CTX_get_current_cert(x509_ctx);
        int depth = X509_STORE_CTX_get_error_depth(x509_ctx);

        if (depth == 0) {
            // 计算公钥哈希
            EVP_PKEY* pkey = X509_get_pubkey(cert);
            // 比较哈希值
            // ...
            EVP_PKEY_free(pkey);
        }

        return true;
    });

// 方法 2：固定证书
// 直接比较证书内容
```

## TLS 配置优化

### 协议版本选择

根据安全需求和兼容性选择协议版本：

```cpp
// 仅 TLS 1.3（最安全）
ctx.setMinProtocolVersion(TLS1_3_VERSION);
ctx.setMaxProtocolVersion(TLS1_3_VERSION);

// TLS 1.2 和 1.3（推荐）
ctx.setMinProtocolVersion(TLS1_2_VERSION);
ctx.setMaxProtocolVersion(TLS1_3_VERSION);

// 兼容旧客户端（不推荐）
ctx.setMinProtocolVersion(TLS1_VERSION);
```

### 密码套件配置

选择安全且高性能的密码套件：

```cpp
// 高安全性配置（TLS 1.2）
ctx.setCiphers(
    "ECDHE-ECDSA-AES256-GCM-SHA384:"
    "ECDHE-RSA-AES256-GCM-SHA384:"
    "ECDHE-ECDSA-AES128-GCM-SHA256:"
    "ECDHE-RSA-AES128-GCM-SHA256"
);

// TLS 1.3 密码套件
ctx.setCiphersuites(
    "TLS_AES_256_GCM_SHA384:"
    "TLS_CHACHA20_POLY1305_SHA256:"
    "TLS_AES_128_GCM_SHA256"
);

// 性能优先（硬件加速）
ctx.setCiphersuites("TLS_AES_128_GCM_SHA256");
```

密码套件选择原则：

1. **优先 AEAD**：GCM、ChaCha20-Poly1305
2. **优先 ECDHE**：提供前向保密
3. **避免 CBC**：存在 BEAST、Lucky13 等攻击
4. **避免 RC4、MD5、SHA1**：已被破解
5. **考虑硬件加速**：AES-NI 支持 AES-GCM

### 椭圆曲线配置

选择安全的椭圆曲线：

```cpp
// 设置支持的曲线（OpenSSL 1.1.1+）
SSL_CTX_set1_curves_list(ctx.native(), "X25519:P-256:P-384");

// 或使用 NID
int curves[] = {NID_X25519, NID_secp256k1, NID_secp384r1};
SSL_CTX_set1_curves(ctx.native(), curves, 3);
```

推荐曲线：

- **X25519**：性能最好，安全性高
- **P-256**：广泛支持
- **P-384**：更高安全性

### Diffie-Hellman 参数

配置 DH 参数（TLS 1.2 及以下）：

```cpp
// 生成 DH 参数
// openssl dhparam -out dhparam.pem 2048

// 加载 DH 参数
DH* dh = nullptr;
FILE* fp = fopen("dhparam.pem", "r");
if (fp) {
    dh = PEM_read_DHparams(fp, nullptr, nullptr, nullptr);
    fclose(fp);
}

if (dh) {
    SSL_CTX_set_tmp_dh(ctx.native(), dh);
    DH_free(dh);
}

// 或使用自动生成
SSL_CTX_set_dh_auto(ctx.native(), 1);
```

### ALPN 配置

应用层协议协商，用于 HTTP/2、HTTP/3 等：

```cpp
// 服务端
ctx.setALPNProtocols({"h2", "http/1.1"});

// 客户端
ctx.setALPNProtocols({"h2", "http/1.1"});

// 握手后检查协商结果
std::string alpn = socket.getALPNProtocol();
if (alpn == "h2") {
    // 使用 HTTP/2
} else if (alpn == "http/1.1") {
    // 使用 HTTP/1.1
}
```

服务端自定义 ALPN 选择：

```cpp
SSL_CTX_set_alpn_select_cb(ctx.native(),
    [](SSL* ssl, const unsigned char** out, unsigned char* outlen,
       const unsigned char* in, unsigned int inlen, void* arg) -> int {
        // 解析客户端提供的协议列表
        std::vector<std::string> client_protos;
        const unsigned char* p = in;
        while (p < in + inlen) {
            unsigned char len = *p++;
            client_protos.emplace_back(reinterpret_cast<const char*>(p), len);
            p += len;
        }

        // 选择服务端支持的协议
        for (const auto& proto : {"h2", "http/1.1"}) {
            if (std::find(client_protos.begin(), client_protos.end(), proto)
                != client_protos.end()) {
                *out = reinterpret_cast<const unsigned char*>(proto);
                *outlen = strlen(proto);
                return SSL_TLSEXT_ERR_OK;
            }
        }

        return SSL_TLSEXT_ERR_NOACK;
    }, nullptr);
```

### SNI 配置

服务器名称指示，用于虚拟主机：

```cpp
// 客户端设置 SNI
socket.setHostname("www.example.com");

// 服务端处理 SNI
SSL_CTX_set_tlsext_servername_callback(ctx.native(),
    [](SSL* ssl, int* ad, void* arg) -> int {
        const char* servername = SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);
        if (servername) {
            std::cout << "SNI: " << servername << '\n';

            // 根据 SNI 选择不同的证书
            if (strcmp(servername, "www.example.com") == 0) {
                // 加载 example.com 的证书
            } else if (strcmp(servername, "api.example.com") == 0) {
                // 加载 api.example.com 的证书
            }
        }
        return SSL_TLSEXT_ERR_OK;
    });
```

## Session 管理

### Session 缓存策略

配置 Session 缓存以提高性能：

```cpp
// 服务端配置
serverCtx.setSessionCacheMode(SSL_SESS_CACHE_SERVER);
serverCtx.setSessionTimeout(300);  // 5 分钟

// 设置缓存大小
SSL_CTX_sess_set_cache_size(serverCtx.native(), 1024);

// 客户端配置
clientCtx.setSessionCacheMode(SSL_SESS_CACHE_CLIENT);
```

### Session Ticket

TLS 1.3 和 TLS 1.2（RFC 5077）支持 Session Ticket：

```cpp
// 服务端启用 Session Ticket
SSL_CTX_set_options(ctx.native(), SSL_OP_NO_TICKET);  // 禁用
// 或
SSL_CTX_clear_options(ctx.native(), SSL_OP_NO_TICKET);  // 启用

// 设置 Ticket 密钥（用于多服务器共享）
unsigned char key[48];
RAND_bytes(key, sizeof(key));
SSL_CTX_set_tlsext_ticket_keys(ctx.native(), key, sizeof(key));
```

### Session 复用实现

完整的 Session 复用示例：

```cpp
class SessionCache {
public:
    void save(const std::string& host, SSL_SESSION* session) {
        std::lock_guard<std::mutex> lock(m_mutex);

        // 释放旧 Session
        auto it = m_cache.find(host);
        if (it != m_cache.end()) {
            SSL_SESSION_free(it->second);
        }

        // 保存新 Session（增加引用计数）
        SSL_SESSION_up_ref(session);
        m_cache[host] = session;
    }

    SSL_SESSION* load(const std::string& host) {
        std::lock_guard<std::mutex> lock(m_mutex);

        auto it = m_cache.find(host);
        if (it != m_cache.end()) {
            // 增加引用计数
            SSL_SESSION_up_ref(it->second);
            return it->second;
        }
        return nullptr;
    }

    ~SessionCache() {
        for (auto& [host, session] : m_cache) {
            SSL_SESSION_free(session);
        }
    }

private:
    std::mutex m_mutex;
    std::unordered_map<std::string, SSL_SESSION*> m_cache;
};

// 使用示例
SessionCache cache;

// 第一次连接
{
    SslSocket socket(&ctx);
    co_await socket.connect(host);
    // ... 握手 ...

    SSL_SESSION* session = socket.getSession();
    if (session) {
        cache.save(host_string, session);
        SSL_SESSION_free(session);
    }
}

// 第二次连接
{
    SslSocket socket(&ctx);

    SSL_SESSION* session = cache.load(host_string);
    if (session) {
        socket.setSession(session);
        SSL_SESSION_free(session);
    }

    co_await socket.connect(host);
    // ... 握手 ...

    if (socket.isSessionReused()) {
        std::cout << "Session reused!\n";
    }
}
```

## 性能优化

### 连接池实现

减少握手开销的连接池：

```cpp
class SslConnectionPool {
public:
    SslConnectionPool(SslContext* ctx, const Host& host, size_t max_size)
        : m_ctx(ctx), m_host(host), m_max_size(max_size) {}

    Coroutine acquire() {
        std::unique_lock<std::mutex> lock(m_mutex);

        // 复用空闲连接
        if (!m_idle.empty()) {
            auto* socket = m_idle.back();
            m_idle.pop_back();
            m_active.insert(socket);
            co_return socket;
        }

        // 创建新连接
        if (m_active.size() < m_max_size) {
            lock.unlock();

            auto* socket = new SslSocket(m_ctx);
            socket->option().handleNonBlock();

            auto conn = co_await socket->connect(m_host);
            if (!conn) {
                delete socket;
                co_return std::unexpected("Connect failed");
            }

            while (!socket->isHandshakeCompleted()) {
                auto hs = co_await socket->handshake();
                if (!hs) {
                    delete socket;
                    co_return std::unexpected("Handshake failed");
                }
            }

            lock.lock();
            m_active.insert(socket);
            co_return socket;
        }

        // 等待可用连接
        m_cv.wait(lock, [this] { return !m_idle.empty(); });
        co_return co_await acquire();
    }

    void release(SslSocket* socket) {
        std::lock_guard<std::mutex> lock(m_mutex);
        m_active.erase(socket);
        m_idle.push_back(socket);
        m_cv.notify_one();
    }

    ~SslConnectionPool() {
        for (auto* socket : m_active) {
            delete socket;
        }
        for (auto* socket : m_idle) {
            delete socket;
        }
    }

private:
    SslContext* m_ctx;
    Host m_host;
    size_t m_max_size;
    std::mutex m_mutex;
    std::condition_variable m_cv;
    std::unordered_set<SslSocket*> m_active;
    std::vector<SslSocket*> m_idle;
};
```

### 批量操作

减少系统调用次数：

```cpp
// 批量发送
std::vector<std::span<const char>> buffers = {
    {data1, len1},
    {data2, len2},
    {data3, len3}
};

for (const auto& buf : buffers) {
    co_await socket.send(buf.data(), buf.size());
}

// 或合并后发送
std::vector<char> merged;
for (const auto& buf : buffers) {
    merged.insert(merged.end(), buf.begin(), buf.end());
}
co_await socket.send(merged.data(), merged.size());
```

### 零拷贝技术

减少内存拷贝：

```cpp
// 使用 std::span 避免拷贝
std::span<const uint8_t> data = get_data();
co_await socket.send(reinterpret_cast<const char*>(data.data()), data.size());

// 接收时直接使用用户缓冲区
char buffer[64 * 1024];
auto result = co_await socket.recv(buffer, sizeof(buffer));
// result.value() 是 std::span，指向 buffer
```

### 硬件加速

利用 CPU 指令集加速：

```cpp
// 检查 AES-NI 支持
#include <cpuid.h>

bool has_aes_ni() {
    unsigned int eax, ebx, ecx, edx;
    if (__get_cpuid(1, &eax, &ebx, &ecx, &edx)) {
        return (ecx & bit_AES) != 0;
    }
    return false;
}

// 优先使用 AES-GCM
if (has_aes_ni()) {
    ctx.setCiphersuites("TLS_AES_128_GCM_SHA256");
} else {
    ctx.setCiphersuites("TLS_CHACHA20_POLY1305_SHA256");
}
```

### 内存池

减少内存分配开销：

```cpp
class BufferPool {
public:
    BufferPool(size_t buffer_size, size_t pool_size)
        : m_buffer_size(buffer_size) {
        for (size_t i = 0; i < pool_size; ++i) {
            m_pool.push_back(std::make_unique<char[]>(buffer_size));
        }
    }

    char* acquire() {
        std::lock_guard<std::mutex> lock(m_mutex);
        if (m_pool.empty()) {
            return new char[m_buffer_size];
        }
        auto buffer = std::move(m_pool.back());
        m_pool.pop_back();
        return buffer.release();
    }

    void release(char* buffer) {
        std::lock_guard<std::mutex> lock(m_mutex);
        m_pool.push_back(std::unique_ptr<char[]>(buffer));
    }

private:
    size_t m_buffer_size;
    std::mutex m_mutex;
    std::vector<std::unique_ptr<char[]>> m_pool;
};
```

## 安全加固

### 防止降级攻击

```cpp
// 禁用不安全的协议版本
ctx.setMinProtocolVersion(TLS1_2_VERSION);

// 禁用压缩（防止 CRIME 攻击）
SSL_CTX_set_options(ctx.native(), SSL_OP_NO_COMPRESSION);

// 禁用重协商（防止 DoS）
SSL_CTX_set_options(ctx.native(), SSL_OP_NO_RENEGOTIATION);
```

### 防止时序攻击

```cpp
// 使用常量时间比较
bool constant_time_compare(const void* a, const void* b, size_t len) {
    return CRYPTO_memcmp(a, b, len) == 0;
}
```

### 密钥保护

```cpp
// 使用内存锁定防止密钥被交换到磁盘
#include <sys/mman.h>

void* secure_alloc(size_t size) {
    void* ptr = mmap(nullptr, size, PROT_READ | PROT_WRITE,
                     MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (ptr != MAP_FAILED) {
        mlock(ptr, size);
    }
    return ptr;
}

void secure_free(void* ptr, size_t size) {
    // 清零内存
    OPENSSL_cleanse(ptr, size);
    munlock(ptr, size);
    munmap(ptr, size);
}
```

### 随机数生成

```cpp
// 确保使用安全的随机数生成器
unsigned char random_bytes[32];
if (RAND_bytes(random_bytes, sizeof(random_bytes)) != 1) {
    // 错误处理
}

// 检查随机数生成器状态
if (RAND_status() != 1) {
    // 熵不足，需要添加熵源
    RAND_poll();
}
```

## 监控与诊断

### 性能指标收集

```cpp
struct SslMetrics {
    std::atomic<uint64_t> handshakes{0};
    std::atomic<uint64_t> handshake_failures{0};
    std::atomic<uint64_t> session_reuses{0};
    std::atomic<uint64_t> bytes_sent{0};
    std::atomic<uint64_t> bytes_received{0};
    std::atomic<uint64_t> active_connections{0};

    void recordHandshake(bool success, bool reused) {
        handshakes.fetch_add(1, std::memory_order_relaxed);
        if (!success) {
            handshake_failures.fetch_add(1, std::memory_order_relaxed);
        }
        if (reused) {
            session_reuses.fetch_add(1, std::memory_order_relaxed);
        }
    }

    void recordTraffic(size_t sent, size_t received) {
        bytes_sent.fetch_add(sent, std::memory_order_relaxed);
        bytes_received.fetch_add(received, std::memory_order_relaxed);
    }

    void print() const {
        std::cout << "Handshakes: " << handshakes << '\n';
        std::cout << "Failures: " << handshake_failures << '\n';
        std::cout << "Session reuses: " << session_reuses << '\n';
        std::cout << "Bytes sent: " << bytes_sent << '\n';
        std::cout << "Bytes received: " << bytes_received << '\n';
        std::cout << "Active connections: " << active_connections << '\n';
    }
};
```

### 日志记录

```cpp
class SslLogger {
public:
    static void logHandshake(const SslSocket& socket, bool success) {
        if (success) {
            std::cout << "[SSL] Handshake successful\n";
            std::cout << "  Protocol: " << socket.getProtocolVersion() << '\n';
            std::cout << "  Cipher: " << socket.getCipher() << '\n';
            std::cout << "  ALPN: " << socket.getALPNProtocol() << '\n';
            std::cout << "  Session reused: " << socket.isSessionReused() << '\n';
        } else {
            std::cerr << "[SSL] Handshake failed\n";
        }
    }

    static void logCertificate(const SslSocket& socket) {
        X509* cert = socket.getPeerCertificate();
        if (cert) {
            char subject[256];
            X509_NAME_oneline(X509_get_subject_name(cert), subject, sizeof(subject));
            std::cout << "[SSL] Peer certificate: " << subject << '\n';

            long verify_result = socket.getVerifyResult();
            if (verify_result == X509_V_OK) {
                std::cout << "[SSL] Certificate verification: OK\n";
            } else {
                std::cerr << "[SSL] Certificate verification failed: "
                          << X509_verify_cert_error_string(verify_result) << '\n';
            }

            X509_free(cert);
        }
    }
};
```

### 错误追踪

```cpp
class SslErrorTracker {
public:
    void recordError(const SslError& error) {
        std::lock_guard<std::mutex> lock(m_mutex);
        m_errors[error.code()]++;
        m_recent_errors.push_back({
            std::chrono::system_clock::now(),
            error.message()
        });
        if (m_recent_errors.size() > 100) {
            m_recent_errors.pop_front();
        }
    }

    void printStats() const {
        std::lock_guard<std::mutex> lock(m_mutex);
        std::cout << "Error statistics:\n";
        for (const auto& [code, count] : m_errors) {
            std::cout << "  " << static_cast<int>(code) << ": " << count << '\n';
        }
    }

private:
    mutable std::mutex m_mutex;
    std::unordered_map<SslErrorCode, size_t> m_errors;
    std::deque<std::pair<std::chrono::system_clock::time_point, std::string>> m_recent_errors;
};
```

## 测试与验证

### 单元测试

```cpp
#include <gtest/gtest.h>

TEST(SslContextTest, LoadCertificate) {
    SslContext ctx(SslMethod::TLS_Server);
    auto result = ctx.loadCertificate("test.crt");
    ASSERT_TRUE(result);
}

TEST(SslSocketTest, Handshake) {
    // 创建测试服务器
    // 创建客户端
    // 执行握手
    // 验证结果
}
```

### 压力测试

```cpp
// 并发连接测试
Coroutine stressTest(SslContext* ctx, size_t num_connections) {
    std::vector<Coroutine> tasks;

    for (size_t i = 0; i < num_connections; ++i) {
        tasks.push_back([ctx]() -> Coroutine {
            SslSocket socket(ctx);
            co_await socket.connect(Host(IPType::IPV4, "127.0.0.1", 8443));

            while (!socket.isHandshakeCompleted()) {
                co_await socket.handshake();
            }

            co_await socket.send("test", 4);

            char buf[1024];
            co_await socket.recv(buf, sizeof(buf));

            co_await socket.shutdown();
            co_await socket.close();
        }());
    }

    for (auto& task : tasks) {
        co_await task;
    }
}
```

### 安全审计

```bash
# 使用 testssl.sh 检查服务器配置
./testssl.sh localhost:8443

# 使用 sslyze 扫描
sslyze --regular localhost:8443

# 使用 nmap 检查
nmap --script ssl-enum-ciphers -p 8443 localhost
```
