# 03-示例代码

本文档提供各模块的实用示例代码。所有示例默认使用传统 include 方式，也可以使用 C++23 模块方式（`import galay.utils;`）。

## 核心工具

### String 模块

#### 基本字符串操作

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>

using namespace galay::utils;

int main() {
    // 分割 CSV 数据
    std::string csv = "Alice,30,Engineer";
    auto fields = StringUtils::split(csv, ',');
    std::cout << "Name: " << fields[0] << std::endl;
    std::cout << "Age: " << fields[1] << std::endl;
    std::cout << "Job: " << fields[2] << std::endl;

    // 连接路径
    std::vector<std::string> paths = {"home", "user", "documents"};
    std::string fullPath = "/" + StringUtils::join(paths, "/");
    std::cout << "Path: " << fullPath << std::endl;

    // 清理用户输入
    std::string input = "  hello world  ";
    std::string cleaned = StringUtils::trim(input);
    std::cout << "Cleaned: '" << cleaned << "'" << std::endl;

    return 0;
}
```

#### URL 参数解析

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>
#include <unordered_map>

using namespace galay::utils;

std::unordered_map<std::string, std::string> parseQueryString(const std::string& query) {
    std::unordered_map<std::string, std::string> params;

    auto pairs = StringUtils::split(query, '&');
    for (const auto& pair : pairs) {
        auto kv = StringUtils::split(pair, '=');
        if (kv.size() == 2) {
            params[kv[0]] = kv[1];
        }
    }

    return params;
}

int main() {
    std::string query = "name=Alice&age=30&city=Beijing";
    auto params = parseQueryString(query);

    for (const auto& [key, value] : params) {
        std::cout << key << " = " << value << std::endl;
    }

    return 0;
}
```

#### 十六进制数据处理

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>

using namespace galay::utils;

int main() {
    // 二进制数据转十六进制
    uint8_t data[] = {0x48, 0x65, 0x6C, 0x6C, 0x6F}; // "Hello"
    std::string hex = StringUtils::toHex(data, 5, true);
    std::cout << "Hex: " << hex << std::endl;

    // 十六进制转二进制
    auto bytes = StringUtils::fromHex(hex);
    std::string text(bytes.begin(), bytes.end());
    std::cout << "Text: " << text << std::endl;

    // 可视化十六进制（用于调试）
    std::string visible = StringUtils::toVisibleHex(data, 5);
    std::cout << "Visible: " << visible << std::endl;

    return 0;
}
```

---

### Random 模块

#### 随机数生成

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>

using namespace galay::utils;

int main() {
    auto& rng = Randomizer::instance();

    // 模拟骰子
    int dice = rng.randomInt(1, 6);
    std::cout << "Dice: " << dice << std::endl;

    // 随机概率
    double probability = rng.randomDouble(0.0, 1.0);
    if (probability < 0.5) {
        std::cout << "Heads" << std::endl;
    } else {
        std::cout << "Tails" << std::endl;
    }

    // 生成随机密码
    std::string password = rng.randomString(16);
    std::cout << "Password: " << password << std::endl;

    // 生成 UUID
    std::string uuid = rng.uuid();
    std::cout << "UUID: " << uuid << std::endl;

    return 0;
}
```

#### 随机采样

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>
#include <vector>
#include <algorithm>

using namespace galay::utils;

template<typename T>
std::vector<T> randomSample(const std::vector<T>& data, size_t n) {
    auto& rng = Randomizer::instance();
    std::vector<T> result;

    if (n >= data.size()) {
        return data;
    }

    std::vector<size_t> indices(data.size());
    std::iota(indices.begin(), indices.end(), 0);

    for (size_t i = 0; i < n; ++i) {
        size_t idx = rng.randomInt(i, data.size() - 1);
        std::swap(indices[i], indices[idx]);
        result.push_back(data[indices[i]]);
    }

    return result;
}

int main() {
    std::vector<int> data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    auto sample = randomSample(data, 5);

    std::cout << "Sample: ";
    for (int val : sample) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

---

### System 模块

#### 系统信息收集

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>

using namespace galay::utils;

int main() {
    std::cout << "=== System Information ===" << std::endl;
    std::cout << "Hostname: " << System::hostname() << std::endl;
    std::cout << "CPU Cores: " << System::cpuCount() << std::endl;
    std::cout << "Memory: " << System::memorySize() / (1024 * 1024) << " MB" << std::endl;
    std::cout << "Process ID: " << System::pid() << std::endl;
    std::cout << "Username: " << System::username() << std::endl;

    // 当前时间
    int64_t now = System::timestamp();
    std::string timeStr = System::formatTime(now, "%Y-%m-%d %H:%M:%S");
    std::cout << "Current Time: " << timeStr << std::endl;

    return 0;
}
```

#### 配置文件读写

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>

using namespace galay::utils;

int main() {
    // 写入配置
    std::string config = R"(
server:
  host: 127.0.0.1
  port: 8080
database:
  url: mysql://localhost:3306/mydb
)";

    if (System::writeFile("config.yaml", config)) {
        std::cout << "Config written successfully" << std::endl;
    }

    // 读取配置
    if (System::fileExists("config.yaml")) {
        std::string content = System::readFile("config.yaml");
        std::cout << "Config size: " << System::fileSize("config.yaml") << " bytes" << std::endl;
        std::cout << "Content:\n" << content << std::endl;
    }

    return 0;
}
```

---

## 数据结构

### TrieTree 模块

#### 自动补全

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>
#include <vector>

using namespace galay::utils;

int main() {
    TrieTree trie;

    // 添加词典
    std::vector<std::string> words = {
        "apple", "application", "apply", "banana", "band", "can", "cat"
    };

    for (const auto& word : words) {
        trie.insert(word);
    }

    // 搜索
    std::cout << "Search 'apple': " << (trie.search("apple") ? "Found" : "Not found") << std::endl;
    std::cout << "Search 'app': " << (trie.search("app") ? "Found" : "Not found") << std::endl;

    // 前缀匹配
    std::cout << "Starts with 'app': " << (trie.startsWith("app") ? "Yes" : "No") << std::endl;
    std::cout << "Starts with 'ban': " << (trie.startsWith("ban") ? "Yes" : "No") << std::endl;

    return 0;
}
```

---

### ConsistentHash 模块

#### 分布式缓存

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>
#include <vector>

using namespace galay::utils;

int main() {
    // 创建一致性哈希环
    ConsistentHash<std::string> hash(150); // 150 个虚拟节点

    // 添加缓存服务器
    std::vector<std::string> servers = {
        "cache-1.example.com",
        "cache-2.example.com",
        "cache-3.example.com"
    };

    for (const auto& server : servers) {
        hash.addNode(server);
    }

    // 分配键到服务器
    std::vector<std::string> keys = {
        "user:1001", "user:1002", "user:1003", "user:1004", "user:1005"
    };

    for (const auto& key : keys) {
        auto node = hash.getNode(key);
        if (node) {
            std::cout << key << " -> " << *node << std::endl;
        }
    }

    // 添加新服务器
    std::cout << "\nAdding new server..." << std::endl;
    hash.addNode("cache-4.example.com");

    for (const auto& key : keys) {
        auto node = hash.getNode(key);
        if (node) {
            std::cout << key << " -> " << *node << std::endl;
        }
    }

    return 0;
}
```

---

## 并发编程

### Thread 模块

#### 并行任务处理

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>
#include <vector>

using namespace galay::utils;

int main() {
    ThreadPool pool(4); // 4 个工作线程

    // 提交多个任务
    std::vector<std::future<int>> futures;

    for (int i = 0; i < 10; ++i) {
        auto future = pool.addTask([i]() {
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            return i * i;
        });
        futures.push_back(std::move(future));
    }

    // 收集结果
    std::cout << "Results: ";
    for (auto& future : futures) {
        std::cout << future.get() << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

#### 批量任务等待

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>

using namespace galay::utils;

int main() {
    ThreadPool pool(4);
    TaskWaiter waiter;

    // 添加多个任务
    for (int i = 0; i < 10; ++i) {
        waiter.addTask(pool, [i]() {
            std::cout << "Task " << i << " running on thread "
                      << std::this_thread::get_id() << std::endl;
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        });
    }

    std::cout << "Waiting for all tasks to complete..." << std::endl;
    waiter.wait();
    std::cout << "All tasks completed!" << std::endl;

    return 0;
}
```

---

### Pool 模块

#### 数据库连接池

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>
#include <memory>

using namespace galay::utils;

// 模拟数据库连接
class Connection {
public:
    Connection(int id) : id_(id) {
        std::cout << "Connection " << id_ << " created" << std::endl;
    }

    ~Connection() {
        std::cout << "Connection " << id_ << " destroyed" << std::endl;
    }

    void query(const std::string& sql) {
        std::cout << "Connection " << id_ << " executing: " << sql << std::endl;
    }

private:
    int id_;
};

int main() {
    // 创建连接池
    int nextId = 0;
    ObjectPool<Connection> pool(
        [&nextId]() { return std::make_unique<Connection>(nextId++); },
        5 // 池大小
    );

    // 使用连接
    {
        auto conn1 = pool.acquire();
        conn1->query("SELECT * FROM users");

        auto conn2 = pool.acquire();
        conn2->query("SELECT * FROM orders");

        // 连接自动归还到池中
    }

    // 再次使用（复用之前的连接）
    {
        auto conn = pool.acquire();
        conn->query("SELECT * FROM products");
    }

    return 0;
}
```

---

## 网络与分布式

### RateLimiter 模块

#### API 限流（非阻塞）

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>
#include <thread>
#include <chrono>

using namespace galay::utils;

void handleRequest(TokenBucketLimiter& limiter, int requestId) {
    if (limiter.tryAcquire(1)) {
        std::cout << "Request " << requestId << " accepted" << std::endl;
        // 处理请求
    } else {
        std::cout << "Request " << requestId << " rejected (rate limit)" << std::endl;
    }
}

int main() {
    // 每秒 10 个请求，容量 5
    TokenBucketLimiter limiter(10.0, 5);

    // 模拟请求
    for (int i = 0; i < 20; ++i) {
        handleRequest(limiter, i);
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
    }

    return 0;
}
```

#### 协程限流（需要 galay-kernel）

```cpp
#include <galay-utils/galay-utils.hpp>
#include <galay-kernel/kernel/Runtime.h>
#include <iostream>

using namespace galay::utils;
using namespace galay::kernel;

Coroutine worker(IOScheduler* scheduler, TokenBucketLimiter* limiter, int id) {
    // 等待令牌
    auto result = co_await limiter->acquire(1).timeout(std::chrono::milliseconds(100));

    if (result) {
        std::cout << "Worker " << id << " acquired token" << std::endl;
        // 处理任务
    } else {
        std::cout << "Worker " << id << " timeout" << std::endl;
    }
}

int main() {
    Runtime runtime;
    runtime.start();

    auto* scheduler = runtime.getNextIOScheduler();
    if (!scheduler) return 1;

    TokenBucketLimiter limiter(10.0, 5);

    // 启动多个协程
    for (int i = 0; i < 20; ++i) {
        scheduler->spawn(worker(scheduler, &limiter, i));
    }

    std::this_thread::sleep_for(std::chrono::seconds(2));
    runtime.stop();

    return 0;
}
```

---

### CircuitBreaker 模块

#### 服务调用保护

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>
#include <random>

using namespace galay::utils;

// 模拟不稳定的服务
bool unstableService() {
    static std::random_device rd;
    static std::mt19937 gen(rd());
    static std::uniform_real_distribution<> dis(0.0, 1.0);

    // 30% 失败率
    if (dis(gen) < 0.3) {
        throw std::runtime_error("Service unavailable");
    }

    return true;
}

int main() {
    CircuitBreakerConfig config;
    config.failureThreshold = 3;
    config.successThreshold = 2;
    config.resetTimeout = std::chrono::seconds(5);

    CircuitBreaker cb(config);

    // 模拟请求
    for (int i = 0; i < 20; ++i) {
        try {
            auto result = cb.execute([]() {
                return unstableService();
            });

            std::cout << "Request " << i << " succeeded (state: "
                      << cb.stateString() << ")" << std::endl;
        } catch (const std::exception& e) {
            std::cout << "Request " << i << " failed: " << e.what()
                      << " (state: " << cb.stateString() << ")" << std::endl;
        }

        std::this_thread::sleep_for(std::chrono::milliseconds(500));
    }

    return 0;
}
```

#### 降级处理

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>

using namespace galay::utils;

std::string fetchUserData(int userId) {
    // 可能失败的主服务
    throw std::runtime_error("Primary service down");
}

std::string fetchUserDataFromCache(int userId) {
    // 降级：从缓存获取
    return "Cached data for user " + std::to_string(userId);
}

int main() {
    CircuitBreakerConfig config;
    config.failureThreshold = 3;
    config.resetTimeout = std::chrono::seconds(10);

    CircuitBreaker cb(config);

    // 使用降级
    for (int userId = 1; userId <= 10; ++userId) {
        auto data = cb.executeWithFallback(
            [userId]() { return fetchUserData(userId); },
            [userId]() { return fetchUserDataFromCache(userId); }
        );

        std::cout << "User " << userId << ": " << data << std::endl;
    }

    return 0;
}
```

---

### Balancer 模块

#### 微服务负载均衡

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>

using namespace galay::utils;

struct Server {
    std::string host;
    int port;

    std::string toString() const {
        return host + ":" + std::to_string(port);
    }
};

int main() {
    std::vector<Server> servers = {
        {"192.168.1.10", 8080},
        {"192.168.1.11", 8080},
        {"192.168.1.12", 8080}
    };

    // 轮询
    RoundRobinLoadBalancer<Server> rr(servers);

    std::cout << "=== Round Robin ===" << std::endl;
    for (int i = 0; i < 6; ++i) {
        auto server = rr.select();
        if (server) {
            std::cout << "Request " << i << " -> " << server->toString() << std::endl;
        }
    }

    // 加权轮询
    std::vector<uint32_t> weights = {3, 2, 1}; // 性能比例
    WeightRoundRobinLoadBalancer<Server> wrr(servers, weights);

    std::cout << "\n=== Weighted Round Robin ===" << std::endl;
    for (int i = 0; i < 12; ++i) {
        auto server = wrr.select();
        if (server) {
            std::cout << "Request " << i << " -> " << server->toString() << std::endl;
        }
    }

    return 0;
}
```

---

## 应用框架

### App 模块

#### 命令行工具

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>

using namespace galay::utils;

int main(int argc, char* argv[]) {
    App app("mytool", "A sample command line tool");

    // 定义选项
    app.addOption("--input", "Input file path", true);
    app.addOption("--output", "Output file path", true);
    app.addOption("--format", "Output format (json/xml)", false);

    // 定义标志
    app.addFlag("--verbose", "Enable verbose output");
    app.addFlag("--help", "Show help message");

    // 解析参数
    if (!app.parse(argc, argv)) {
        app.printHelp();
        return 1;
    }

    if (app.hasFlag("--help")) {
        app.printHelp();
        return 0;
    }

    // 获取参数
    std::string input = app.getOption("--input");
    std::string output = app.getOption("--output");
    std::string format = app.getOption("--format");
    bool verbose = app.hasFlag("--verbose");

    if (verbose) {
        std::cout << "Input: " << input << std::endl;
        std::cout << "Output: " << output << std::endl;
        std::cout << "Format: " << (format.empty() ? "default" : format) << std::endl;
    }

    // 处理逻辑
    std::cout << "Processing..." << std::endl;

    return 0;
}
```

---

### Parser 模块

#### INI 配置解析

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>

using namespace galay::utils;

int main() {
    // 创建配置文件
    std::string config = R"(
[server]
host = 127.0.0.1
port = 8080
workers = 4

[database]
url = mysql://localhost:3306/mydb
username = root
password = secret
pool_size = 10

[logging]
level = info
file = /var/log/app.log
)";

    System::writeFile("config.ini", config);

    // 解析配置
    IniParser parser;
    if (!parser.parse("config.ini")) {
        std::cerr << "Failed to parse config" << std::endl;
        return 1;
    }

    // 读取配置
    std::string host = parser.get("server", "host");
    int port = std::stoi(parser.get("server", "port"));
    int workers = std::stoi(parser.get("server", "workers"));

    std::cout << "Server: " << host << ":" << port << std::endl;
    std::cout << "Workers: " << workers << std::endl;

    std::string dbUrl = parser.get("database", "url");
    std::cout << "Database: " << dbUrl << std::endl;

    return 0;
}
```

---

## 综合示例

### Web 服务器框架

```cpp
#include <galay-utils/galay-utils.hpp>
#include <galay-kernel/kernel/Runtime.h>
#include <iostream>
#include <memory>

using namespace galay::utils;
using namespace galay::kernel;

// 请求处理器
class RequestHandler {
public:
    RequestHandler(TokenBucketLimiter* limiter, CircuitBreaker* breaker)
        : limiter_(limiter), breaker_(breaker) {}

    Coroutine handle(IOScheduler* scheduler, int requestId) {
        // 限流
        auto acquired = co_await limiter_->acquire(1).timeout(std::chrono::milliseconds(100));
        if (!acquired) {
            std::cout << "Request " << requestId << " rejected (rate limit)" << std::endl;
            co_return;
        }

        // 熔断保护
        try {
            breaker_->execute([requestId]() {
                std::cout << "Processing request " << requestId << std::endl;
                // 处理请求
                return true;
            });
        } catch (const std::exception& e) {
            std::cout << "Request " << requestId << " failed: " << e.what() << std::endl;
        }
    }

private:
    TokenBucketLimiter* limiter_;
    CircuitBreaker* breaker_;
};

int main() {
    // 初始化运行时
    Runtime runtime;
    runtime.start();

    auto* scheduler = runtime.getNextIOScheduler();
    if (!scheduler) return 1;

    // 限流器：每秒 100 个请求
    TokenBucketLimiter limiter(100.0, 50);

    // 熔断器
    CircuitBreakerConfig cbConfig;
    cbConfig.failureThreshold = 5;
    cbConfig.resetTimeout = std::chrono::seconds(10);
    CircuitBreaker breaker(cbConfig);

    // 请求处理器
    RequestHandler handler(&limiter, &breaker);

    // 模拟请求
    for (int i = 0; i < 200; ++i) {
        scheduler->spawn(handler.handle(scheduler, i));
    }

    std::this_thread::sleep_for(std::chrono::seconds(3));
    runtime.stop();

    return 0;
}
```

### 分布式缓存客户端

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>
#include <unordered_map>

using namespace galay::utils;

class DistributedCache {
public:
    DistributedCache(const std::vector<std::string>& servers)
        : hash_(150) {
        for (const auto& server : servers) {
            hash_.addNode(server);
        }
    }

    void set(const std::string& key, const std::string& value) {
        auto server = hash_.getNode(key);
        if (server) {
            std::cout << "SET " << key << " -> " << *server << std::endl;
            // 实际发送到服务器
        }
    }

    std::string get(const std::string& key) {
        auto server = hash_.getNode(key);
        if (server) {
            std::cout << "GET " << key << " -> " << *server << std::endl;
            // 实际从服务器获取
            return "value";
        }
        return "";
    }

    void addServer(const std::string& server) {
        hash_.addNode(server);
        std::cout << "Added server: " << server << std::endl;
    }

private:
    ConsistentHash<std::string> hash_;
};

int main() {
    std::vector<std::string> servers = {
        "cache-1.example.com",
        "cache-2.example.com",
        "cache-3.example.com"
    };

    DistributedCache cache(servers);

    // 存储数据
    cache.set("user:1001", "Alice");
    cache.set("user:1002", "Bob");
    cache.set("user:1003", "Charlie");

    // 获取数据
    cache.get("user:1001");
    cache.get("user:1002");

    // 扩容
    cache.addServer("cache-4.example.com");

    // 数据重新分布
    cache.get("user:1001");
    cache.get("user:1002");

    return 0;
}
```

## 编译和运行

### 编译单个示例

```bash
g++ -std=c++20 -I/path/to/galay-utils example.cpp -o example -lpthread
./example
```

### 使用 CMake

```cmake
cmake_minimum_required(VERSION 3.16)
project(examples)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

find_package(galay-utils REQUIRED)

add_executable(string_example string_example.cpp)
target_link_libraries(string_example galay-utils)

add_executable(thread_example thread_example.cpp)
target_link_libraries(thread_example galay-utils)
```

### 使用 C++23 模块

```bash
# 编译模块
cmake -S . -B build -G Ninja -DCMAKE_CXX_COMPILER=g++-14
cmake --build build --target galay-utils-modules

# 编译示例
g++-14 -std=c++23 -fmodules-ts example.cpp -o example
```
