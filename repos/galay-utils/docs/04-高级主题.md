# 04-高级主题

本文档介绍 galay-utils 的高级使用技巧、性能优化、最佳实践和常见模式。

## 性能优化

### 字符串操作优化

#### 避免不必要的拷贝

```cpp
#include <galay-utils/galay-utils.hpp>
#include <string_view>

using namespace galay::utils;

// 不推荐：多次拷贝
void processData(const std::string& data) {
    auto parts = StringUtils::split(data, ',');
    for (const auto& part : parts) {
        std::string trimmed = StringUtils::trim(part);
        // 处理 trimmed
    }
}

// 推荐：减少拷贝
void processDataOptimized(std::string_view data) {
    std::string dataStr(data);
    auto parts = StringUtils::split(dataStr, ',');
    for (auto& part : parts) {
        part = StringUtils::trim(part); // 原地修改
        // 处理 part
    }
}
```

#### 预分配内存

```cpp
#include <galay-utils/galay-utils.hpp>

using namespace galay::utils;

// 大量字符串连接
std::string buildLargeString(const std::vector<std::string>& parts) {
    // 预估总大小
    size_t totalSize = 0;
    for (const auto& part : parts) {
        totalSize += part.size();
    }

    std::string result;
    result.reserve(totalSize + parts.size() - 1); // 包括分隔符

    return StringUtils::join(parts, ",");
}
```

### 随机数生成优化

#### 批量生成

```cpp
#include <galay-utils/galay-utils.hpp>
#include <vector>

using namespace galay::utils;

// 批量生成随机数
std::vector<int> generateRandomNumbers(size_t count, int min, int max) {
    auto& rng = Randomizer::instance();
    std::vector<int> numbers;
    numbers.reserve(count);

    for (size_t i = 0; i < count; ++i) {
        numbers.push_back(rng.randomInt(min, max));
    }

    return numbers;
}
```

#### 线程局部随机数生成器

```cpp
#include <galay-utils/galay-utils.hpp>
#include <random>

// 对于极高性能需求，使用线程局部生成器
class FastRandomizer {
public:
    static int randomInt(int min, int max) {
        thread_local std::mt19937 gen(std::random_device{}());
        std::uniform_int_distribution<> dis(min, max);
        return dis(gen);
    }
};
```

### 线程池优化

#### 任务批处理

```cpp
#include <galay-utils/galay-utils.hpp>
#include <vector>

using namespace galay::utils;

// 批量处理任务
template<typename T, typename F>
std::vector<T> parallelMap(const std::vector<T>& data, F func, size_t numThreads) {
    ThreadPool pool(numThreads);
    std::vector<std::future<T>> futures;

    for (const auto& item : data) {
        futures.push_back(pool.addTask([&func, item]() {
            return func(item);
        }));
    }

    std::vector<T> results;
    results.reserve(data.size());
    for (auto& future : futures) {
        results.push_back(future.get());
    }

    return results;
}
```

#### 任务分块

```cpp
#include <galay-utils/galay-utils.hpp>
#include <vector>

using namespace galay::utils;

// 将大任务分块处理
template<typename T>
void processLargeDataset(const std::vector<T>& data, size_t chunkSize) {
    ThreadPool pool(std::thread::hardware_concurrency());
    TaskWaiter waiter;

    for (size_t i = 0; i < data.size(); i += chunkSize) {
        size_t end = std::min(i + chunkSize, data.size());

        waiter.addTask(pool, [&data, i, end]() {
            for (size_t j = i; j < end; ++j) {
                // 处理 data[j]
            }
        });
    }

    waiter.wait();
}
```

### 对象池优化

#### 预热对象池

```cpp
#include <galay-utils/galay-utils.hpp>
#include <memory>

using namespace galay::utils;

template<typename T>
class PrewarmedObjectPool {
public:
    PrewarmedObjectPool(std::function<std::unique_ptr<T>()> factory, size_t size)
        : pool_(factory, size) {
        // 预热：创建所有对象
        std::vector<std::unique_ptr<T>> objects;
        for (size_t i = 0; i < size; ++i) {
            objects.push_back(pool_.acquire());
        }
        // 归还到池中
        for (auto& obj : objects) {
            pool_.release(std::move(obj));
        }
    }

    std::unique_ptr<T> acquire() {
        return pool_.acquire();
    }

    void release(std::unique_ptr<T> obj) {
        pool_.release(std::move(obj));
    }

private:
    ObjectPool<T> pool_;
};
```

### 限流器优化

#### 非阻塞优先

```cpp
#include <galay-utils/galay-utils.hpp>

using namespace galay::utils;

// 优先使用 tryAcquire 避免协程开销
class OptimizedRateLimiter {
public:
    OptimizedRateLimiter(double rate, size_t capacity)
        : limiter_(rate, capacity) {}

    bool tryHandle() {
        // 快速路径：非阻塞
        if (limiter_.tryAcquire(1)) {
            return true;
        }
        return false;
    }

    // 仅在必要时使用协程
    galay::kernel::CustomAwaitable<bool> handleAsync() {
        return limiter_.acquire(1);
    }

private:
    TokenBucketLimiter limiter_;
};
```

## 设计模式

### RAII 资源管理

#### 对象池 RAII 包装

```cpp
#include <galay-utils/galay-utils.hpp>
#include <memory>

using namespace galay::utils;

template<typename T>
class PooledObject {
public:
    PooledObject(ObjectPool<T>* pool, std::unique_ptr<T> obj)
        : pool_(pool), obj_(std::move(obj)) {}

    ~PooledObject() {
        if (obj_) {
            pool_->release(std::move(obj_));
        }
    }

    // 禁止拷贝
    PooledObject(const PooledObject&) = delete;
    PooledObject& operator=(const PooledObject&) = delete;

    // 允许移动
    PooledObject(PooledObject&&) = default;
    PooledObject& operator=(PooledObject&&) = default;

    T* operator->() { return obj_.get(); }
    T& operator*() { return *obj_; }

private:
    ObjectPool<T>* pool_;
    std::unique_ptr<T> obj_;
};

template<typename T>
class ManagedObjectPool {
public:
    ManagedObjectPool(std::function<std::unique_ptr<T>()> factory, size_t size)
        : pool_(factory, size) {}

    PooledObject<T> acquire() {
        return PooledObject<T>(&pool_, pool_.acquire());
    }

private:
    ObjectPool<T> pool_;
};
```

### 策略模式

#### 可配置的负载均衡器

```cpp
#include <galay-utils/galay-utils.hpp>
#include <memory>

using namespace galay::utils;

template<typename T>
class LoadBalancerStrategy {
public:
    virtual ~LoadBalancerStrategy() = default;
    virtual std::optional<T> select() = 0;
    virtual void append(const T& node) = 0;
};

template<typename T>
class RoundRobinStrategy : public LoadBalancerStrategy<T> {
public:
    RoundRobinStrategy(const std::vector<T>& nodes) : balancer_(nodes) {}

    std::optional<T> select() override {
        return balancer_.select();
    }

    void append(const T& node) override {
        balancer_.append(node);
    }

private:
    RoundRobinLoadBalancer<T> balancer_;
};

template<typename T>
class RandomStrategy : public LoadBalancerStrategy<T> {
public:
    RandomStrategy(const std::vector<T>& nodes) : balancer_(nodes) {}

    std::optional<T> select() override {
        return balancer_.select();
    }

    void append(const T& node) override {
        balancer_.append(node);
    }

private:
    RandomLoadBalancer<T> balancer_;
};

template<typename T>
class ConfigurableLoadBalancer {
public:
    ConfigurableLoadBalancer(std::unique_ptr<LoadBalancerStrategy<T>> strategy)
        : strategy_(std::move(strategy)) {}

    std::optional<T> select() {
        return strategy_->select();
    }

    void append(const T& node) {
        strategy_->append(node);
    }

private:
    std::unique_ptr<LoadBalancerStrategy<T>> strategy_;
};
```

### 装饰器模式

#### 带监控的熔断器

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>
#include <chrono>

using namespace galay::utils;

class MonitoredCircuitBreaker {
public:
    MonitoredCircuitBreaker(const CircuitBreakerConfig& config)
        : breaker_(config), totalRequests_(0), successCount_(0), failureCount_(0) {}

    template<typename F>
    auto execute(F&& func) -> decltype(func()) {
        totalRequests_++;

        try {
            auto result = breaker_.execute(std::forward<F>(func));
            successCount_++;
            return result;
        } catch (...) {
            failureCount_++;
            throw;
        }
    }

    void printStats() const {
        std::cout << "=== Circuit Breaker Stats ===" << std::endl;
        std::cout << "Total Requests: " << totalRequests_ << std::endl;
        std::cout << "Success: " << successCount_ << std::endl;
        std::cout << "Failure: " << failureCount_ << std::endl;
        std::cout << "State: " << breaker_.stateString() << std::endl;
        std::cout << "Success Rate: "
                  << (totalRequests_ > 0 ? (successCount_ * 100.0 / totalRequests_) : 0)
                  << "%" << std::endl;
    }

private:
    CircuitBreaker breaker_;
    size_t totalRequests_;
    size_t successCount_;
    size_t failureCount_;
};
```

## 并发模式

### 生产者-消费者

```cpp
#include <galay-utils/galay-utils.hpp>
#include <queue>
#include <mutex>
#include <condition_variable>

using namespace galay::utils;

template<typename T>
class ThreadSafeQueue {
public:
    void push(T value) {
        std::lock_guard<std::mutex> lock(mutex_);
        queue_.push(std::move(value));
        cv_.notify_one();
    }

    bool tryPop(T& value) {
        std::lock_guard<std::mutex> lock(mutex_);
        if (queue_.empty()) {
            return false;
        }
        value = std::move(queue_.front());
        queue_.pop();
        return true;
    }

    T waitAndPop() {
        std::unique_lock<std::mutex> lock(mutex_);
        cv_.wait(lock, [this] { return !queue_.empty(); });
        T value = std::move(queue_.front());
        queue_.pop();
        return value;
    }

private:
    std::queue<T> queue_;
    std::mutex mutex_;
    std::condition_variable cv_;
};

// 使用示例
void producerConsumerExample() {
    ThreadSafeQueue<int> queue;
    ThreadPool pool(4);

    // 生产者
    for (int i = 0; i < 3; ++i) {
        pool.addTask([&queue, i]() {
            for (int j = 0; j < 10; ++j) {
                queue.push(i * 10 + j);
                std::this_thread::sleep_for(std::chrono::milliseconds(100));
            }
        });
    }

    // 消费者
    for (int i = 0; i < 2; ++i) {
        pool.addTask([&queue]() {
            for (int j = 0; j < 15; ++j) {
                int value = queue.waitAndPop();
                std::cout << "Consumed: " << value << std::endl;
            }
        });
    }

    std::this_thread::sleep_for(std::chrono::seconds(5));
}
```

### 读写锁模式

```cpp
#include <galay-utils/galay-utils.hpp>
#include <shared_mutex>
#include <unordered_map>

using namespace galay::utils;

template<typename K, typename V>
class ThreadSafeCache {
public:
    void set(const K& key, const V& value) {
        std::unique_lock<std::shared_mutex> lock(mutex_);
        cache_[key] = value;
    }

    std::optional<V> get(const K& key) const {
        std::shared_lock<std::shared_mutex> lock(mutex_);
        auto it = cache_.find(key);
        if (it != cache_.end()) {
            return it->second;
        }
        return std::nullopt;
    }

    void remove(const K& key) {
        std::unique_lock<std::shared_mutex> lock(mutex_);
        cache_.erase(key);
    }

    size_t size() const {
        std::shared_lock<std::shared_mutex> lock(mutex_);
        return cache_.size();
    }

private:
    mutable std::shared_mutex mutex_;
    std::unordered_map<K, V> cache_;
};
```

## 错误处理

### 异常安全

```cpp
#include <galay-utils/galay-utils.hpp>
#include <memory>

using namespace galay::utils;

// 强异常安全保证
template<typename T>
class SafeObjectPool {
public:
    SafeObjectPool(std::function<std::unique_ptr<T>()> factory, size_t size)
        : pool_(factory, size) {}

    std::unique_ptr<T> acquire() {
        try {
            return pool_.acquire();
        } catch (const std::exception& e) {
            // 记录错误
            std::cerr << "Failed to acquire object: " << e.what() << std::endl;
            throw;
        }
    }

    void release(std::unique_ptr<T> obj) noexcept {
        try {
            pool_.release(std::move(obj));
        } catch (...) {
            // 吞掉异常，保证 noexcept
        }
    }

private:
    ObjectPool<T> pool_;
};
```

### 错误重试

```cpp
#include <galay-utils/galay-utils.hpp>
#include <chrono>
#include <thread>

using namespace galay::utils;

template<typename F>
auto retryWithBackoff(F&& func, size_t maxRetries = 3) -> decltype(func()) {
    size_t retries = 0;
    std::chrono::milliseconds delay(100);

    while (true) {
        try {
            return func();
        } catch (const std::exception& e) {
            retries++;
            if (retries >= maxRetries) {
                throw;
            }

            std::cerr << "Retry " << retries << " after error: " << e.what() << std::endl;
            std::this_thread::sleep_for(delay);
            delay *= 2; // 指数退避
        }
    }
}
```

## 测试技巧

### 模拟和桩

```cpp
#include <galay-utils/galay-utils.hpp>
#include <memory>

using namespace galay::utils;

// 接口
class IService {
public:
    virtual ~IService() = default;
    virtual std::string fetchData(int id) = 0;
};

// 真实实现
class RealService : public IService {
public:
    std::string fetchData(int id) override {
        // 实际网络请求
        return "real data";
    }
};

// 测试桩
class MockService : public IService {
public:
    std::string fetchData(int id) override {
        return "mock data for " + std::to_string(id);
    }
};

// 使用熔断器保护
class ProtectedService {
public:
    ProtectedService(std::unique_ptr<IService> service, const CircuitBreakerConfig& config)
        : service_(std::move(service)), breaker_(config) {}

    std::string fetchData(int id) {
        return breaker_.execute([this, id]() {
            return service_->fetchData(id);
        });
    }

private:
    std::unique_ptr<IService> service_;
    CircuitBreaker breaker_;
};
```

### 性能基准测试

```cpp
#include <galay-utils/galay-utils.hpp>
#include <chrono>
#include <iostream>

using namespace galay::utils;

template<typename F>
void benchmark(const std::string& name, F&& func, size_t iterations) {
    auto start = std::chrono::high_resolution_clock::now();

    for (size_t i = 0; i < iterations; ++i) {
        func();
    }

    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);

    double opsPerSec = iterations * 1000000.0 / duration.count();

    std::cout << name << ":" << std::endl;
    std::cout << "  Total time: " << duration.count() << " us" << std::endl;
    std::cout << "  Ops/sec: " << opsPerSec << std::endl;
}

void runBenchmarks() {
    auto& rng = Randomizer::instance();

    benchmark("StringUtils::split", []() {
        StringUtils::split("a,b,c,d,e", ',');
    }, 100000);

    benchmark("Randomizer::randomInt", [&rng]() {
        rng.randomInt(1, 100);
    }, 1000000);

    CircuitBreaker cb(CircuitBreakerConfig{});
    benchmark("CircuitBreaker::allowRequest", [&cb]() {
        cb.allowRequest();
    }, 10000000);
}
```

## 最佳实践

### 1. 资源管理

```cpp
// 使用 RAII 管理资源
{
    auto obj = pool.acquire();
    // 使用 obj
} // 自动归还

// 避免手动管理
auto obj = pool.acquire();
// ... 可能抛出异常
pool.release(std::move(obj)); // 可能不会执行
```

### 2. 线程安全

```cpp
// 了解模块的线程安全性
Randomizer::instance().randomInt(1, 100); // 线程安全

TrieTree trie; // 非线程安全
std::mutex mutex;
{
    std::lock_guard<std::mutex> lock(mutex);
    trie.insert("word");
}
```

### 3. 性能优化

```cpp
// 预分配容器
std::vector<int> numbers;
numbers.reserve(1000);

// 使用移动语义
auto obj = pool.acquire();
processObject(std::move(obj));

// 避免不必要的拷贝
void process(std::string_view str); // 而不是 const std::string&
```

### 4. 错误处理

```cpp
// 检查返回值
auto node = balancer.select();
if (node) {
    // 使用 *node
} else {
    // 处理错误
}

// 捕获异常
try {
    breaker.execute([]() { /* ... */ });
} catch (const std::exception& e) {
    // 处理错误
}
```

### 5. 配置管理

```cpp
// 使用配置对象
CircuitBreakerConfig config;
config.failureThreshold = 5;
config.successThreshold = 3;
config.resetTimeout = std::chrono::seconds(30);

CircuitBreaker breaker(config);

// 而不是硬编码
// CircuitBreaker breaker(5, 3, 30000); // 不推荐
```

## 调试技巧

### 启用详细日志

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>

using namespace galay::utils;

class LoggingCircuitBreaker {
public:
    LoggingCircuitBreaker(const CircuitBreakerConfig& config)
        : breaker_(config) {}

    template<typename F>
    auto execute(F&& func) -> decltype(func()) {
        std::cout << "[CB] State: " << breaker_.stateString() << std::endl;

        try {
            auto result = breaker_.execute(std::forward<F>(func));
            std::cout << "[CB] Success" << std::endl;
            return result;
        } catch (const std::exception& e) {
            std::cout << "[CB] Failure: " << e.what() << std::endl;
            throw;
        }
    }

private:
    CircuitBreaker breaker_;
};
```

### 性能分析

```cpp
#include <galay-utils/galay-utils.hpp>
#include <chrono>

using namespace galay::utils;

class ProfiledThreadPool {
public:
    ProfiledThreadPool(size_t numThreads) : pool_(numThreads) {}

    template<typename F, typename... Args>
    auto addTask(F&& f, Args&&... args) {
        auto start = std::chrono::high_resolution_clock::now();

        auto future = pool_.addTask([start, f = std::forward<F>(f), ...args = std::forward<Args>(args)]() mutable {
            auto result = f(args...);

            auto end = std::chrono::high_resolution_clock::now();
            auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
            std::cout << "Task completed in " << duration.count() << " ms" << std::endl;

            return result;
        });

        return future;
    }

private:
    ThreadPool pool_;
};
```

## 常见陷阱

### 1. 对象生命周期

```cpp
// 错误：悬空引用
auto& rng = Randomizer::instance();
std::thread t([&rng]() {
    rng.randomInt(1, 100); // 可能在 rng 销毁后访问
});

// 正确：在线程内获取
std::thread t([]() {
    auto& rng = Randomizer::instance();
    rng.randomInt(1, 100);
});
```

### 2. 死锁

```cpp
// 错误：可能死锁
ObjectPool<Connection> pool1(factory, 10);
ObjectPool<Connection> pool2(factory, 10);

auto conn1 = pool1.acquire();
auto conn2 = pool2.acquire(); // 如果两个线程以不同顺序获取

// 正确：统一顺序
auto conn1 = pool1.acquire();
auto conn2 = pool2.acquire();
```

### 3. 竞态条件

```cpp
// 错误：检查和使用之间有竞态
if (limiter.tryAcquire(1)) {
    // 其他线程可能在这里修改状态
    processRequest();
}

// 正确：原子操作
if (limiter.tryAcquire(1)) {
    processRequest();
    // tryAcquire 已经原子地获取了令牌
}
```
