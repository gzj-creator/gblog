# 05-常见问题

## 编译相关

### Q: 编译时找不到头文件

**A:** 确保 CMake 能找到库，使用 `CMAKE_PREFIX_PATH` 指定：

```bash
cmake -S . -B build -DCMAKE_PREFIX_PATH="/path/to/galay-utils"
```

或者设置环境变量：

```bash
export CMAKE_PREFIX_PATH="/path/to/galay-utils"
cmake -S . -B build
```

如果直接使用头文件，确保包含路径正确：

```bash
g++ -std=c++20 -I/path/to/galay-utils example.cpp -o example
```

---

### Q: 链接时出现 undefined reference 错误

**A:** galay-utils 是纯头文件库，但需要链接系统库：

```cmake
target_link_libraries(your_target PRIVATE galay-utils)

# Linux 需要额外链接
if(UNIX AND NOT APPLE)
    target_link_libraries(your_target PRIVATE pthread dl)
endif()

# macOS
if(APPLE)
    target_link_libraries(your_target PRIVATE pthread)
endif()
```

命令行编译：

```bash
# Linux
g++ -std=c++20 example.cpp -o example -lpthread -ldl

# macOS
g++ -std=c++20 example.cpp -o example -lpthread
```

---

### Q: C++23 模块编译失败

**A:** 模块编译有严格的工具链要求：

- CMake >= 3.28
- Ninja 或 Visual Studio 生成器
- GCC >= 14 或 Clang >= 16（非 AppleClang）

检查工具链版本：

```bash
cmake --version
g++ --version
ninja --version
```

不满足条件时会自动降级到 include 路径。如果需要使用模块：

```bash
# GCC 14+
cmake -S . -B build -G Ninja \
  -DCMAKE_CXX_COMPILER=g++-14 \
  -DBUILD_MODULE_TESTS=ON
cmake --build build --parallel

# Clang 16+
cmake -S . -B build -G Ninja \
  -DCMAKE_CXX_COMPILER=clang++-16 \
  -DBUILD_MODULE_TESTS=ON
cmake --build build --parallel
```

---

### Q: 编译时出现 C++20 特性不支持

**A:** 确保编译器支持 C++20：

```bash
# GCC
g++ --version  # 需要 >= 10

# Clang
clang++ --version  # 需要 >= 10

# MSVC
cl  # 需要 Visual Studio 2019 16.8+
```

在 CMakeLists.txt 中显式指定：

```cmake
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)
```

---

### Q: macOS 上编译失败

**A:** macOS 默认使用 AppleClang，可能不支持某些 C++20 特性。建议使用 Homebrew 安装 GCC 或 LLVM：

```bash
# 安装 GCC
brew install gcc

# 使用 GCC 编译
cmake -S . -B build -DCMAKE_CXX_COMPILER=g++-13
cmake --build build --parallel

# 或安装 LLVM
brew install llvm

# 使用 LLVM Clang 编译
cmake -S . -B build -DCMAKE_CXX_COMPILER=/opt/homebrew/opt/llvm/bin/clang++
cmake --build build --parallel
```

---

## 使用相关

### Q: RateLimiter 需要 galay-kernel 吗？

**A:** 部分需要。RateLimiter 提供两种接口：

1. **非阻塞接口**（不需要 galay-kernel）：

```cpp
#include <galay-utils/galay-utils.hpp>

TokenBucketLimiter limiter(100.0, 10);

// 非阻塞尝试
if (limiter.tryAcquire(5)) {
    // 处理请求
}
```

2. **协程接口**（需要 galay-kernel）：

```cpp
#include <galay-utils/galay-utils.hpp>
#include <galay-kernel/kernel/Runtime.h>

TokenBucketLimiter limiter(100.0, 10);

// 协程异步等待
co_await limiter.acquire(5);
```

如果只使用 `tryAcquire()`，不需要 galay-kernel。

---

### Q: 如何选择合适的限流算法？

**A:** 根据场景选择：

| 算法 | 适用场景 | 特点 |
|------|----------|------|
| CountingSemaphore | 并发控制 | 简单，限制并发数 |
| TokenBucketLimiter | API 限流 | 允许突发流量 |
| SlidingWindowLimiter | 精确限流 | 时间窗口内精确计数 |
| LeakyBucketLimiter | 流量整形 | 平滑输出速率 |

示例：

```cpp
// API 限流：允许短时突发
TokenBucketLimiter apiLimiter(100.0, 50); // 100 req/s, 容量 50

// 数据库连接：限制并发数
CountingSemaphore dbSemaphore(10); // 最多 10 个并发连接

// 精确限流：每秒严格 100 个请求
SlidingWindowLimiter strictLimiter(100, std::chrono::seconds(1));
```

---

### Q: 如何选择负载均衡算法？

**A:** 根据需求选择：

| 算法 | 适用场景 | 优点 | 缺点 |
|------|----------|------|------|
| RoundRobin | 节点性能相同 | 简单，公平 | 不考虑负载 |
| WeightRoundRobin | 节点性能不同 | 按权重分配 | 需要配置权重 |
| Random | 简单场景 | 实现简单 | 分布不均匀 |
| WeightedRandom | 节点性能不同 | 按权重随机 | 需要配置权重 |

示例：

```cpp
std::vector<std::string> servers = {"server1", "server2", "server3"};

// 性能相同：轮询
RoundRobinLoadBalancer<std::string> rr(servers);

// 性能不同：加权轮询
std::vector<uint32_t> weights = {5, 3, 2}; // server1 性能最好
WeightRoundRobinLoadBalancer<std::string> wrr(servers, weights);
```

---

### Q: 熔断器什么时候打开？

**A:** 熔断器在连续失败次数达到阈值时打开：

```cpp
CircuitBreakerConfig config;
config.failureThreshold = 5;        // 连续失败 5 次后打开
config.successThreshold = 3;        // 半开状态连续成功 3 次后关闭
config.resetTimeout = std::chrono::seconds(30); // 30 秒后进入半开状态

CircuitBreaker cb(config);
```

状态转换：

```text
Closed (关闭) --[连续失败 5 次]--> Open (开放)
Open (开放) --[30 秒后]--> HalfOpen (半开)
HalfOpen (半开) --[连续成功 3 次]--> Closed (关闭)
HalfOpen (半开) --[任何失败]--> Open (开放)
```

---

### Q: 线程池应该设置多少线程？

**A:** 根据任务类型设置：

1. **CPU 密集型任务**：

```cpp
// 线程数 = CPU 核心数
ThreadPool pool(std::thread::hardware_concurrency());
```

2. **I/O 密集型任务**：

```cpp
// 线程数 = CPU 核心数 * 2 或更多
ThreadPool pool(std::thread::hardware_concurrency() * 2);
```

3. **混合任务**：

```cpp
// 根据实际测试调整
ThreadPool pool(8);
```

示例：

```cpp
#include <galay-utils/galay-utils.hpp>
#include <thread>

using namespace galay::utils;

int main() {
    size_t numThreads = std::thread::hardware_concurrency();
    std::cout << "CPU cores: " << numThreads << std::endl;

    // CPU 密集型
    ThreadPool cpuPool(numThreads);

    // I/O 密集型
    ThreadPool ioPool(numThreads * 2);

    return 0;
}
```

---

### Q: 对象池大小如何设置？

**A:** 根据并发需求和资源限制设置：

```cpp
// 数据库连接池：根据数据库最大连接数
ObjectPool<Connection> dbPool(factory, 20);

// HTTP 客户端池：根据并发请求数
ObjectPool<HttpClient> httpPool(factory, 50);

// 缓冲区池：根据内存限制
ObjectPool<Buffer> bufferPool(factory, 100);
```

建议：

- 最小值：预期并发数
- 最大值：资源限制（内存、连接数等）
- 监控池的使用率，动态调整

---

### Q: 如何处理对象池耗尽？

**A:** 使用 `BlockingObjectPool` 或自定义超时：

```cpp
#include <galay-utils/galay-utils.hpp>

using namespace galay::utils;

// 方法 1：阻塞等待
BlockingObjectPool<Connection> pool(factory, 10);
auto conn = pool.acquire(); // 阻塞直到有可用对象

// 方法 2：非阻塞 + 重试
ObjectPool<Connection> pool2(factory, 10);
std::unique_ptr<Connection> conn2;
int retries = 0;
while (!conn2 && retries < 3) {
    conn2 = pool2.acquire();
    if (!conn2) {
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        retries++;
    }
}

if (!conn2) {
    // 处理失败
}
```

---

## 性能相关

### Q: 为什么性能达不到预期？

**A:** 检查以下几点：

1. **编译优化**：

```bash
# 使用 Release 模式
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release
cmake --build build --parallel
```

2. **避免不必要的拷贝**：

```cpp
// 不推荐
std::string data = getData();
auto parts = StringUtils::split(data, ',');

// 推荐
auto parts = StringUtils::split(getData(), ',');
```

3. **预分配内存**：

```cpp
std::vector<int> numbers;
numbers.reserve(1000); // 预分配
```

4. **使用非阻塞接口**：

```cpp
// 快速路径
if (limiter.tryAcquire(1)) {
    // 处理
}

// 而不是
co_await limiter.acquire(1); // 协程开销
```

---

### Q: 如何测量性能？

**A:** 使用基准测试：

```cpp
#include <galay-utils/galay-utils.hpp>
#include <chrono>
#include <iostream>

using namespace galay::utils;

template<typename F>
void benchmark(const std::string& name, F&& func, size_t iterations) {
    auto start = std::chrono::high_resolution_clock::now();

    for (size_t i = 0; i < iterations; ++i) {
        func();
    }

    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);

    double opsPerSec = iterations * 1000000.0 / duration.count();

    std::cout << name << ":" << std::endl;
    std::cout << "  Total: " << duration.count() << " us" << std::endl;
    std::cout << "  Ops/sec: " << opsPerSec << std::endl;
}

int main() {
    auto& rng = Randomizer::instance();

    benchmark("Randomizer::randomInt", [&rng]() {
        rng.randomInt(1, 100);
    }, 1000000);

    return 0;
}
```

---

### Q: 多线程性能不如预期？

**A:** 检查以下问题：

1. **伪共享**：

```cpp
// 不推荐：可能伪共享
struct Counter {
    std::atomic<int> count1;
    std::atomic<int> count2;
};

// 推荐：缓存行对齐
struct alignas(64) Counter {
    std::atomic<int> count1;
    char padding[60];
};
```

2. **锁竞争**：

```cpp
// 不推荐：频繁加锁
std::mutex mutex;
for (int i = 0; i < 1000000; ++i) {
    std::lock_guard<std::mutex> lock(mutex);
    // 操作
}

// 推荐：批量操作
std::mutex mutex;
std::vector<int> batch;
batch.reserve(1000);
for (int i = 0; i < 1000000; ++i) {
    batch.push_back(i);
    if (batch.size() >= 1000) {
        std::lock_guard<std::mutex> lock(mutex);
        // 批量操作
        batch.clear();
    }
}
```

3. **线程数过多**：

```cpp
// 不推荐：线程数远超 CPU 核心数
ThreadPool pool(100); // 如果只有 8 核

// 推荐：线程数接近 CPU 核心数
ThreadPool pool(std::thread::hardware_concurrency());
```

---

## 调试相关

### Q: 如何调试熔断器状态？

**A:** 添加日志或监控：

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>

using namespace galay::utils;

class DebugCircuitBreaker {
public:
    DebugCircuitBreaker(const CircuitBreakerConfig& config)
        : breaker_(config) {}

    template<typename F>
    auto execute(F&& func) -> decltype(func()) {
        std::cout << "[CB] State: " << breaker_.stateString()
                  << ", Failures: " << breaker_.failureCount()
                  << ", Successes: " << breaker_.successCount() << std::endl;

        try {
            auto result = breaker_.execute(std::forward<F>(func));
            std::cout << "[CB] Request succeeded" << std::endl;
            return result;
        } catch (const std::exception& e) {
            std::cout << "[CB] Request failed: " << e.what() << std::endl;
            throw;
        }
    }

private:
    CircuitBreaker breaker_;
};
```

---

### Q: 如何调试线程池问题？

**A:** 添加任务追踪：

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>
#include <atomic>

using namespace galay::utils;

class DebugThreadPool {
public:
    DebugThreadPool(size_t numThreads) : pool_(numThreads) {}

    template<typename F, typename... Args>
    auto addTask(F&& f, Args&&... args) {
        size_t taskId = nextTaskId_++;

        std::cout << "[Pool] Task " << taskId << " submitted" << std::endl;

        return pool_.addTask([taskId, f = std::forward<F>(f), ...args = std::forward<Args>(args)]() mutable {
            std::cout << "[Pool] Task " << taskId << " started on thread "
                      << std::this_thread::get_id() << std::endl;

            auto result = f(args...);

            std::cout << "[Pool] Task " << taskId << " completed" << std::endl;

            return result;
        });
    }

private:
    ThreadPool pool_;
    std::atomic<size_t> nextTaskId_{0};
};
```

---

### Q: 如何检测内存泄漏？

**A:** 使用工具检测：

```bash
# Valgrind (Linux)
valgrind --leak-check=full ./your_program

# AddressSanitizer (GCC/Clang)
g++ -std=c++20 -fsanitize=address -g example.cpp -o example
./example

# Instruments (macOS)
instruments -t Leaks ./your_program
```

确保正确管理资源：

```cpp
// 使用 RAII
{
    auto obj = pool.acquire();
    // 使用 obj
} // 自动归还

// 使用智能指针
std::unique_ptr<Connection> conn = pool.acquire();
```

---

## 集成相关

### Q: 如何与其他库集成？

**A:** galay-utils 是纯头文件库，易于集成：

```cmake
# CMakeLists.txt
find_package(galay-utils REQUIRED)
find_package(spdlog REQUIRED)
find_package(Boost REQUIRED)

add_executable(myapp main.cpp)
target_link_libraries(myapp
    galay-utils
    spdlog::spdlog
    Boost::boost
)
```

---

### Q: 如何在现有项目中使用？

**A:** 三种方式：

1. **子模块**：

```bash
git submodule add https://github.com/gzj-creator/galay-utils.git third_party/galay-utils
```

2. **安装到系统**：

```bash
cd galay-utils
cmake -S . -B build
sudo cmake --install build
```

3. **直接复制头文件**：

```bash
cp -r galay-utils/galay-utils /path/to/your/project/include/
```

---

### Q: 如何处理版本冲突？

**A:** 使用命名空间隔离：

```cpp
// 如果有冲突，使用完整命名空间
galay::utils::StringUtils::split("a,b,c", ',');

// 或使用别名
namespace gu = galay::utils;
gu::StringUtils::split("a,b,c", ',');
```

---

## 其他问题

### Q: 支持哪些平台？

**A:** 支持主流平台：

- **Linux**: 完整支持
- **macOS**: 完整支持
- **Windows**: 大部分功能支持（部分 POSIX 特性需要适配）

---

### Q: 是否线程安全？

**A:** 各模块线程安全性不同：

| 模块 | 线程安全 |
|------|----------|
| String | 是（无状态） |
| Random | 是（内部锁） |
| System | 部分 |
| Thread | 是 |
| Pool | 是 |
| RateLimiter | 是（无锁） |
| CircuitBreaker | 是（无锁） |
| Balancer | 部分 |
| TrieTree | 否 |
| ConsistentHash | 否 |

详见 [API 索引](02-API索引.md)。

---

### Q: 如何贡献代码？

**A:** 欢迎贡献：

1. Fork 仓库
2. 创建特性分支
3. 提交更改
4. 创建 Pull Request

贡献指南：

- 遵循现有代码风格
- 添加测试
- 更新文档
- 确保所有测试通过

---

### Q: 如何报告 Bug？

**A:** 在 GitHub 上创建 Issue：

1. 描述问题
2. 提供复现步骤
3. 附上环境信息（OS、编译器、版本）
4. 提供最小复现代码

---

### Q: 文档在哪里？

**A:** 文档位于 `docs/` 目录：

- [快速开始](00-快速开始.md)
- [架构设计](01-架构设计.md)
- [API 索引](02-API索引.md)
- [示例代码](03-示例代码.md)
- [高级主题](04-高级主题.md)
- [常见问题](05-常见问题.md)

各模块详细文档：

- [String](string.md), [Random](random.md), [System](system.md)
- [Thread](thread.md), [Pool](pool.md)
- [RateLimiter](ratelimiter.md), [CircuitBreaker](circuitbreaker.md), [Balancer](balancer.md)
- 等等...

---

## 获取帮助

如果以上问题没有解决您的疑问：

1. 查看 [示例代码](03-示例代码.md)
2. 查看 [高级主题](04-高级主题.md)
3. 在 GitHub 上创建 Issue
4. 查看测试代码 `test/test_all.cpp`
